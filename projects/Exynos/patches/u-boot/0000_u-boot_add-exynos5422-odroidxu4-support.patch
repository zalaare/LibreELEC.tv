diff --git a/arch/arm/dts/exynos5422-odroidxu4.dts b/arch/arm/dts/exynos5422-odroidxu4.dts
new file mode 100644
index 0000000000..62db98a12f
--- /dev/null
+++ b/arch/arm/dts/exynos5422-odroidxu4.dts
@@ -0,0 +1,66 @@
+/*
+ * Odroid XU4 device tree source
+ *
+ * Copyright (c) 2014 Samsung Electronics Co., Ltd.
+ *		http://www.samsung.com
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/dts-v1/;
+#include "exynos54xx.dtsi"
+
+/ {
+	model = "Odroid XU4 based on EXYNOS5422";
+	compatible = "samsung,odroidxu3", "samsung,exynos5";
+
+	aliases {
+		serial0 = "/serial@12C00000";
+		console = "/serial@12C20000";
+	};
+
+	memory {
+		device_type = "memory";
+		reg =  <0x40000000 0x10000000
+			0x50000000 0x10000000
+			0x60000000 0x10000000
+			0x70000000 0x10000000
+			0x80000000 0x10000000
+			0x90000000 0x10000000
+			0xa0000000 0x10000000
+			0xb0000000 0xea00000>;
+	};
+
+	adc@12D10000 {
+		u-boot,dm-pre-reloc;
+		status = "okay";
+	};
+
+	i2c@12CA0000 {
+		s2mps11_pmic@66 {
+			compatible = "samsung,s2mps11-pmic";
+			reg = <0x66>;
+		};
+	};
+
+	ehci@12110000 {
+		samsung,vbus-gpio = <&gpx2 6 GPIO_ACTIVE_HIGH>;
+	};
+
+	serial@12C20000 {
+		status="okay";
+	};
+
+	mmc@12200000 {
+		fifoth_val = <0x201f0020>;
+	};
+
+	mmc@12220000 {
+		fifoth_val = <0x201f0020>;
+	};
+
+	emmc-reset {
+		compatible = "samsung,emmc-reset";
+		reset-gpio = <&gpd1 0 0>;
+	};
+};
diff --git a/arch/arm/mach-exynos/Kconfig b/arch/arm/mach-exynos/Kconfig
index 5ac047d892..12a6e1c78a 100644
--- a/arch/arm/mach-exynos/Kconfig
+++ b/arch/arm/mach-exynos/Kconfig
@@ -84,7 +84,11 @@ choice
 	prompt "EXYNOS5 board select"
 
 config TARGET_ODROID_XU3
-	bool "Exynos5422 Odroid board"
+	bool "Exynos5422 Odroid-XU3 board"
+	select OF_CONTROL
+
+config TARGET_ODROID_XU4
+	bool "Exynos5422 Odroid-XU4 board"
 	select OF_CONTROL
 
 config TARGET_ARNDALE
diff --git a/arch/arm/mach-exynos/clock.c b/arch/arm/mach-exynos/clock.c
old mode 100644
new mode 100755
index 3d31f9d524..5ad6a297ec
--- a/arch/arm/mach-exynos/clock.c
+++ b/arch/arm/mach-exynos/clock.c
@@ -951,6 +951,40 @@ static unsigned long exynos4_get_lcd_clk(void)
 	return pclk;
 }
 
+/* exynos5: get the usbdrd clock */
+static unsigned long exynos5_get_usbdrd_clk(void)
+{
+	struct exynos5_clock *clk =
+		(struct exynos5_clock *)samsung_get_base_clock();
+	unsigned int addr;
+	unsigned int sel;
+	unsigned int ratio;
+	unsigned long sclk;
+
+	sel = readl(&clk->src_fsys);
+	sel = (sel >> 28) & 0xf;
+
+	sclk = 24000000;
+	/*
+	 * CLK_DIV_FSYS0
+	 * USBDRD30_RATIO[27:24], SATA_RATIO[23:20]
+	 */
+	addr = (unsigned int)&clk->div_fsys0;
+	ratio = readl(addr);
+
+	ratio = (ratio >> 24) & 0xff;
+
+	return (sclk / (ratio + 1));
+}
+
+unsigned long get_usbdrd_clk(void)
+{
+	if (cpu_is_exynos5())
+		return exynos5_get_usbdrd_clk();
+
+	return	0;
+}
+
 /* get_lcd_clk: return lcd clock frequency */
 static unsigned long exynos5_get_lcd_clk(void)
 {
diff --git a/arch/arm/mach-exynos/include/mach/clk.h b/arch/arm/mach-exynos/include/mach/clk.h
old mode 100644
new mode 100755
index d20b7d2ae3..aa04325a24
--- a/arch/arm/mach-exynos/include/mach/clk.h
+++ b/arch/arm/mach-exynos/include/mach/clk.h
@@ -60,4 +60,6 @@ int set_spi_clk(int periph_id, unsigned int rate);
  */
 unsigned long clock_get_periph_rate(int peripheral);
 
+unsigned long get_usbdrd_clk(void);
+
 #endif
diff --git a/arch/arm/mach-exynos/include/mach/usb.h b/arch/arm/mach-exynos/include/mach/usb.h
new file mode 100755
index 0000000000..4e1e1ab093
--- /dev/null
+++ b/arch/arm/mach-exynos/include/mach/usb.h
@@ -0,0 +1,133 @@
+/*
+ * (C) Copyright 2011 Samsung Electronics Co. Ltd
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef _EXYNOS_USB_H
+#define _EXYNOS_USB_H
+
+/*
+ * SYSREG
+ */
+#define USB_CFG_OFFSET			0x230
+#define USB_CFG_REG			(EXYNOS_SYSREG_BASE + USB_CFG_OFFSET)
+
+/* PHY CONTROL */
+#define USB_DEVICE_PHY_CONTROL_OFFSET	0x0704
+#define USB_DEVICE1_PHY_CONTROL_OFFSET	0x0708
+#define USB_PHY_CONTROL_OFFSET		0x070C
+
+#define USB_DEVICE_PHY_CONTROL		(EXYNOS_POWER_BASE+USB_DEVICE_PHY_CONTROL_OFFSET)
+#define USB_DEVICE1_PHY_CONTROL		(EXYNOS_POWER_BASE+USB_DEVICE1_PHY_CONTROL_OFFSET)
+#define USB_PHY_CONTROL			(EXYNOS_POWER_BASE+USB_PHY_CONTROL_OFFSET)
+
+//==========================
+// Global Registers (Gxxxx)
+//==========================
+// Global Common Registers
+#define rGSBUSCFG0			(USBDEVICE3_LINK_BASE + 0xc100)
+#define rGSBUSCFG1			(USBDEVICE3_LINK_BASE + 0xc104)
+#define rGTXTHRCFG			(USBDEVICE3_LINK_BASE + 0xc108)
+#define rGRXTHRCFG			(USBDEVICE3_LINK_BASE + 0xc10c)
+#define rGCTL				(USBDEVICE3_LINK_BASE + 0xc110)
+#define rGEVTEN				(USBDEVICE3_LINK_BASE + 0xc114)
+#define rGSTS				(USBDEVICE3_LINK_BASE + 0xc118)
+#define rGSNPSID			(USBDEVICE3_LINK_BASE + 0xc120)
+#define rGGPIO				(USBDEVICE3_LINK_BASE + 0xc124)
+#define rGUID				(USBDEVICE3_LINK_BASE + 0xc128)
+#define rGUCTL				(USBDEVICE3_LINK_BASE + 0xc12c)
+#define rGBUSERRADDR_LO			(USBDEVICE3_LINK_BASE + 0xc130)
+#define rGBUSERRADDR_HI			(USBDEVICE3_LINK_BASE + 0xc134)
+
+// Global Port to USB Instance Mapping Registers
+#define rGPRTBIMAP_LO			(USBDEVICE3_LINK_BASE + 0xc138)
+#define rGPRTBIMAP_HI			(USBDEVICE3_LINK_BASE + 0xc13c)
+#define rGPRTBIMAP_HS_LO		(USBDEVICE3_LINK_BASE + 0xc180)
+#define rGPRTBIMAP_HS_HI		(USBDEVICE3_LINK_BASE + 0xc184)
+#define rGPRTBIMAP_FS_LO		(USBDEVICE3_LINK_BASE + 0xc188)
+#define rGPRTBIMAP_FS_HI		(USBDEVICE3_LINK_BASE + 0xc18c)
+
+// Global Hardware Parameter Registers
+#define rGHWPARAMS0			(USBDEVICE3_LINK_BASE + 0xc140)	// 0x20204000 @c510
+#define rGHWPARAMS1			(USBDEVICE3_LINK_BASE + 0xc144)	// 0x0060c93b @c510
+#define rGHWPARAMS2			(USBDEVICE3_LINK_BASE + 0xc148)	// 0x12345678 @c510
+#define rGHWPARAMS3			(USBDEVICE3_LINK_BASE + 0xc14c)	// 0x10420085 @c510
+#define rGHWPARAMS4			(USBDEVICE3_LINK_BASE + 0xc150)	// 0x48820004 @c510
+#define rGHWPARAMS5			(USBDEVICE3_LINK_BASE + 0xc154)	// 0x04204108 @c510
+#define rGHWPARAMS6			(USBDEVICE3_LINK_BASE + 0xc158)	// 0x04008020 @c510
+#define rGHWPARAMS7			(USBDEVICE3_LINK_BASE + 0xc15c)	// 0x018516fe @c510
+#define rGHWPARAMS8			(USBDEVICE3_LINK_BASE + 0xc600)	// 0x00000386 @c510
+
+// Global Debug Registers
+#define rGDBGFIFOSPACE			(USBDEVICE3_LINK_BASE + 0xc160)
+#define rGDBGLTSSM			(USBDEVICE3_LINK_BASE + 0xc164)
+#define rGDBGLSPMUX			(USBDEVICE3_LINK_BASE + 0xc170)
+#define rGDBGLSP			(USBDEVICE3_LINK_BASE + 0xc174)
+#define rGDBGEPINFO0			(USBDEVICE3_LINK_BASE + 0xc178)
+#define rGDBGEPINFO1			(USBDEVICE3_LINK_BASE + 0xc17c)
+
+// Global PHY Registers
+#define rGUSB2PHYCFG			(USBDEVICE3_LINK_BASE + 0xc200)
+#define rGUSB2I2CCTL			(USBDEVICE3_LINK_BASE + 0xc240)
+#define rGUSB2PHYACC			(USBDEVICE3_LINK_BASE + 0xc280)
+#define rGUSB3PIPECTL			(USBDEVICE3_LINK_BASE + 0xc2c0)
+
+// Global FIFO Size Registers (0 <= num <= 15 @510)
+#define rGTXFIFOSIZ(num)		((USBDEVICE3_LINK_BASE + 0xc300) + 0x04*num)
+#define rGRXFIFOSIZ0			(USBDEVICE3_LINK_BASE + 0xc380)
+
+// Global Event Buffer Registers (DWC_USB3_DEVICE_NUM_INT = 1 @C510, GHWPARAMS1[20:15])
+#define rGEVNTADR_LO0			(USBDEVICE3_LINK_BASE + 0xc400)
+#define rGEVNTADR_HI0			(USBDEVICE3_LINK_BASE + 0xc404)
+#define rGEVNTSIZ0			(USBDEVICE3_LINK_BASE + 0xc408)
+#define rGEVNTCOUNT0			(USBDEVICE3_LINK_BASE + 0xc40c)
+
+//==========================
+// Device Registers (Dxxxx)
+//==========================
+// Device Common Registers
+#define rDCFG				(USBDEVICE3_LINK_BASE + 0xc700)
+#define rDCTL				(USBDEVICE3_LINK_BASE + 0xc704)
+#define rDEVTEN				(USBDEVICE3_LINK_BASE + 0xc708)
+#define rDSTS				(USBDEVICE3_LINK_BASE + 0xc70c)
+#define rDGCMDPAR			(USBDEVICE3_LINK_BASE + 0xc710)
+#define rDGCMD				(USBDEVICE3_LINK_BASE + 0xc714)
+#define rDALEPENA			(USBDEVICE3_LINK_BASE + 0xc720)
+
+// Device Endpoint Registers (0 <= ep <= 15)
+#define rDOEPCMDPAR2(ep)		((USBDEVICE3_LINK_BASE + 0xc800) + 0x20*ep)
+#define rDOEPCMDPAR1(ep)		((USBDEVICE3_LINK_BASE + 0xc804) + 0x20*ep)
+#define rDOEPCMDPAR0(ep)		((USBDEVICE3_LINK_BASE + 0xc808) + 0x20*ep)
+#define rDOEPCMD(ep)			((USBDEVICE3_LINK_BASE + 0xc80c) + 0x20*ep)
+
+#define rDIEPCMDPAR2(ep)		((USBDEVICE3_LINK_BASE + 0xc810) + 0x20*ep)
+#define rDIEPCMDPAR1(ep)		((USBDEVICE3_LINK_BASE + 0xc814) + 0x20*ep)
+#define rDIEPCMDPAR0(ep)		((USBDEVICE3_LINK_BASE + 0xc818) + 0x20*ep)
+#define rDIEPCMD(ep)			((USBDEVICE3_LINK_BASE + 0xc81c) + 0x20*ep)
+
+//==========================
+// USB DEVICE PHY CONTROL REGISTERS
+//==========================
+#define EXYNOS_PHY_LINKSYSTEM		(USBDEVICE3_PHYCTRL_BASE + 0x04)
+#define EXYNOS_PHY_UTMI			(USBDEVICE3_PHYCTRL_BASE + 0x08)
+#define EXYNOS_PHY_PIPE			(USBDEVICE3_PHYCTRL_BASE + 0x0C)
+#define EXYNOS_PHY_CLKPWR		(USBDEVICE3_PHYCTRL_BASE + 0x10)
+#define EXYNOS_PHY_REG0			(USBDEVICE3_PHYCTRL_BASE + 0x14)
+#define EXYNOS_PHY_REG1			(USBDEVICE3_PHYCTRL_BASE + 0x18)
+#define EXYNOS_PHY_PARAM0		(USBDEVICE3_PHYCTRL_BASE + 0x1C)
+#define EXYNOS_PHY_PARAM1		(USBDEVICE3_PHYCTRL_BASE + 0x20)
+#define EXYNOS_PHY_TERM			(USBDEVICE3_PHYCTRL_BASE + 0x24)
+#define EXYNOS_PHY_TEST			(USBDEVICE3_PHYCTRL_BASE + 0x28)
+#define EXYNOS_PHY_ADP			(USBDEVICE3_PHYCTRL_BASE + 0x2C)
+#define EXYNOS_PHY_BATCHG		(USBDEVICE3_PHYCTRL_BASE + 0x30)
+#define EXYNOS_PHY_RESUME		(USBDEVICE3_PHYCTRL_BASE + 0x34)
+#define EXYNOS_PHY_LINK_PORT		(USBDEVICE3_PHYCTRL_BASE + 0x44)
+
+#endif
diff --git a/board/samsung/common/Makefile b/board/samsung/common/Makefile
old mode 100644
new mode 100755
index fa85f7dcd2..0a8570d46e
--- a/board/samsung/common/Makefile
+++ b/board/samsung/common/Makefile
@@ -8,6 +8,8 @@
 obj-$(CONFIG_USB_GADGET_DOWNLOAD) += gadget.o
 obj-$(CONFIG_MISC_COMMON) += misc.o
 
+obj-$(CONFIG_TARGET_ODROID_XU4) += odroid_misc.o
+
 ifndef CONFIG_SPL_BUILD
 obj-$(CONFIG_BOARD_COMMON)	+= board.o
 ifdef CONFIG_EXYNOS5_DT
diff --git a/board/samsung/common/board.c b/board/samsung/common/board.c
old mode 100644
new mode 100755
index 88299f17e3..573b302e5e
--- a/board/samsung/common/board.c
+++ b/board/samsung/common/board.c
@@ -29,6 +29,11 @@
 #include <samsung/misc.h>
 #include <dm/pinctrl.h>
 #include <dm.h>
+#include <mmc.h>
+
+#if defined(CONFIG_TARGET_ODROID_XU4) || defined(CONFIG_TARGET_ODROID_XU3)
+	#include <samsung/odroid_misc.h>
+#endif
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -307,6 +312,9 @@ int checkboard(void)
 #ifdef CONFIG_BOARD_LATE_INIT
 int board_late_init(void)
 {
+#if defined(CONFIG_TARGET_ODROID_XU4) || defined(CONFIG_TARGET_ODROID_XU3)
+	odroid_misc_init();
+#else
 	stdio_print_current_devices();
 
 	if (cros_ec_get_error()) {
@@ -319,6 +327,7 @@ int board_late_init(void)
 		panic("Cannot init cros-ec device");
 		return -1;
 	}
+#endif
 	return 0;
 }
 #endif
diff --git a/board/samsung/common/misc.c b/board/samsung/common/misc.c
old mode 100644
new mode 100755
index 4157349d02..4cc3e6ccbb
--- a/board/samsung/common/misc.c
+++ b/board/samsung/common/misc.c
@@ -33,6 +33,9 @@
 #endif
 #include <power/pmic.h>
 #include <mmc.h>
+#if defined(CONFIG_TARGET_ODROID_XU4) || defined(CONFIG_TARGET_ODROID_XU3)
+	#include <adc.h>
+#endif
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -99,10 +102,35 @@ void set_board_info(void)
 #ifdef CONFIG_BOARD_TYPES
 	bdtype = get_board_type();
 	if (!bdtype)
-		bdtype = "";
+		bdtype = "unknown";
 
 	sprintf(info, "%s%s", bdname, bdtype);
 	env_set("boardname", info);
+
+#if defined(CONFIG_TARGET_ODROID_XU4) || defined(CONFIG_TARGET_ODROID_XU3)
+	/* save board_name for select dtb */
+	if (!strncmp("xu3-lite" , bdtype, 8))
+		env_set("board_name", "xu3l");
+	else if (!strncmp("xu3", bdtype, 3))
+		env_set("board_name", "xu3");
+	else
+		env_set("board_name", "xu4");
+
+	/* save board_id_value (adc value) */
+	{
+		unsigned int adcval = 0;
+
+		adc_channel_single_shot("adc", CONFIG_ODROID_REV_AIN, &adcval);
+		env_set_ulong("board_adc_value", adcval);
+	}
+
+	/* save boot_device value (SD or eMMC) */
+	{
+		struct mmc *mmc = find_mmc_device(0);
+		env_set("boot_device", IS_SD(mmc) ? "SD" : "eMMC");
+	}
+#endif
+
 #endif
 	snprintf(info, ARRAY_SIZE(info),  "%s%x-%s%s.dtb",
 		 CONFIG_SYS_SOC, s5p_cpu_id, bdname, bdtype);
diff --git a/board/samsung/common/odroid_misc.c b/board/samsung/common/odroid_misc.c
new file mode 100755
index 0000000000..c88633acdb
--- /dev/null
+++ b/board/samsung/common/odroid_misc.c
@@ -0,0 +1,663 @@
+/*
+ * Odroid Board setup for EXYNOS5 based board
+ *
+ * Copyright (C) 2017 Hardkernel Co.,Ltd
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/board.h>
+#include <asm/arch/dwmmc.h>
+#include <asm/arch/mmc.h>
+#include <asm/arch/pinmux.h>
+#include <asm/arch/power.h>
+#include <asm/arch/system.h>
+#include <asm/arch/sromc.h>
+#include <asm/gpio.h>
+#include <asm/io.h>
+#include <samsung/misc.h>
+#include <samsung/odroid_misc.h>
+#include <errno.h>
+#include <version.h>
+#include <malloc.h>
+#include <memalign.h>
+#include <linux/sizes.h>
+#include <linux/input.h>
+#include <power/pmic.h>
+#include <power/regulator.h>
+#include <power/s2mps11.h>
+#include <dm.h>
+#include <adc.h>
+#include <mmc.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/* ODROID Debug Message */
+/*
+#define	ODROID_MISC_DEBUG
+*/
+
+/*
+	Default Partition Info for Android system
+*/
+static struct partition_info gPartInfo[PART_MAX] = {
+	[PART_FWBL1] = {
+		.name 	   = "fwbl1",
+		.blk_start = PART_BL1_ST_BLK,
+		.size 	   = PART_SIZE_BL1,
+		.raw_en    = 1,
+	},
+	[PART_BL2] = {
+		.name 	   = "bl2",
+		.blk_start = PART_BL2_ST_BLK,
+		.size 	   = PART_SIZE_BL2,
+		.raw_en    = 1,
+	},
+	[PART_BOOTLOADER] = {
+		.name 	   = "bootloader",
+		.blk_start = PART_UBOOT_ST_BLK,
+		.size 	   = PART_SIZE_UBOOT,
+		.raw_en    = 1,
+	},
+	[PART_TZSW] = {
+		.name 	   = "tzsw",
+		.blk_start = PART_TZSW_ST_BLK,
+		.size 	   = PART_SIZE_TZSW,
+		.raw_en    = 1,
+	},
+	[PART_ENV] = {
+		.name 	   = "env",
+		.blk_start = PART_ENV_ST_BLK,
+		.size 	   = PART_SIZE_ENV,
+		.raw_en    = 0,
+	},
+	[PART_KERNEL] = {
+		.name 	   = "kernel",
+		.blk_start = PART_KERNEL_ST_BLK,
+		.size 	   = PART_SIZE_KERNEL,
+		.raw_en    = 0,
+	},
+	[PART_FAT] = {
+		.name 	   = "fat",
+		.blk_start = 0,
+		.size 	   = 0,
+		.raw_en    = 0,
+	},
+	[PART_SYSTEM] = {
+		.name 	   = "system",
+		.blk_start = 0,
+		.size 	   = 0,
+		.raw_en    = 0,
+	},
+	[PART_USERDATA] = {
+		.name 	   = "userdata",
+		.blk_start = 0,
+		.size 	   = 0,
+		.raw_en    = 0,
+	},
+	[PART_CACHE] = {
+		.name 	   = "cache",
+		.blk_start = 0,
+		.size 	   = 0,
+		.raw_en    = 0,
+	},
+};
+
+/*---------------------------------------------------------------------------*/
+/* from cmd/mmc.c */
+extern int get_mmc_part_info(char *device_name, int part_num,
+	u64 *block_start, u64 *block_count, uchar *part_Id);
+
+/*---------------------------------------------------------------------------*/
+static void odroid_print_part_info(char *dev_no)
+{
+	uint i, blk_start, blk_count, kb_size;
+
+	printf("\n*** Partition Information for Andorid ***");
+	printf("\nControl Device ID : %s", dev_no);
+	printf("\npNo\tStart Block\tBlock Count\tpName");
+
+	for (i = 0; i < PART_MAX; i++) {
+		blk_start = gPartInfo[i].blk_start;
+		blk_count = gPartInfo[i].size / MOVI_BLK_SIZE;
+		kb_size   = gPartInfo[i].size / SZ_1K;
+		printf("\n %d \t%8d\t%8d\t%s (%d KB)",
+			i, blk_start, blk_count, gPartInfo[i].name, kb_size);
+	}
+	printf("\n\n");
+}
+
+/*---------------------------------------------------------------------------*/
+int odroid_get_partition_info(const char *ptn, struct partition_info *pinfo)
+{
+	int i;
+
+	for (i = 0; i < PART_MAX; i++) {
+		if (!strncmp(gPartInfo[i].name, ptn, strlen(ptn)))
+			break;
+	}
+	if (PART_MAX == i)
+		return	-1;
+
+	memcpy((void *)pinfo, (void *)&gPartInfo[i],
+		sizeof(struct partition_info));
+	return	0;
+}
+
+/*---------------------------------------------------------------------------*/
+/*
+	Partition information setup for Android fastboot.
+
+	Partition 1 = fat partition
+	Partition 2 - system partition
+	Partition 3 - userdata partition
+	Partition 4 - cache partition
+*/
+/*---------------------------------------------------------------------------*/
+int odroid_partition_setup(char *dev_no)
+{
+	u64 blk_st, blk_cnt;
+	unsigned char pid, i;
+
+	for (i = 0; i < 4; i++)	{
+		if (get_mmc_part_info (dev_no, i + 1, &blk_st, &blk_cnt, &pid))
+			goto err;
+		if (pid != 0x83 && pid != 0x0C)
+			goto err;
+		gPartInfo[PART_FAT+i].blk_start = blk_st;
+		gPartInfo[PART_FAT+i].size = (blk_cnt * MOVI_BLK_SIZE);
+	}
+
+	odroid_print_part_info(dev_no);
+	return	0;
+err:
+	printf( "\n****************************\n" \
+		"\n***      Warning!!!      ***\n" \
+		"\n****************************\n" \
+		"\This is not an Android Partition device!" \
+		"\nIf you want Android partitioning," \
+		"use fdisk command befor fastboot command.\n\n");
+	return	-1;
+}
+
+/*---------------------------------------------------------------------------*/
+void odroid_led_ctrl(int gpio, int status)
+{
+	gpio_set_value(gpio, status);
+}
+
+/*---------------------------------------------------------------------------*/
+static void odroid_pmic_deinit(void)
+{
+	struct udevice *dev;
+
+	if (pmic_get("s2mps11", &dev))	{
+		printf("%s : s2mps11 control error!\n", __func__);
+		return;
+	}
+	/* Master Reset Enable */
+	pmic_reg_write(dev, S2MPS11_REG_CTRL1, 0x0);
+}
+
+/*---------------------------------------------------------------------------*/
+static void odroid_pmic_init(void)
+{
+	struct udevice *dev;
+
+	if (pmic_get("s2mps11", &dev))	{
+		printf("%s : s2mps11 control error!\n", __func__);
+		return;
+	}
+
+	/* LDO9 : USB 3.0 3.3V */
+	pmic_reg_write(dev, S2MPS11_REG_L9CTRL, 0xF2);
+
+	/* LDO15, LDO17 : ETH 3.3V */
+	pmic_reg_write(dev, S2MPS11_REG_L15CTRL, 0xF2);
+	pmic_reg_write(dev, S2MPS11_REG_L17CTRL, 0xF2);
+
+	/* LDO13, LDO19 : MMC 3.3V */
+	pmic_reg_write(dev, S2MPS11_REG_L13CTRL, 0xF2);
+	pmic_reg_write(dev, S2MPS11_REG_L19CTRL, 0xF2);
+
+	/* BUCK10 : eMMC 2.85V */
+	pmic_reg_write(dev, S2MPS11_REG_B10CTRL2, 0xA8);
+
+	/* Master Reset Enable */
+	pmic_reg_write(dev, 0x0c, 0x10);
+
+#if defined(ODROID_MISC_DEBUG)
+	/* debug message */
+	printf("S2MPS11_REG_L9CTRL = 0x%02X\n",
+		pmic_reg_read(dev, S2MPS11_REG_L9CTRL));
+	printf("S2MPS11_REG_L15CTRL = 0x%02X\n",
+		pmic_reg_read(dev, S2MPS11_REG_L15CTRL));
+	printf("S2MPS11_REG_L17CTRL = 0x%02X\n",
+		pmic_reg_read(dev, S2MPS11_REG_L17CTRL));
+	printf("S2MPS11_REG_L13CTRL = 0x%02X\n",
+		pmic_reg_read(dev, S2MPS11_REG_L13CTRL));
+	printf("S2MPS11_REG_L19CTRL = 0x%02X\n",
+		pmic_reg_read(dev, S2MPS11_REG_L19CTRL));
+	printf("S2MPS11_REG_B10CTRL2 = 0x%02X\n",
+		pmic_reg_read(dev, S2MPS11_REG_B10CTRL2));
+#endif
+}
+
+/*---------------------------------------------------------------------------*/
+static void odroid_led_deinit(void)
+{
+	odroid_led_ctrl(GPIO_LED_R, 0);
+	odroid_led_ctrl(GPIO_LED_G, 0);
+	odroid_led_ctrl(GPIO_LED_B, 0);
+	gpio_free(GPIO_LED_R);
+	gpio_free(GPIO_LED_G);
+	gpio_free(GPIO_LED_B);
+}
+
+/*---------------------------------------------------------------------------*/
+static void odroid_led_init(void)
+{
+	if (gpio_request(GPIO_LED_R, "LED-R")) 
+		goto	err;
+	odroid_led_ctrl(GPIO_LED_R, 0);
+
+	if (gpio_request(GPIO_LED_G, "LED-G"))
+		goto	err;
+	odroid_led_ctrl(GPIO_LED_G, 0);
+
+	/* Default On */
+	if (gpio_request(GPIO_LED_B, "LED-B"))
+		goto	err;
+	odroid_led_ctrl(GPIO_LED_B, 1);
+
+	return;
+err:
+	printf("%s : GPIO Control error!\n", __func__);
+}
+
+/*---------------------------------------------------------------------------*/
+static void odroid_gpio_deinit(void)
+{
+	gpio_direction_output(GPIO_FAN_CTL, 0);
+	gpio_direction_output(GPIO_LCD_PWM, 0);
+
+	gpio_free(GPIO_POWER_BT);
+	gpio_free(GPIO_FAN_CTL);
+	gpio_free(GPIO_LCD_PWM);
+}
+
+/*---------------------------------------------------------------------------*/
+static void odroid_gpio_init(void)
+{
+	/* Power control button pin */
+	if (gpio_request(GPIO_POWER_BT, "Power BT"))
+		goto err;
+	gpio_set_pull(GPIO_POWER_BT, S5P_GPIO_PULL_NONE);
+	gpio_direction_input(GPIO_POWER_BT);
+
+	/* FAN Full Enable */
+	if (gpio_request(GPIO_FAN_CTL, "FAN Ctrl"))
+		goto err;
+	gpio_set_pull(GPIO_FAN_CTL, S5P_GPIO_PULL_NONE);
+	gpio_direction_output(GPIO_FAN_CTL, 1);
+
+	/* LCD PWM Port High */
+	if (gpio_request(GPIO_LCD_PWM, "LCD PWM"))
+		goto err;
+	gpio_set_pull(GPIO_LCD_PWM, S5P_GPIO_PULL_NONE);
+	gpio_direction_output(GPIO_LCD_PWM, 1);
+
+	return;
+err:
+	printf("%s : GPIO Control error!\n", __func__);
+}
+
+/*---------------------------------------------------------------------------*/
+static uint upload_file(const char *fname, const char *pname,
+	uint mem_addr, struct upload_info *upinfo, bool is_split)
+{
+	char	cmd[64], i;
+	unsigned long	filesize, fileload_part = 0;
+	unsigned long	total_fsize = 0;
+
+	/* file load from userdata area */
+	fileload_part = env_get_ulong("fileload_part", 10, 0);
+
+	/* mem load start addr */
+	upinfo->mem_addr = mem_addr;
+
+	/* max load file count = 64 */
+	for(i = 0; i < 64; i++) {
+		#if defined(ODROID_MISC_DEBUG)
+			printf("%s : %s, fname = %s%c, load_addr = 0x%08x\n",
+				__func__, pname, fname,
+				is_split ? ('a'+i) : ' ',
+				mem_addr);
+		#endif
+		/* env variable init */
+		env_set("filesize", "0");
+		filesize = 0;
+		memset(cmd, 0x00, sizeof(cmd));
+
+		if (fileload_part)
+			sprintf(cmd, "ext4load mmc 0:3 %x media/0/update/%s%c",
+				mem_addr, fname,
+				is_split ? ('a'+i) : ' ');
+		else
+			sprintf(cmd, "fatload mmc 0:1 %x update/%s%c",
+				mem_addr, fname,
+				is_split ? ('a'+i) : ' ');
+		run_command(cmd, 0);
+
+		/* file size check */
+		if ((filesize = env_get_ulong("filesize", 16, 0))) {
+			#if defined(ODROID_MISC_DEBUG)
+				printf("%s : filesize = %ld, total_filesize = %ld\n",
+					__func__, filesize, total_fsize);
+			#endif
+			total_fsize += filesize;
+		}
+
+		mem_addr += filesize;
+		/* load memory overflow */
+		if (total_fsize >= (SZ_1G + SZ_512M)) {
+			printf("ERROR! Memory overflow! fcount = %d, fsize = %ld\n",
+				i, total_fsize);
+			upinfo->file_size = 0;
+			return	upinfo->mem_addr;
+		}
+		if (!is_split || !filesize)
+			goto out;
+	}
+out:
+	if (total_fsize) {
+		strncpy(upinfo->part_name, pname, strlen(pname));
+		upinfo->file_size = total_fsize;
+		return  (mem_addr + 256) & 0xFFFFFF00;
+	}
+
+	printf("ERROR! update/%s%c File Not Found!! filesize = 0\n",
+		fname, is_split ? 'a'+i : ' ');
+	/* error */
+	return  mem_addr;
+}
+
+/*---------------------------------------------------------------------------*/
+static void update_raw_image(struct upload_info *upinfo)
+{
+	char cmd[64], is_emmc = 0, ptn;
+
+	memset(cmd, 0x00, sizeof(cmd));
+
+	if (!strncmp(env_get("boot_device"), "eMMC", sizeof("eMMC")))
+		is_emmc = 1;
+
+	if (!strncmp(upinfo->part_name, "kernel", sizeof("kernel"))) {
+		sprintf(cmd, "movi w k 0 0x%08x", upinfo->mem_addr);
+		run_command(cmd, 0);
+	} else {
+		if (!strncmp(upinfo->part_name, "bootloader", sizeof("bootloader")))
+			ptn = 'u';
+		if (!strncmp(upinfo->part_name, "bl1", sizeof("bl1")))
+			ptn = 'f';
+		if (!strncmp(upinfo->part_name, "bl2", sizeof("bl2")))
+			ptn = 'b';
+		if (!strncmp(upinfo->part_name, "tzsw", sizeof("tzsw")))
+			ptn = 't';
+
+		if (is_emmc)
+			sprintf(cmd, "movi w z %c 0 0x%08x", ptn, upinfo->mem_addr);
+		else
+			sprintf(cmd, "movi w %c 0 0x%08x", ptn, upinfo->mem_addr);
+
+		if (is_emmc)
+			run_command("emmc open 0", 0);
+
+		run_command(cmd, 0);
+
+		if (is_emmc)
+			run_command("emmc close 0", 0);
+	}
+}
+
+/*---------------------------------------------------------------------------*/
+static void update_ptn_image(struct upload_info *upinfo)
+{
+	char	cmd[64];
+
+	memset(cmd, 0x00, sizeof(cmd));
+	sprintf(cmd, "fastboot flash %s 0x%08x 0",
+		upinfo->part_name, upinfo->mem_addr);
+	run_command(cmd, 0);
+}
+
+/*---------------------------------------------------------------------------*/
+static void upload_data_write(struct upload_info *upinfo, int is_raw)
+{
+	if (is_raw) {
+		if (upinfo->file_size)
+			update_raw_image(upinfo);
+	} else {
+		if (upinfo->file_size)
+			update_ptn_image(upinfo);
+	}
+}
+
+/*---------------------------------------------------------------------------*/
+/* firmware update check */
+static void odroid_fw_update(unsigned int option)
+{
+	unsigned long		upload_addr = 0, i;
+	struct upload_info 	upinfo[PART_MAX];
+	struct exynos5_power *pmu =
+		(struct exynos5_power *)samsung_get_base_power();
+
+	odroid_led_ctrl(GPIO_LED_B, 1);
+
+	memset(upinfo, 0x00, sizeof(upinfo));
+
+	if (option & OPTION_FILELOAD_EXT4)
+		env_set_ulong("fileload_part", 3);
+	else
+		env_set_ulong("fileload_part", 0);
+
+	upload_addr = env_get_ulong("loadaddr", 16, 0);
+	if (!upload_addr)
+		upload_addr = CFG_FASTBOOT_TRANSFER_BUFFER;
+
+#if 0
+	upload_addr = upload_file("system.img",
+		"system", upload_addr, &upinfo[PART_SYSTEM], false);
+
+	if (!upinfo[PART_SYSTEM].file_size) {
+		/*
+		 If the system.img size is larger than 256MB,
+		 use 256MB divided images.
+		 max file load size is 1.5Gbytes.
+		 image name format : system_aa ... system_af(max 6 file)
+		*/
+		upload_addr = upload_file("system_a",
+			"system", upload_addr, &upinfo[PART_SYSTEM], true);
+	}
+#endif
+	upload_addr = upload_file("system_a",
+		"system", upload_addr, &upinfo[PART_SYSTEM], true);
+
+	upload_addr = upload_file("cache.img",
+		"cache", upload_addr, &upinfo[PART_CACHE], false);
+
+	if (option & OPTION_ERASE_USERDATA) {
+		if ((option & OPTION_RESIZE_PART) == 0) {
+			upload_addr = upload_file("userdata.img",
+				"userdata", upload_addr, &upinfo[PART_USERDATA], false);
+		}
+	}
+
+	upload_addr = upload_file("zImage",
+		"kernel", upload_addr, &upinfo[PART_KERNEL], false);
+
+	if (!upinfo[PART_KERNEL].file_size) {
+		upload_addr = upload_file("zImage-dtb",
+			"kernel", upload_addr, &upinfo[PART_KERNEL], false);
+	}
+
+	if (option & OPTION_UPDATE_UBOOT) {
+		upload_addr = upload_file("u-boot.bin",
+			"bootloader", upload_addr, &upinfo[PART_BOOTLOADER], false);
+		upload_addr = upload_file("bl1.bin",
+			"bl1", upload_addr, &upinfo[PART_FWBL1], false);
+		upload_addr = upload_file("bl2.bin",
+			"bl2", upload_addr, &upinfo[PART_BL2], false);
+		upload_addr = upload_file("tzsw.bin",
+			"tzsw", upload_addr, &upinfo[PART_TZSW], false);
+	}
+
+	/*
+		sysip_data1(msb 16 bits) : system mb size
+		sysip_data1(lsb 16 bits) : cache mb size
+		sysip_data2		 : userdata mb size
+		sysip_data3		 : fat mb size
+
+		default : System 1G/Cache 256M/FAT 100M/expand Userdata
+			fdisk -c 0 1024 0 256 100
+	*/
+	if (option & OPTION_RESIZE_PART) {
+		char cmd[64];
+		memset(cmd, 0x00, sizeof(cmd));
+		sprintf(cmd, "fdisk -c 0 %d %d %d %d",
+			(pmu->sysip_dat1 & 0xFFFF0000) >> 16,
+			(pmu->sysip_dat2),
+			(pmu->sysip_dat1 & 0x0000FFFF),
+			(pmu->sysip_dat3));
+		pmu->sysip_dat1 = 0;	pmu->sysip_dat2 = 0;
+		pmu->sysip_dat3 = 0;
+		run_command(cmd, 0);
+		if (option & OPTION_FILELOAD_EXT4)
+			run_command("fatformat mmc 0:3", 0);
+	}
+	else if (option & OPTION_OLDTYPE_PART)
+		run_command("fdisk -c 0", 0);
+
+	if (option & OPTION_ERASE_USERDATA)
+		if (option & OPTION_FILELOAD_EXT4)
+			run_command("fatformat mmc 0:3", 0);
+
+	for (i = 0; i < PART_MAX; i++)
+		upload_data_write(&upinfo[i], i > PART_KERNEL ? 0 : 1);
+
+	if (option & OPTION_ERASE_ENV)
+		run_command(UBOOT_ENV_ERASE, 0);
+
+	if (option & OPTION_ERASE_FAT)
+		run_command("fatformat mmc 0:1", 0);
+
+	odroid_led_ctrl(GPIO_LED_B, 0);
+}
+
+/*---------------------------------------------------------------------------*/
+static void odroid_magic_cmd_check(void)
+{
+	struct exynos5_power *pmu =
+		(struct exynos5_power *)samsung_get_base_power();
+
+	unsigned int	cmd, option;
+
+	cmd	= (pmu->sysip_dat0 & 0xFFFF);
+	option	= (pmu->inform0	   & 0xFFFF);
+
+#if defined(ODROID_MISC_DEBUG)
+	printf("pmu->sysip = 0x%08x, pmu->inform0 = 0x%08x\n",
+		cmd, option);
+	printf("pmu->sysip1 = 0x%08x\n", pmu->sysip_dat1);
+	printf("pmu->sysip2 = 0x%08x\n", pmu->sysip_dat2);
+	printf("pmu->sysip3 = 0x%08x\n", pmu->sysip_dat3);
+
+	printf("resize part size : \n");
+	printf("system %d Mb, cache %d Mb, fat %d Mb, userdata %d Mb\n",
+		(pmu->sysip_dat1 >> 16)	& 0xFFFF,
+		(pmu->sysip_dat1)	& 0xFFFF,
+		(pmu->sysip_dat2),
+		(pmu->sysip_dat3));
+#endif
+	pmu->sysip_dat0 = 0;	pmu->inform0 = 0;
+
+	switch(cmd) {
+	case	FASTBOOT_MAGIC_REBOOT_CMD:
+		run_command("fastboot", 0);
+		break;
+	case	FASTBOOT_MAGIC_UPDATE_CMD:
+		if (!odroid_partition_setup("0"))
+			odroid_fw_update(option);
+		run_command("reset", 0);
+		break;
+	}
+}
+
+/*---------------------------------------------------------------------------*/
+void odroid_self_update(uint option)
+{
+	struct exynos5_power *pmu =
+		(struct exynos5_power *)samsung_get_base_power();
+
+	pmu->sysip_dat1 = 0;	pmu->sysip_dat2 = 0;	pmu->sysip_dat3 = 0;
+
+	if (!odroid_partition_setup("0"))
+		odroid_fw_update(option);
+}
+
+/*---------------------------------------------------------------------------*/
+/*
+	ODROID XU3/XU3-Lite/XU4 Hardware Init.
+	call from board/samsung/common/board.c
+*/
+/*---------------------------------------------------------------------------*/
+void odroid_misc_init(void)
+{
+	/* Default LDO value setup */
+	odroid_pmic_init();
+	odroid_gpio_init();
+	odroid_led_init();
+
+	/* check Android Image update or fastboot Magic command */
+	odroid_magic_cmd_check();
+}
+
+/*---------------------------------------------------------------------------*/
+void odroid_misc_deinit(void)
+{
+	odroid_led_deinit();
+	odroid_gpio_deinit();
+	odroid_pmic_deinit();
+}
+
+/*---------------------------------------------------------------------------*/
+void odroid_power_off(void)
+{
+	struct exynos5_power *power =
+		(struct exynos5_power *)samsung_get_base_power();
+
+	printf("%s\n", __func__);
+	odroid_misc_deinit();
+
+	power->ps_hold_control = 0x5200;
+}
+
+/*---------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------*/
diff --git a/board/samsung/smdk5420/Kconfig b/board/samsung/smdk5420/Kconfig
index a9d62fffa5..3331b1d56c 100644
--- a/board/samsung/smdk5420/Kconfig
+++ b/board/samsung/smdk5420/Kconfig
@@ -11,6 +11,19 @@ config SYS_CONFIG_NAME
 
 endif
 
+if TARGET_ODROID_XU4
+
+config SYS_BOARD
+	default "smdk5420"
+
+config SYS_VENDOR
+	default "samsung"
+
+config SYS_CONFIG_NAME
+	default "odroid_xu4"
+
+endif
+
 if TARGET_PEACH_PI
 
 config SYS_BOARD
diff --git a/cmd/Kconfig b/cmd/Kconfig
index d6d130edfa..ee5f0fcb06 100644
--- a/cmd/Kconfig
+++ b/cmd/Kconfig
@@ -531,6 +531,11 @@ config CMD_LZMADEC
 	  Support decompressing an LZMA (Lempel-Ziv-Markov chain algorithm)
 	  image from memory.
 
+config CMD_DMC
+	bool "dmc - ddr_freq"
+	help
+	   Set DDR clock
+
 config CMD_UNZIP
 	bool "unzip"
 	help
diff --git a/cmd/Makefile b/cmd/Makefile
old mode 100644
new mode 100755
index 2a5b8ce825..5cd88ae989
--- a/cmd/Makefile
+++ b/cmd/Makefile
@@ -79,6 +79,7 @@ obj-$(CONFIG_LOGBUFFER) += log.o
 obj-$(CONFIG_ID_EEPROM) += mac.o
 obj-$(CONFIG_CMD_MD5SUM) += md5sum.o
 obj-$(CONFIG_CMD_MEMORY) += mem.o
+obj-$(CONFIG_CMD_DMC) += dmc.o
 obj-$(CONFIG_CMD_IO) += io.o
 obj-$(CONFIG_CMD_MFSL) += mfsl.o
 obj-$(CONFIG_CMD_MII) += mii.o
@@ -128,7 +129,12 @@ obj-$(CONFIG_CMD_UNZIP) += unzip.o
 obj-$(CONFIG_CMD_LZMADEC) += lzmadec.o
 
 obj-$(CONFIG_CMD_USB) += usb.o disk.o
+ifdef CONFIG_TARGET_ODROID_XU4
+obj-$(CONFIG_CMD_FASTBOOT) += odroid_fastboot.o
+else
 obj-$(CONFIG_CMD_FASTBOOT) += fastboot.o
+endif
+
 obj-$(CONFIG_CMD_FS_UUID) += fs_uuid.o
 
 obj-$(CONFIG_CMD_USB_MASS_STORAGE) += usb_mass_storage.o
@@ -151,6 +157,9 @@ obj-$(CONFIG_CMD_REGULATOR) += regulator.o
 obj-$(CONFIG_CMD_BLOB) += blob.o
 endif # !CONFIG_SPL_BUILD
 
+# bootini command
+obj-$(CONFIG_TARGET_ODROID_XU4) += bootini.o
+
 # core command
 obj-y += nvedit.o
 
diff --git a/cmd/bootini.c b/cmd/bootini.c
new file mode 100755
index 0000000000..2a08078c1d
--- /dev/null
+++ b/cmd/bootini.c
@@ -0,0 +1,150 @@
+/*
+ * Copyright (C) 2015 Hardkernel Co,. Ltd
+ * Dongjin Kim <tobetter@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <command.h>
+#include <errno.h>
+#include <malloc.h>
+#include <linux/ctype.h>    /* isalpha, isdigit */
+#include <linux/sizes.h>
+
+#ifdef CONFIG_SYS_HUSH_PARSER
+#include <cli_hush.h>
+#endif
+
+#if defined(CONFIG_TARGET_ODROID_XU4)
+#define BOOTINI_MAGIC	"ODROID-UBOOT-CONFIG"
+#else
+#error 'BOOTINI_MAGIC' is missing!!!
+#endif
+
+#define SZ_BOOTINI		SZ_64K
+
+/* Nothing to proceed with zero size string or comment.
+ *
+ * FIXME: Do we really need to strip the line start with '#' or ';',
+ *        since any U-boot command does not start with punctuation character.
+ */
+static int valid_command(const char* p)
+{
+	char *q;
+
+	for (q = (char*)p; *q; q++) {
+		if (isblank(*q)) continue;
+		if (isalnum(*q)) return 1;
+		if (ispunct(*q))
+			return (*q != '#') && (*q != ';');
+	}
+
+	return !(p == q);
+}
+
+/* Read boot.ini from FAT partition
+ */
+static char* read_bootini(void)
+{
+	char msg[128] = { 0, };
+	unsigned long filesize;
+	char *p;
+
+	p = (char *)simple_strtoul(env_get("loadaddr"), NULL, 16);
+	if (NULL == p) {
+		p = (char *)CONFIG_SYS_LOAD_ADDR;
+		sprintf(msg, "%x", CONFIG_SYS_LOAD_ADDR);
+		env_set("loadaddr", msg);
+	}
+
+	env_set("filesize", "0");
+	sprintf(msg, "bootini addr = 0x%08X, Loading boot.ini from ",
+		simple_strtoul(env_get("loadaddr"), NULL, 16));
+
+	env_set("msgload", msg);
+	run_command("if fatload mmc 0:1 ${loadaddr} boot.ini;" \
+		"   then echo ${msgload} FAT;" \
+		"   else if ext4load mmc 0:1 ${loadaddr} /boot.ini;" \
+		"   then echo ${msgload} ext4 0:1 /boot.ini;" \
+		"   else if ext4load mmc 0:1 ${loadaddr} /boot/boot.ini;" \
+		"   then echo ${msgload} ext4 0:1 /boot/boot.ini;" \
+		"   else if ext4load mmc 0:2 ${loadaddr} /boot/boot.ini;" \
+		"   then echo ${msgload} ext4 0:2 /boot.ini;" \
+		"   else if ext4load mmc 0:2 ${loadaddr} /boot.ini;" \
+		"   then echo ${msgload} ext4 0:2 /boot/boot.ini;" \
+		"   fi;fi;fi;fi;fi;", 0);
+
+	filesize = env_get_ulong("filesize", 16, 0);
+	if (0 == filesize) {
+		printf("bootini: no boot.ini or empty file\n");
+		return NULL;
+	}
+
+	if (filesize > SZ_BOOTINI) {
+		printf("boot.ini: 'boot.ini' exceeds %d, size=%ld\n",
+				SZ_BOOTINI, filesize);
+		return NULL;
+	}
+
+	/* Terminate the read buffer with '\0' to be treated as string */
+	*(char *)(p + filesize) = '\0';
+
+	/* Scan MAGIC string, readed boot.ini must start with exact magic string.
+	 * Otherwise, we will not proceed at all.
+	 */
+	while (*p) {
+		char *s = strsep(&p, "\n");
+		if (!valid_command(s))
+			continue;
+
+		/* MAGIC string is discovered, return the buffer address of next to
+		 * proceed the commands.
+		 */
+		if (!strncmp(s, BOOTINI_MAGIC, sizeof(BOOTINI_MAGIC)))
+			return memcpy(malloc(filesize), p, filesize);
+	}
+
+	printf("bootini: MAGIC NAME, %s, is not found!!\n", BOOTINI_MAGIC);
+
+	return NULL;
+}
+
+static int do_bootini(cmd_tbl_t *cmdtp, int flag, int argc,
+		char *const argv[])
+{
+	char *p;
+	char *cmd;
+
+	p = read_bootini();
+	if (NULL == p)
+		return 0;
+
+	printf("bootini: applying boot.ini...\n");
+
+	while (p) {
+		cmd = strsep(&p, "\n");
+		if (!valid_command(cmd))
+			continue;
+
+		printf("bootini: %s\n", cmd);
+
+#ifndef CONFIG_SYS_HUSH_PARSER
+		run_command(cmd, 0);
+#else
+		parse_string_outer(cmd, FLAG_PARSE_SEMICOLON
+				| FLAG_EXIT_FROM_LOOP);
+#endif
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(
+		bootini,		1,		0,		do_bootini,
+		"read 'boot.ini' from FAT partiton",
+		"\n"
+		"    - read boot.ini from the first partiton treated as FAT partiton"
+);
+
+/* vim: set ts=4 sw=4 tw=80: */
diff --git a/cmd/dmc.c b/cmd/dmc.c
new file mode 100644
index 0000000000..f8e9d110ec
--- /dev/null
+++ b/cmd/dmc.c
@@ -0,0 +1,115 @@
+/*
+ * Set LPDDR3 frequency and DMC for Exynos5422
+ *
+ * Copyright (C) 2017 Joy Cho <joy.cho@hardkernel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+
+#define DREXI_0		0x10C20000
+#define DREXI_1		0x10C30000
+
+static int set_cmu(int freq)
+{
+	struct exynos5420_clock *clk =
+		(struct exynos5420_clock *)EXYNOS5_CLOCK_BASE;
+
+	/* set BPLL_LOCK, BPLL_CON1 and BPLL_CON0 */
+	switch (freq) {
+	case 933:
+		writel(0x00000320, &clk->bpll_lock);
+		writel(0x0020F300, &clk->bpll_con1);
+		writel(0x81370401, &clk->bpll_con0);
+		break;
+	case 825:
+		writel(0x00000320, &clk->bpll_lock);
+		writel(0x0020F300, &clk->bpll_con1);
+		writel(0x81130401, &clk->bpll_con0);
+		break;
+	case 728:
+		writel(0x00000258, &clk->bpll_lock);
+		writel(0x0020F300, &clk->bpll_con1);
+		writel(0x80B60301, &clk->bpll_con0);
+		break;
+	case 633:
+		writel(0x00000320, &clk->bpll_lock);
+		writel(0x0020F300, &clk->bpll_con1);
+		writel(0x80D30401, &clk->bpll_con0);
+		break;
+	default:
+		printf("no available frequency - %dMHz\n", freq);
+		return 0;
+	}
+
+	/* check the 29th bit (LOCKED) to confirm PLL locking */
+	while(!(readl(&clk->bpll_con0) & (0x1 << 29)));
+
+	return 1;
+}
+
+static void set_dmc(int freq, u32 drex_addr)
+{
+	/* set TIMINGROW0, TIMINGDATA0 and TIMINGPOWER0 */
+	switch (freq) {
+	case 933:
+		writel(0x3D6BA816, drex_addr+0x0034);
+		writel(0x4742086E, drex_addr+0x0038);
+		writel(0x60670447, drex_addr+0x003C);
+		break;
+	case 825:
+		writel(0x365A9713, drex_addr+0x0034);
+		writel(0x4740085E, drex_addr+0x0038);
+		writel(0x543A0446, drex_addr+0x003C);
+		break;
+	case 728:
+		writel(0x30598651, drex_addr+0x0034);
+		writel(0x3730085E, drex_addr+0x0038);
+		writel(0x4C330336, drex_addr+0x003C);
+		break;
+	case 633:
+		writel(0x2A48758F, drex_addr+0x0034);
+		writel(0x3730085E, drex_addr+0x0038);
+		writel(0x402D0335, drex_addr+0x003C);
+		break;
+	default:
+		printf("no available frequency - %dMHz\n", freq);
+		break;
+	}
+}
+
+static int do_dmc(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int freq;
+
+	if (argc != 2)
+		return cmd_usage(cmdtp);
+	else
+		freq = simple_strtoul(argv[1], NULL, 10);
+
+	if (!set_cmu(freq))
+		return cmd_usage(cmdtp);
+
+	set_dmc(freq, DREXI_0);
+	set_dmc(freq, DREXI_1);
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	dmc,	2,	0,	do_dmc,
+	"Set LPDDR3 clock",
+	"dmc <lpddr3 frequency>\n"
+	"ex) dmc 933\n"
+	"lpddr3 frequency list - 933/825/728/633\n");
diff --git a/cmd/fat.c b/cmd/fat.c
old mode 100644
new mode 100755
index ad1dc2a49f..a8c62269c8
--- a/cmd/fat.c
+++ b/cmd/fat.c
@@ -19,6 +19,40 @@
 #include <fat.h>
 #include <fs.h>
 
+int do_fat_format(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int dev, part;
+	struct blk_desc *dev_desc;
+	disk_partition_t info;
+
+	if (argc < 2) {
+		printf("usage: fatformat <interface> [<dev[:part]>]\n");
+		return 0;
+	}
+
+	part = blk_get_device_part_str(argv[1], argv[2], &dev_desc, &info, 1);
+	if (part < 0)
+		return 1;
+
+	dev = dev_desc->devnum;
+
+	printf("Start format MMC %d partition %d ...\n", dev, part);
+
+	if (do_format(dev_desc, part) != 0) {
+		printf("\n** Unable to use %s %d:%d for fatformat **\n",
+			argv[1], dev, part);
+		return 1;
+	}
+	return 0;
+}
+
+U_BOOT_CMD(
+	fatformat, 3, 0, do_fat_format,
+	"fatformat - disk format by FAT32\n",
+	"<interface(only support mmc)> <dev:partition num>\n"
+	"	- format by FAT32 on 'interface'\n"
+);
+
 int do_fat_size(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
 	return do_size(cmdtp, flag, argc, argv, FS_TYPE_FAT);
diff --git a/cmd/mmc.c b/cmd/mmc.c
old mode 100644
new mode 100755
index 00697fc1f2..b097315a81
--- a/cmd/mmc.c
+++ b/cmd/mmc.c
@@ -883,3 +883,749 @@ U_BOOT_CMD(
 	"display MMC info",
 	"- display info of the current MMC device"
 );
+
+#ifdef CONFIG_SUPPORT_EMMC_BOOT
+static int do_emmc(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int rc = 0;
+
+	if (argc != 3)
+		return	CMD_RET_USAGE;
+
+	if (strcmp(argv[1], "open") == 0) {
+		int dev = simple_strtoul(argv[2], NULL, 10);
+		struct mmc *mmc = find_mmc_device(dev);
+
+		if (!mmc)
+			goto out;
+
+		if (IS_SD(mmc)) {
+			printf("MMC%d device is SD.!!\n", dev);
+			return	CMD_RET_FAILURE;
+		}
+
+		rc = emmc_boot_open(mmc);
+
+		if (rc == 0) {
+			printf("eMMC OPEN Success.!!\n");
+			printf("\t\t\t!!!Notice!!!\n");
+			printf("!You must close eMMC boot Partition after all image writing!\n");
+			printf("!eMMC boot partition has continuity at image writing time.!\n");
+			printf("!So, Do not close boot partition, Before, all images is written.!\n");
+		} else {
+			printf("eMMC OPEN Failed.!!\n");
+			return	CMD_RET_FAILURE;
+		}
+	} else if (strcmp(argv[1], "close") == 0) {
+		int dev = simple_strtoul(argv[2], NULL, 10);
+		struct mmc *mmc = find_mmc_device(dev);
+
+		if (!mmc)
+			goto out;
+
+		if (IS_SD(mmc)) {
+			printf("MMC%d device is SD.!!\n", dev);
+			return	CMD_RET_FAILURE;
+		}
+
+		rc = emmc_boot_close(mmc);
+
+		if (rc == 0) {
+			printf("eMMC CLOSE Success.!!\n");
+		} else {
+			printf("eMMC CLOSE Failed.!!\n");
+			return	CMD_RET_FAILURE;
+		}
+	} else {
+		goto out;
+	}
+	return	CMD_RET_SUCCESS;
+out:
+	puts("No MMC device available\n");
+	return	CMD_RET_FAILURE;
+}
+
+U_BOOT_CMD(
+	emmc, 3, 0, do_emmc,
+	"Open/Close eMMC boot partition",
+	"open <device_num> \n"
+	"emmc close <device_num> \n"
+);
+
+#endif
+
+#ifdef CONFIG_FASTBOOT
+
+#include <memalign.h>
+
+#define	CHS_MODE	0
+#define	LBA_MODE	!(CHS_MODE)
+
+typedef struct
+{
+	uint	C_start, C_end;
+	uint	H_start, H_end;
+	uint	S_start, S_end;
+
+	uint	available_block;
+	uint	unit;
+	uint	total_block_count;
+
+	/* LBA or CHS mode */
+	uint	addr_mode;
+} SDInfo;
+
+typedef struct
+{
+	uchar	bootable;
+	uchar	partitionId;
+
+	uint	C_start, C_end;
+	uint	H_start, H_end;
+	uint	S_start, S_end;
+
+	u64	block_start;
+	u64	block_count;
+	u64	block_end;
+} PartitionInfo;
+
+#define	LBA_MODE_SIZE	(1023*254*63)
+
+static u64 calc_unit(u64 length, SDInfo sdInfo)
+{
+	if (sdInfo.addr_mode == CHS_MODE)
+		return ( (length / MOVI_BLK_SIZE / sdInfo.unit + 1 ) * sdInfo.unit);
+	else
+		return ( (length / MOVI_BLK_SIZE) );
+}
+
+static void encode_chs(uint C, uint H, uint S, uchar *result)
+{
+	*result++ = (uchar)   H;
+	*result++ = (uchar) ( S + ((C & 0x00000300) >> 2) );
+	*result   = (uchar) ( C & 0x000000FF );
+}
+
+static void encode_partitionInfo(PartitionInfo partInfo, uchar *result)
+{
+	uint blk_start = partInfo.block_start;
+	uint blk_count = partInfo.block_count;
+
+	*result++ = partInfo.bootable;
+
+	encode_chs(partInfo.C_start, partInfo.H_start, partInfo.S_start, result);
+	result +=3;
+	*result++ = partInfo.partitionId;
+
+	encode_chs(partInfo.C_end, partInfo.H_end, partInfo.S_end, result);
+	result += 3;
+
+	memcpy(result, (uchar *)&(blk_start), 4);
+	result += 4;
+
+	memcpy(result, (uchar *)&(blk_count), 4);
+}
+
+static void decode_partitionInfo(uchar *in, PartitionInfo *partInfo)
+{
+	uint blk_start, blk_count;
+
+	partInfo->bootable	= *in;
+	partInfo->partitionId	= *(in + 4);
+
+	memcpy((uchar *)&(blk_start), (in + 8), 4);
+	memcpy((uchar *)&(blk_count), (in +12), 4);
+
+	partInfo->block_start = blk_start;
+	partInfo->block_count = blk_count;
+}
+
+static void get_SDInfo(int block_count, SDInfo *sdInfo)
+{
+	uint C, H, S;
+
+	uint C_max = 1023, H_max = 254, S_max = 63;
+	uint H_start = 1, S_start = 1;
+	uint diff_min = 0, diff = 0;
+
+	if(block_count >= LBA_MODE_SIZE)
+		sdInfo->addr_mode = LBA_MODE;
+	else
+		sdInfo->addr_mode = CHS_MODE;
+
+	if (sdInfo->addr_mode == CHS_MODE) {
+		diff_min = C_max;
+
+		for (H = H_start; H <= H_max; H++) {
+			for (S  = S_start; S <= S_max; S++) {
+				C = block_count / (H * S);
+
+				if ( (C <= C_max) ) {
+					diff = C_max - C;
+					if (diff <= diff_min) {
+						diff_min = diff;
+						sdInfo->C_end = C;
+						sdInfo->H_end = H;
+						sdInfo->S_end = S;
+					}
+				}
+			}
+		}
+	} else {
+		sdInfo->C_end = 1023;
+		sdInfo->H_end = 254;
+		sdInfo->S_end = 63;
+	}
+
+	sdInfo->C_start	= 0;
+	sdInfo->H_start	= 1;
+	sdInfo->S_start	= 1;
+
+	sdInfo->total_block_count	= block_count;
+	sdInfo->available_block		= sdInfo->C_end * sdInfo->H_end * sdInfo->S_end;
+	sdInfo->unit			= sdInfo->H_end * sdInfo->S_end;
+}
+
+static void make_partitionInfo(u64 LBA_start,
+	u64 count, SDInfo sdInfo, PartitionInfo *partInfo)
+{
+	u64	temp = 0;
+	u64	part_start_blk;
+
+	partInfo->block_start = LBA_start;
+
+	if (sdInfo.addr_mode == CHS_MODE) {
+		partInfo->C_start	= partInfo->block_start / (sdInfo.H_end * sdInfo.S_end);
+		temp			= partInfo->block_start % (sdInfo.H_end * sdInfo.S_end);
+		partInfo->H_start	= temp / sdInfo.S_end;
+		partInfo->S_start	= temp % sdInfo.S_end + 1;
+
+		if (count == MOVI_BLK_END) {
+			part_start_blk 		= calc_unit(ANDROID_PART_START, sdInfo);
+			partInfo->block_end	= sdInfo.C_end * sdInfo.H_end * sdInfo.S_end - part_start_blk - 1;
+			partInfo->block_count	= partInfo->block_end - partInfo->block_start + 1;
+
+			partInfo->C_end = partInfo->block_end / sdInfo.unit;
+			partInfo->H_end = sdInfo.H_end - 1;
+			partInfo->S_end = sdInfo.S_end;
+		} else {
+			partInfo->block_count	= count;
+
+			partInfo->block_end	= partInfo->block_start + count - 1;
+			partInfo->C_end		= partInfo->block_end / sdInfo.unit;
+
+			temp			= partInfo->block_end % sdInfo.unit;
+			partInfo->H_end		= temp / sdInfo.S_end;
+			partInfo->S_end		= temp % sdInfo.S_end + 1;
+		}
+	} else {
+		partInfo->C_start	= 0;
+		partInfo->H_start	= 1;
+		partInfo->S_start	= 1;
+
+		partInfo->C_end		= 1023;
+		partInfo->H_end		= 254;
+		partInfo->S_end		= 63;
+
+		if (count == MOVI_BLK_END) {
+			part_start_blk 		= calc_unit(ANDROID_PART_START, sdInfo);
+			partInfo->block_end	= sdInfo.total_block_count - part_start_blk - 1;
+			partInfo->block_count	= partInfo->block_end - partInfo->block_start + 1;
+		} else {
+			partInfo->block_count	= count;
+			partInfo->block_end	= partInfo->block_start + count - 1;
+		}
+	}
+}
+
+/* partition setup info struct */
+struct psetup_info {
+	int	expand_part;
+	u64	part_size[4];
+};
+
+static int check_partition_param(int total_block_count,
+	int argc, char * const argv[],  int *expand_part, u64 *psize)
+{
+	int	expand_part_cnt = 0, i;
+	u64	setup_block_cnt;
+
+	/* default expand partition is fat */
+	*expand_part = 3;
+
+	switch(argc) {
+	/* fdisk -c {dev} */
+	case	3:
+		/* default value setup */
+		psize[0] = PART_SIZE_SYSTEM;
+		psize[1] = PART_SIZE_USERDATA;
+		psize[2] = PART_SIZE_CACHE;
+		psize[3] = 0;
+		break;
+	/* fdisk -c {dev} {system} {userdata} {cache} */
+	case	6:
+		for (i = 0; i < 3; i++) {
+			psize[i] = simple_strtoul(argv[3 + i], NULL, 0);
+			psize[i] = psize[i] * SZ_1M;
+		}
+		psize[i] = 0;
+		break;
+	/* fdisk -c {dev} {system} {userdata} {cache} {fat} */
+	case	7:
+		for (i = 0; i < 4; i++) {
+			if ( strncmp(argv[3 + i],  "0", sizeof("0")) &&
+			     strncmp(argv[3 + i], "-1", sizeof("-1")) ) {
+				psize[i] = simple_strtoul(argv[3 + i], NULL, 0);
+				psize[i] = psize[i] * SZ_1M;
+			} else {
+				expand_part_cnt++;
+				*expand_part = i;
+				psize[i] = 0;
+			}
+		}
+		break;
+	default :
+		printf("Error : ");
+		printf("Wrong param count.(param count = %d\n",
+			argc);
+		return	-1;
+	}
+
+	if (expand_part_cnt > 1) {
+		printf("\nError : ");
+		printf("Only one partition can be expanded.(expand part = %d)\n",
+			expand_part_cnt);
+		printf("\nDefault partition setup : \n");
+		printf("System 1GB / Cache 256MB / FAT 100MB / Expand Userdata\n");
+		psize[0] = PART_SIZE_SYSTEM;
+		psize[1] = 0;
+		psize[2] = PART_SIZE_CACHE;
+		psize[3] = 100 * SZ_1M;
+		*expand_part = 1;
+	}
+
+	setup_block_cnt = psize[0] + psize[1] + psize[2] + psize[3];
+	setup_block_cnt = (setup_block_cnt / MMC_MAX_BLOCK_LEN);
+
+	if (total_block_count < setup_block_cnt) {
+		printf("Error : ");
+		printf("Block size overflow.(total_block = %d, cal block = %lld)\n",
+			total_block_count, setup_block_cnt);
+		return	-1;
+	}
+	return	0;
+}
+
+static int make_mmc_partition(int total_block_count, uchar *mbr,
+	int argc, char * const argv[])
+{
+	u64		block_start = 0, block_offset, psize[4];
+	int		expand_part;
+	SDInfo		sdInfo;
+	PartitionInfo	partInfo[4];
+
+	if(check_partition_param(total_block_count, argc, argv,
+		&expand_part, psize))
+		return	-1;
+
+	memset((uchar *)&sdInfo, 0x00, sizeof(SDInfo));
+
+	get_SDInfo(total_block_count, &sdInfo);
+
+	block_start = calc_unit(ANDROID_PART_START, sdInfo);
+
+	/* system partition */
+	if (expand_part != 0) {
+		block_offset = calc_unit(psize[0], sdInfo);
+		partInfo[0].bootable	= 0x00;
+		partInfo[0].partitionId	= 0x83;
+		make_partitionInfo(block_start, block_offset, sdInfo, &partInfo[0]);
+		block_start += block_offset;
+	}
+
+	/* userdata partition */
+	if (expand_part != 1) {
+		block_offset = calc_unit(psize[1], sdInfo);
+		partInfo[1].bootable	= 0x00;
+		partInfo[1].partitionId	= 0x83;
+		make_partitionInfo(block_start, block_offset, sdInfo, &partInfo[1]);
+		block_start += block_offset;
+	}
+
+	/* cache partition */
+	if (expand_part != 2) {
+		block_offset = calc_unit(psize[2], sdInfo);
+		partInfo[2].bootable	= 0x00;
+		partInfo[2].partitionId	= 0x83;
+		make_partitionInfo(block_start, block_offset, sdInfo, &partInfo[2]);
+		block_start += block_offset;
+	}
+
+	/* fat partition */
+	if (expand_part != 3) {
+		block_offset = calc_unit(psize[3], sdInfo);
+		partInfo[3].bootable	= 0x00;
+		partInfo[3].partitionId	= 0x0C;
+		make_partitionInfo(block_start, block_offset, sdInfo, &partInfo[3]);
+		block_start += block_offset;
+	}
+
+	/* expand partition setup */
+	block_offset = MOVI_BLK_END;
+
+	partInfo[expand_part].bootable	= 0x00;
+	partInfo[expand_part].partitionId = expand_part != 3 ? 0x83 : 0x0C;
+
+	make_partitionInfo(block_start, block_offset, sdInfo,
+		&partInfo[expand_part]);
+
+	memset(mbr, 0x00, sizeof(mbr));
+	mbr[510] = 0x55; mbr[511] = 0xAA;
+
+	encode_partitionInfo(partInfo[0], &mbr[0x1CE]);
+	encode_partitionInfo(partInfo[1], &mbr[0x1DE]);
+	encode_partitionInfo(partInfo[2], &mbr[0x1EE]);
+	encode_partitionInfo(partInfo[3], &mbr[0x1BE]);
+
+	return 0;
+}
+
+static uint get_mmc_block_count(char *device_name)
+{
+	struct mmc *mmc;
+	int block_count = 0;
+	int dev_num;
+
+	dev_num = simple_strtoul(device_name, NULL, 0);
+
+	mmc = find_mmc_device(dev_num);
+
+	if (!mmc || !mmc->capacity) {
+		puts("No MMC device available\n");
+		return -1;
+	}
+
+	block_count = mmc->capacity / mmc->read_bl_len;
+
+	return block_count;
+}
+
+static int get_mmc_mbr(char *device_name, uchar *mbr)
+{
+	int rv;
+	struct mmc *mmc;
+	int dev_num;
+
+	dev_num = simple_strtoul(device_name, NULL, 0);
+
+	mmc = find_mmc_device(dev_num);
+	if (!mmc || !mmc->capacity) {
+		puts("No MMC device available\n");
+		return -1;
+	}
+
+	rv = mmc->block_dev.block_read(&mmc->block_dev, 0, 1, mbr);
+
+	if(rv == 1)
+		return 0;
+	else
+		return -1;
+}
+
+static int put_mmc_mbr(uchar *mbr, char *device_name)
+{
+	int rv;
+	struct mmc *mmc;
+	int dev_num;
+
+	dev_num = simple_strtoul(device_name, NULL, 0);
+
+	mmc = find_mmc_device(dev_num);
+	if (!mmc || !mmc->capacity) {
+		puts("No MMC device available\n");
+		return	-1;
+	}
+
+	rv = mmc->block_dev.block_write(&mmc->block_dev, 0, 1, mbr);
+
+	/*
+	 * TODO : set boot partition size for emmc
+	 * mmc->ext_csd.boot_size_multi = 0;
+	 */
+	mmc = init_mmc_device(dev_num, true);
+	if (!mmc) {
+		printf("Card NOT detected or Init Failed!!\n");
+		return	-1;
+	}
+
+	if(rv == 1)
+		return	0;
+	else
+		return	-1;
+}
+
+int get_mmc_part_info(char *device_name, int part_num,
+	u64 *block_start, u64 *block_count, uchar *part_Id)
+{
+	int		rv;
+	PartitionInfo	partInfo;
+	ALLOC_CACHE_ALIGN_BUFFER(uchar, mbr, 512);
+
+	rv = get_mmc_mbr(device_name, mbr);
+	if(rv !=0)
+		return -1;
+
+	switch(part_num)
+	{
+		case 1:
+			decode_partitionInfo(&mbr[0x1BE], &partInfo);
+			*block_start	= partInfo.block_start;
+			*block_count	= partInfo.block_count;
+			*part_Id 	= partInfo.partitionId;
+			break;
+		case 2:
+			decode_partitionInfo(&mbr[0x1CE], &partInfo);
+			*block_start	= partInfo.block_start;
+			*block_count	= partInfo.block_count;
+			*part_Id 	= partInfo.partitionId;
+			break;
+		case 3:
+			decode_partitionInfo(&mbr[0x1DE], &partInfo);
+			*block_start	= partInfo.block_start;
+			*block_count	= partInfo.block_count;
+			*part_Id 	= partInfo.partitionId;
+			break;
+		case 4:
+			decode_partitionInfo(&mbr[0x1EE], &partInfo);
+			*block_start	= partInfo.block_start;
+			*block_count	= partInfo.block_count;
+			*part_Id 	= partInfo.partitionId;
+			break;
+		default:
+			return -1;
+	}
+	return 0;
+}
+
+static int print_mmc_part_info(int argc, char * const argv[])
+{
+	PartitionInfo	partInfo[4];
+
+	if (get_mmc_part_info(argv[2], 1, &(partInfo[0].block_start), &(partInfo[0].block_count),
+			&(partInfo[0].partitionId) ))	return	CMD_RET_FAILURE;
+
+	if (get_mmc_part_info(argv[2], 2, &(partInfo[1].block_start), &(partInfo[1].block_count),
+			&(partInfo[1].partitionId) ))	return	CMD_RET_FAILURE;
+
+	if (get_mmc_part_info(argv[2], 3, &(partInfo[2].block_start), &(partInfo[2].block_count),
+			&(partInfo[2].partitionId) ))	return	CMD_RET_FAILURE;
+
+	if (get_mmc_part_info(argv[2], 4, &(partInfo[3].block_start), &(partInfo[3].block_count),
+			&(partInfo[3].partitionId) ))	return	CMD_RET_FAILURE;
+
+	printf("\n");
+	printf("partion #    size(MB)     block start #    block count    partition_Id \n");
+
+	if ( (partInfo[0].block_start !=0) && (partInfo[0].block_count != 0) )
+		printf("   1        %6lld         %8lld        %8lld          0x%.2X \n",
+			(partInfo[0].block_count / 2048), partInfo[0].block_start,
+			partInfo[0].block_count, partInfo[0].partitionId);
+
+	if ( (partInfo[1].block_start !=0) && (partInfo[1].block_count != 0) )
+		printf("   2        %6lld         %8lld        %8lld          0x%.2X \n",
+			(partInfo[1].block_count / 2048), partInfo[1].block_start,
+			partInfo[1].block_count, partInfo[1].partitionId);
+
+	if ( (partInfo[2].block_start !=0) && (partInfo[2].block_count != 0) )
+		printf("   3        %6lld         %8lld        %8lld          0x%.2X \n",
+			(partInfo[2].block_count / 2048), partInfo[2].block_start,
+			partInfo[2].block_count, partInfo[2].partitionId);
+
+	if ( (partInfo[3].block_start !=0) && (partInfo[3].block_count != 0) )
+		printf("   4        %6lld         %8lld        %8lld          0x%.2X \n",
+			(partInfo[3].block_count / 2048), partInfo[3].block_start,
+			partInfo[3].block_count, partInfo[3].partitionId);
+
+	return	CMD_RET_SUCCESS;
+}
+
+static int create_mmc_fdisk(int argc, char * const argv[])
+{
+	int	rv;
+	uint	total_block_count;
+	ALLOC_CACHE_ALIGN_BUFFER(uchar, mbr, 512);
+
+	memset(mbr, 0x00, 512);
+
+	total_block_count = get_mmc_block_count(argv[2]);
+	if (total_block_count < 0)
+		return CMD_RET_FAILURE;
+
+	make_mmc_partition(total_block_count, mbr, argc, argv);
+
+	rv = put_mmc_mbr(mbr, argv[2]);
+	if (rv != 0)
+		return CMD_RET_FAILURE;
+
+	puts("\nfdisk is completed\n");
+
+	return	CMD_RET_SUCCESS;
+}
+
+static int do_fdisk(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	switch (argc) {
+	default :
+		break;
+	case	3:	case	6:	case	7:
+		if (argv[2][0] != '0' && argv[2][0] != '1') {
+			printf("Error :");
+			printf("Wrong device number\n");
+			return	CMD_RET_FAILURE;
+		}
+		if (argv[1][1] == 'c')
+			create_mmc_fdisk(argc, argv);
+		if (argv[1][1] == 'c' || argv[1][1] == 'p') {
+			argv[1][1] = 'p';
+			print_mmc_part_info(argc, argv);
+			return	CMD_RET_SUCCESS;
+		}
+	}
+	return	CMD_RET_USAGE;
+}
+
+U_BOOT_CMD (
+	fdisk, 7, 0, do_fdisk,
+	"Create(-c) or show(-p) partitions in mmc.",
+	"-c <device_num> [<systemt size(MB)> <user data size(MB)> <cache size(MB)> [fat size(MB)]\n"
+	"fdisk -p <device_num>\n"
+);
+
+
+#define	GB_BLK_CNT	((1024*1024*1024)/(512))
+
+static int do_get_mmc_size(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int total_blk_cnt = 0;
+
+	if ( argc == 2 )
+	{
+		total_blk_cnt = get_mmc_block_count(argv[1]);
+
+		if 	(total_blk_cnt > (200 * GB_BLK_CNT))	env_set("mmc_size_gb", "256");
+		else if (total_blk_cnt > (100 * GB_BLK_CNT))	env_set("mmc_size_gb", "128");
+		else if (total_blk_cnt > (50  * GB_BLK_CNT))	env_set("mmc_size_gb", "64");
+		else if (total_blk_cnt > (25  * GB_BLK_CNT))	env_set("mmc_size_gb", "32");
+		else if (total_blk_cnt > (10  * GB_BLK_CNT))	env_set("mmc_size_gb", "16");
+		else if (total_blk_cnt > (5   * GB_BLK_CNT))	env_set("mmc_size_gb", "8");
+		else if (total_blk_cnt > (3   * GB_BLK_CNT))	env_set("mmc_size_gb", "4");
+		else if (total_blk_cnt > (1   * GB_BLK_CNT))	env_set("mmc_size_gb", "2");
+		else						env_set("mmc_size_gb", "1");
+
+		if (total_blk_cnt <= 0)  {
+			env_set("mmc_size_gb", "0");
+			return	CMD_RET_FAILURE;
+		}
+		return	CMD_RET_SUCCESS;
+	}
+	return	CMD_RET_USAGE;
+}
+
+U_BOOT_CMD(
+	get_mmc_size, 2, 0, do_get_mmc_size,
+	"Check mmc device size.",
+	"<device_num>\n"
+	"MMC size writes to env variable mmc_size_gb [1, 2, 4, 8, 16, 32, 64, 128]\n"
+);
+
+#include <samsung/odroid_misc.h>
+
+static int get_partition_info(const char *ptn, struct partition_info *pinfo)
+{
+	switch(ptn[0]) {
+	case	'f':
+		return	odroid_get_partition_info("fwbl1", pinfo);
+	case	'b':
+		return	odroid_get_partition_info("bl2", pinfo);
+	case	'u':
+		return	odroid_get_partition_info("bootloader", pinfo);
+	case	't':
+		return	odroid_get_partition_info("tzsw", pinfo);
+	case	'k':
+		return	odroid_get_partition_info("kernel", pinfo);
+	default:
+		break;
+	}
+	return	-1;
+}
+
+static int do_movi(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	unsigned int dev_no, ret = -1, addr, offset = 0;
+	struct partition_info pinfo;
+
+	switch(argc)	{
+	case	3:
+		if ('i' == argv[1][0]) {
+			dev_no  = simple_strtoul(argv[2], NULL, 10);
+			if (dev_no)
+				ret = run_command("mmc dev 1", 0);
+			if (!ret)
+				run_command("mmc info", 0);
+			if (dev_no && !ret)
+				run_command("mmc dev 0", 0);
+
+			return	ret ? CMD_RET_FAILURE:CMD_RET_SUCCESS;
+		}
+		break;
+	case	5:
+		dev_no  = simple_strtoul(argv[3], NULL, 10);
+		addr	= simple_strtoul(argv[4], NULL, 16);
+		ret	= get_partition_info(argv[2], &pinfo);
+		break;
+	case	6:
+		dev_no  = simple_strtoul(argv[4], NULL, 10);
+		addr	= simple_strtoul(argv[5], NULL, 16);
+		ret	= get_partition_info(argv[3], &pinfo);
+		if ((argv[2][0] == 'z') && pinfo.raw_en)
+			offset = 1;
+		break;
+	default	:
+		break;
+	}
+	if (!ret) {
+		struct mmc *mmc;
+		uint blk_start, blk_count;
+
+		blk_start = pinfo.blk_start - offset;
+		blk_count = pinfo.size / MMC_MAX_BLOCK_LEN;
+
+		mmc = find_mmc_device(dev_no);
+
+		printf("mmc block %s, dev %d, addr 0x%x, blk start %d, blk cnt %d\n",
+			(argv[1][0] == 'w') ? "write" : "read",
+			dev_no, (unsigned int)addr, blk_start, blk_count);
+
+		if (argv[1][0] == 'w')
+			mmc->block_dev.block_write(&mmc->block_dev,
+				(pinfo.blk_start - offset),
+				(pinfo.size / MOVI_BLK_SIZE),
+				(int *)addr);
+		else
+			mmc->block_dev.block_read(&mmc->block_dev,
+				(pinfo.blk_start - offset),
+				(pinfo.size / MOVI_BLK_SIZE),
+				(void *)addr);
+		return	CMD_RET_SUCCESS;
+	}
+	return CMD_RET_USAGE;
+}
+
+U_BOOT_CMD(
+	movi, 7, 0, do_movi,
+	"movi emmc/sd r/w command",
+	"{read|write} [zero] {fwbl1|bl2|u-boot|tzsw|kernel} {dev no} {addr}\n"
+	"[zero] - flag for emmc raw partition"
+);
+
+#endif
diff --git a/cmd/odroid_fastboot.c b/cmd/odroid_fastboot.c
new file mode 100755
index 0000000000..9db3d71cff
--- /dev/null
+++ b/cmd/odroid_fastboot.c
@@ -0,0 +1,631 @@
+/*
+ * Copyright 2008 - 2009 Windriver, <www.windriver.com>
+ * Author: Tom Rix <Tom.Rix@windriver.com>
+ *
+ * (C) Copyright 2014 Linaro, Ltd.
+ * Rob Herring <robh@kernel.org>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <common.h>
+#include <command.h>
+#include <console.h>
+#include <malloc.h>
+
+#include <mach/power.h>
+#include <fastboot.h>
+#include <samsung/odroid_misc.h>
+#include <mmc.h>
+
+/*---------------------------------------------------------------------------*/
+static unsigned int download_size;
+static unsigned int download_bytes;
+static unsigned int download_error;
+static int rx_handler (const unsigned char *buffer, unsigned int buffer_size);
+
+/*---------------------------------------------------------------------------*/
+static struct cmd_fastboot_interface interface =
+{
+	.rx_handler            = rx_handler,
+	.reset_handler         = NULL,
+	.product_name          = NULL,
+	.serial_no             = NULL,
+	.nand_block_size       = 0,
+	.transfer_buffer       = (unsigned char *)0xffffffff,
+	.transfer_buffer_size  = 0,
+};
+
+/*---------------------------------------------------------------------------*/
+static int flashing_raw_data(struct partition_info *pinfo,
+	unsigned int addr, u64 size, unsigned int dev_no)
+{
+	struct mmc *mmc;
+	char cmd[64] = { 0, };
+	unsigned int blk_start = pinfo->blk_start;
+	unsigned int blk_cnt  = size / MOVI_BLK_SIZE;
+
+	mmc = find_mmc_device(dev_no);
+
+	if (!IS_SD(mmc) && pinfo->raw_en) {
+		memset(cmd, 0x00, sizeof(cmd));
+		sprintf(cmd, "emmc open %d", dev_no);
+		run_command(cmd, 0);
+		blk_start = pinfo->blk_start -1;
+	}
+
+	mmc->block_dev.block_write(&mmc->block_dev,
+		blk_start,
+		blk_cnt,
+		(const void *)addr);
+	printf("mmc block write, dev %d, addr 0x%x, blk start %d, blk cnt %d\n",
+		dev_no,
+		(unsigned int)addr,
+		blk_start,
+		blk_cnt);
+
+	if (!IS_SD(mmc) && pinfo->raw_en) {
+		memset(cmd, 0x00, sizeof(cmd));
+		sprintf(cmd, "emmc close %d", dev_no);
+		run_command(cmd, 0);
+	}
+	return	0;
+}
+
+/*---------------------------------------------------------------------------*/
+static void erase_partition(struct partition_info *pinfo, unsigned int dev_no)
+{
+	#define	BLOCK_ERASE_SIZE	(512 * 1024)
+
+	unsigned int blk_start = pinfo->blk_start;
+	unsigned int blk_cnt  = pinfo->size / MOVI_BLK_SIZE;
+	struct mmc *mmc;
+	unsigned char *clrbuf =
+		(unsigned char *)calloc(sizeof(char), BLOCK_ERASE_SIZE);
+
+	printf("Erasing partition(%s)... blk_st = %d, blk_cnt = %d\n",
+		pinfo->name, blk_start, blk_cnt);
+
+	mmc = find_mmc_device(dev_no);
+
+	if (blk_start & 0x3FF) {
+		mmc->block_dev.block_write(&mmc->block_dev,
+			blk_start,
+			1024 - (blk_start & 0x3ff),
+			clrbuf);
+		printf("*** erase start block 0x%x ***\n", blk_start);
+		blk_cnt = blk_cnt - (1024 - (blk_start & 0x3FFF));
+		blk_start = (blk_start & (~0x3FFF)) + 1024;
+	}
+	if (blk_cnt & 0x3FF) {
+		mmc->block_dev.block_write(&mmc->block_dev,
+			blk_start + blk_cnt - (blk_cnt & 0x3FF),
+			(blk_cnt & 0x3FF),
+			clrbuf);
+		printf("*** erase block length 0x%x ***\n", blk_cnt);
+		blk_cnt = blk_cnt - (blk_cnt & 0x3FFF);
+	}
+	if (blk_cnt >> 10) {
+		mmc->block_dev.block_erase(&mmc->block_dev, blk_start, blk_cnt);
+		printf("*** erase block start 0x%x, cnt 0x%x ***\n", blk_start, blk_cnt);
+	}
+
+	free(clrbuf);
+}
+
+/*---------------------------------------------------------------------------*/
+static int check_compress_ext4(char *img_base, unsigned long long parti_size) {
+	ext4_file_header *file_header;
+
+	file_header = (ext4_file_header*)img_base;
+
+	if (file_header->magic != EXT4_FILE_HEADER_MAGIC) {
+		return -1;
+	}
+
+	if (file_header->major != EXT4_FILE_HEADER_MAJOR) {
+		printf("Invalid Version Info! 0x%2x\n", file_header->major);
+		return -1;
+	}
+
+	if (file_header->file_header_size != EXT4_FILE_HEADER_SIZE) {
+		printf("Invalid File Header Size! 0x%8x\n",
+			file_header->file_header_size);
+		return -1;
+	}
+
+	if (file_header->chunk_header_size != EXT4_CHUNK_HEADER_SIZE) {
+		printf("Invalid Chunk Header Size! 0x%8x\n",
+			file_header->chunk_header_size);
+		return -1;
+	}
+
+	if (file_header->block_size != EXT4_FILE_BLOCK_SIZE) {
+		printf("Invalid Block Size! 0x%8x\n", file_header->block_size);
+		return -1;
+	}
+
+	if ((parti_size/file_header->block_size)  < file_header->total_blocks) {
+		printf("Invalid Volume Size! Image is bigger than partition size!\n");
+		printf("partion size %lld , image size %d \n",
+			(parti_size/file_header->block_size), file_header->total_blocks);
+		while(1);
+	}
+
+	/* image is compressed ext4 */
+	return 0;
+}
+
+/*---------------------------------------------------------------------------*/
+static int write_compressed_ext4(char* img_base, unsigned int sector_base,
+	unsigned int dev_no)
+{
+	#define SECTOR_BITS	9	/* 512B */
+
+	unsigned int sector_size;
+	int total_chunks;
+	ext4_chunk_header *chunk_header;
+	ext4_file_header *file_header;
+	struct mmc *mmc;
+
+	mmc = find_mmc_device(dev_no);
+
+	file_header = (ext4_file_header*)img_base;
+	total_chunks = file_header->total_chunks;
+
+	printf("%s : total chunk = %d \n", __func__, total_chunks);
+
+	img_base += EXT4_FILE_HEADER_SIZE;
+
+	odroid_led_ctrl	(GPIO_LED_G, 1);
+	while(total_chunks) {
+		chunk_header = (ext4_chunk_header*)img_base;
+		sector_size =
+			(chunk_header->chunk_size *
+				file_header->block_size) >> SECTOR_BITS;
+
+		switch(chunk_header->type)
+		{
+		case EXT4_CHUNK_TYPE_RAW:
+			mmc->block_dev.block_write(&mmc->block_dev,
+				sector_base,
+				sector_size,
+				(const void *)(img_base + EXT4_CHUNK_HEADER_SIZE));
+			sector_base += sector_size;
+			break;
+
+		case EXT4_CHUNK_TYPE_FILL:
+			printf("*** fill_chunk ***\n");
+			sector_base += sector_size;
+			break;
+
+		case EXT4_CHUNK_TYPE_NONE:
+			printf("none chunk \n");
+			sector_base += sector_size;
+			break;
+
+		default:
+			printf("*** unknown chunk type ***\n");
+			sector_base += sector_size;
+			break;
+		}
+		total_chunks--;
+		printf("mmc write dev %d, blk = 0x%08x, size = 0x%08x, remain chunks = %d\n",
+			dev_no,
+			sector_base,
+			sector_size,
+			total_chunks);
+
+		img_base += chunk_header->total_size;
+	};
+
+	odroid_led_ctrl	(GPIO_LED_G, 0);
+	printf("write done \n");
+	return 0;
+}
+
+/*---------------------------------------------------------------------------*/
+static int flashing_data(struct partition_info *pinfo,
+	unsigned int addr, unsigned int size, unsigned int dev_no)
+{
+	if (check_compress_ext4((char *)addr, pinfo->size))
+		flashing_raw_data(pinfo, addr, pinfo->size, dev_no);
+	else {
+		erase_partition(pinfo, dev_no);
+		write_compressed_ext4((char*)addr, pinfo->blk_start, dev_no);
+	}
+
+	printf("\npartition '%s' flashed.\n\n", pinfo->name);
+	return	0;
+}
+
+/*---------------------------------------------------------------------------*/
+static int rx_handler (const unsigned char *buffer, unsigned int buffer_size)
+{
+	int ret = 1;
+
+	/* Use 65 instead of 64
+	   null gets dropped
+	   strcpy's need the extra byte */
+	char response[65];
+
+	if (download_size) {
+		/* Something to download */
+
+		if (buffer_size) {
+			/* Handle possible overflow */
+			unsigned int transfer_size = download_size - download_bytes;
+
+			if (buffer_size < transfer_size)
+				transfer_size = buffer_size;
+
+			/* Save the data to the transfer buffer */
+			memcpy (interface.transfer_buffer + download_bytes,
+				buffer, transfer_size);
+
+			download_bytes += transfer_size;
+
+			/* Check if transfer is done */
+			if (download_bytes >= download_size) {
+				/* Reset global transfer variable,
+				   Keep download_bytes because it will be
+				   used in the next possible flashing command */
+				download_size = 0;
+
+				if (download_error) {
+					/* There was an earlier error */
+					sprintf(response, "ERROR");
+				} else {
+					/* Everything has transferred,
+					   send the OK response */
+					sprintf(response, "OKAY");
+				}
+				fastboot_tx_status(response, strlen(response), FASTBOOT_TX_ASYNC);
+
+				printf("\ndownloading of %d bytes finished\n", download_bytes);
+			}
+
+			/* Provide some feedback */
+			if (download_bytes && download_size &&
+			    0 == (download_bytes & (0x100000 - 1))) {
+				/* Some feeback that the download is happening */
+				if (download_error)
+					printf("X");
+				else
+					printf(".");
+				if (0 == (download_bytes %
+					  (80 * 0x100000)))
+					printf("\n");
+			}
+		} else {
+			/* Ignore empty buffers */
+			printf("Warning empty download buffer\n");
+			printf("Ignoring\n");
+		}
+		ret = 0;
+	} else {
+		/* A command */
+
+		/* Cast to make compiler happy with string functions */
+		const char *cmdbuf = (char *) buffer;
+
+		/* Generic failed response */
+		sprintf(response, "FAIL");
+
+		/* reboot
+		   Reboot the board. */
+		if (memcmp(cmdbuf, "reboot", 6) == 0) {
+			if (!strcmp(cmdbuf + 6, "-bootloader")) {
+				struct exynos5_power *pmu =
+					(struct exynos5_power *)samsung_get_base_power();
+				pmu->sysip_dat0 = FASTBOOT_MAGIC_REBOOT_CMD; 
+				printf("reboot-bootloader (reboot fastboot)\n");			    
+			} else {
+				memset(interface.transfer_buffer, 0x0, FASTBOOT_REBOOT_MAGIC_SIZE);
+			}
+
+			sprintf(response,"OKAY");
+			fastboot_tx_status(response, strlen(response), FASTBOOT_TX_SYNC);
+
+			do_reset (NULL, 0, 0, NULL);
+
+			/* This code is unreachable,
+			   leave it to make the compiler happy */
+			return 0;
+		}
+
+		/* getvar
+		   Get common fastboot variables
+		   Board has a chance to handle other variables */
+		if (memcmp(cmdbuf, "getvar:", 7) == 0)
+		{
+			strcpy(response,"OKAY");
+
+			if (!strcmp(cmdbuf + 7, "version")) {
+				strcpy(response + 4, FASTBOOT_VERSION);
+			} else if (!strcmp(cmdbuf + 7, "product")) {
+				if (interface.product_name)
+					strcpy(response + 4, interface.product_name);
+			} else if (!strcmp(cmdbuf + 7, "serialno")) {
+				if (interface.serial_no)
+					strcpy(response + 4, interface.serial_no);
+			} else if (!strcmp(cmdbuf + 7, "downloadsize")) {
+				if (interface.transfer_buffer_size)
+					sprintf(response + 4, "%08x", interface.transfer_buffer_size);
+			} else {
+				fastboot_getvar(cmdbuf + 7, response + 4);
+			}
+			ret = 0;
+			goto send_tx_status;
+		}
+
+		/* erase
+		   Erase a register flash partition
+		   Board has to set up flash partitions */
+		if (memcmp(cmdbuf, "erase:", 6) == 0)
+		{
+			struct partition_info pinfo;
+
+			ret = 0;
+			printf("partition '%s' erased\n", cmdbuf + 6);
+			if (!strncmp(cmdbuf + 6, "fat", sizeof("fat"))) {
+				run_command("fatformat mmc 0:1", 0);
+				sprintf(response, "OKAY");
+				goto send_tx_status;
+			}
+			if (odroid_get_partition_info(&cmdbuf[6], &pinfo))
+				sprintf(response, "FAILUnsupport partitiond");
+			else {
+				if (!pinfo.raw_en) {
+					erase_partition(&pinfo, 0);
+					sprintf(response, "OKAY");
+				}
+				else
+					sprintf(response, "FAILUnsupport or Unknown partitiond");
+			}
+			goto send_tx_status;
+		}
+
+		/* download
+		   download something ..
+		   What happens to it depends on the next command after data */
+		if (memcmp(cmdbuf, "download:", 9) == 0)
+		{
+			/* save the size */
+			download_size = simple_strtoul(cmdbuf + 9, NULL, 16);
+			/* Reset the bytes count, now it is safe */
+			download_bytes = 0;
+			/* Reset error */
+			download_error = 0;
+
+			printf("Starting download of %d bytes\n", download_size);
+
+			if (0 == download_size) {
+				/* bad user input */
+				sprintf(response, "FAILdata invalid size");
+			} else if (download_size > interface.transfer_buffer_size) {
+				/* set download_size to 0 because this is an error */
+				download_size = 0;
+				sprintf(response, "FAILdata too large");
+			} else {
+				/* The default case, the transfer fits
+				   completely in the interface buffer */
+				sprintf(response, "DATA%08x", download_size);
+			}
+			ret = 0;
+			goto send_tx_status;
+		}
+
+		/* flash
+		   Flash what was downloaded */
+		if (memcmp(cmdbuf, "flash:", 6) == 0) {
+			struct partition_info pinfo;
+
+			ret = 0;
+			if (download_bytes == 0) {
+				sprintf(response, "FAILno image downloaded");
+				goto send_tx_status;
+			}
+			if (odroid_get_partition_info(&cmdbuf[6], &pinfo)) {
+				sprintf(response, "FAILunknown(%s) partition!",
+					cmdbuf + 6);
+				goto send_tx_status;
+			}
+			if (pinfo.size < download_bytes) {
+				sprintf(response, "FAILimage too large for partition(%s)!",
+					cmdbuf + 6);
+				goto send_tx_status;
+			}
+			if (flashing_data(&pinfo,
+				(unsigned int)interface.transfer_buffer,
+				download_bytes, 0)) {
+					sprintf(response, "FAILfailed to flash %s partition!",
+					cmdbuf + 6);
+				goto send_tx_status;
+			}
+			sprintf(response, "OKAY");
+			goto send_tx_status;
+		}
+		/* verify */
+		/* continue */
+		/* powerdown */
+send_tx_status:
+		fastboot_tx_status(response, strlen(response), FASTBOOT_TX_ASYNC);
+	} /* End of command */
+
+	return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+static int fastboot_cmd_flash(int argc, char *const argv[])
+{
+	struct partition_info pinfo;
+	unsigned int addr, dev_no = 0;
+
+	if (odroid_get_partition_info(argv[2], &pinfo))
+		return	1;
+
+	addr = simple_strtoul(argv[3], NULL, 16);
+	if (argc == 5)
+		dev_no = simple_strtoul(argv[4], NULL, 16);
+
+	if ((dev_no != 0) && (dev_no != 1))
+		dev_no = 0;
+
+	flashing_data(&pinfo, addr, pinfo.size, dev_no);
+
+	if (dev_no)
+		run_command("mmc dev 0", 0);
+
+	return	0;
+}
+
+/*---------------------------------------------------------------------------*/
+static int fastboot_cmd_parsing(int argc, char *const argv[], int *retval)
+{
+	int	ret = 0;
+	*retval = CMD_RET_FAILURE;
+
+	switch(argc) {
+	case	2:
+		if (!strncmp(argv[1], "poweroff", sizeof("poweroff"))) {
+			odroid_power_off();
+			while(1);
+		}
+		*retval = CMD_RET_USAGE;
+		break;
+	case	5:	case	6:
+		if (argv[4] != NULL)
+			ret = odroid_partition_setup(argv[4]);
+		else
+			ret = odroid_partition_setup("0");
+
+		if (!ret)
+			ret = fastboot_cmd_flash(argc, argv);
+
+		*retval = ret ? CMD_RET_FAILURE:CMD_RET_SUCCESS;
+		break;
+	default:
+		*retval = CMD_RET_USAGE;
+		break;
+	/* normal fastboot */
+	case	1:
+		ret = odroid_partition_setup("0");
+		*retval = ret ? CMD_RET_FAILURE:CMD_RET_SUCCESS;
+		return	*retval;
+	}
+	return	1;
+}
+
+/*---------------------------------------------------------------------------*/
+static int do_fastboot(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	int continue_from_disconnect = 0, poll_status, retval;
+	int led_status = 0, led_blink_cnt = 0;
+	int ret = 1;
+
+	/* fastboot command parsing */
+	if (fastboot_cmd_parsing(argc, argv, &retval))
+		return retval;
+	do
+	{
+		continue_from_disconnect = 0;
+
+		/* Initialize the board specific support */
+		if (0 == fastboot_init(&interface))
+		{
+			/* If we got this far, we are a success */
+			ret = 0;
+
+			while (1)
+			{
+				/* Green LED Blink */
+				if (led_blink_cnt++ > 0x8000) {
+					if (led_status) {
+						odroid_led_ctrl	(GPIO_LED_G, led_status);
+						led_status = 0;
+					} else {
+						odroid_led_ctrl	(GPIO_LED_G, led_status);
+						led_status = 1;
+					}
+					led_blink_cnt = 0;
+				}
+
+				poll_status = fastboot_poll();
+
+				/* Check if the user wanted to terminate with ^C */
+				if ((FASTBOOT_OK != poll_status) && ctrlc()) {
+					printf("Fastboot ended by user\n");
+					continue_from_disconnect = 0;
+					break;
+				}
+
+				if (FASTBOOT_ERROR == poll_status) {
+					/* Error */
+					printf("Fastboot error \n");
+					break;
+				}
+				else if (FASTBOOT_DISCONNECT == poll_status) {
+					/* break, cleanup and re-init */
+					printf("Fastboot disconnect detected\n");
+					continue_from_disconnect = 1;
+					break;
+				}
+			} /* while (1) */
+		}
+		/* Reset the board specific support */
+		fastboot_shutdown();
+		/* restart the loop if a disconnect was detected */
+	} while (continue_from_disconnect);
+
+	odroid_led_ctrl	(GPIO_LED_G, 0);
+	return	ret;
+}
+
+U_BOOT_CMD(
+	fastboot, 5, 1, do_fastboot,
+	"use USB Fastboot protocol",
+	"[ poweroff | flash [kernel|system|userdata|cache] [addr] [dev no] ]\n"
+	"[] - options for self update"
+);
+
+/*---------------------------------------------------------------------------*/
+static int do_self_update(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	uint	option = 0;
+
+	switch(argc) {
+	case	2:
+		if ((argv[1][0] == 'h') || (argv[1][0] == '-'))
+			return	CMD_RET_USAGE;
+
+		option = (uint)simple_strtoul(argv[1], NULL, 16);
+		printf("%s : option = 0x%x\n", __func__, option);
+		odroid_self_update(option);
+		return	CMD_RET_SUCCESS;
+
+	default :
+		return	CMD_RET_USAGE;
+	}
+}
+
+U_BOOT_CMD(
+	self_update, 2, 0, do_self_update,
+	"self update for android",
+	"[ option val ]\n\n"
+	"==== OPTION Value ====\n"
+	"-h or h : usage display\n"
+	"ERASE_USERDATA = 0x01, ERASE_FAT = 0x02, ERASE_ENV = 0x04\n"
+	"UPDATE_UBOOT = 0x08, RESIZE_PART = 0x10, FILELOAD_EXT4 = 0x20\n"
+	"OPTION_OLDTYPE_PART = 0x40\n\n"
+	"RESIZE_PART flag : expand partition for userdata\n"
+	"	--> fdisk -c 0 1024 0 256 100\n"
+	"	--> System 1G / Userdata expand / Cache 256M / Vfat 100M\n\n"
+	"FILELOAD_EXT4 flag : update file load from userdata partition(ext4)\n"
+	"	--> ext4load mmc 0:3 media/0/update\n\n"
+	"OLDTYPE_PART flag : old style partition setup\n"
+	"	--> fdisk -c 0\n"
+	"	--> System 1G / Userdata 2G / Cache 256M / Vfat expand\n\n"
+);
+
+/*---------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------*/
diff --git a/common/autoboot.c b/common/autoboot.c
old mode 100644
new mode 100755
index a011865028..458740daab
--- a/common/autoboot.c
+++ b/common/autoboot.c
@@ -212,13 +212,16 @@ static int __abortboot(int bootdelay)
 {
 	int abort = 0;
 	unsigned long ts;
+	int key;
+	unsigned char keycheck = 2;
 
 #ifdef CONFIG_MENUPROMPT
 	printf(CONFIG_MENUPROMPT);
 #else
-	printf("Hit any key to stop autoboot: %2d ", bootdelay);
+	printf("Press quickly 'Enter' twice to stop autoboot: %2d ", bootdelay);
 #endif
 
+#if defined CONFIG_ZERO_BOOTDELAY_CHECK
 	/*
 	 * Check if key already pressed
 	 */
@@ -227,21 +230,32 @@ static int __abortboot(int bootdelay)
 		puts("\b\b\b 0");
 		abort = 1;	/* don't auto boot	*/
 	}
+#endif
 
 	while ((bootdelay > 0) && (!abort)) {
 		--bootdelay;
 		/* delay 1000 ms */
 		ts = get_timer(0);
 		do {
-			if (tstc()) {	/* we got a key press	*/
-				abort  = 1;	/* don't auto boot	*/
-				bootdelay = 0;	/* no more delay	*/
+			if (tstc()) {
 # ifdef CONFIG_MENUKEY
 				menukey = getc();
+				key = menukey;
 # else
-				(void) getc();  /* consume input	*/
+				key = getc();
 # endif
-				break;
+				switch (key) {
+				/* Enter Key */
+				case 0x0d:
+					--keycheck;
+					if(!keycheck) {
+						abort = 1;
+						bootdelay = 0;
+					}
+					break;
+				default:
+					break;
+				}
 			}
 			udelay(10000);
 		} while (!abort && get_timer(ts) < 1000);
diff --git a/configs/odroid-xu4_defconfig b/configs/odroid-xu4_defconfig
new file mode 100644
index 0000000000..9f4cae39c5
--- /dev/null
+++ b/configs/odroid-xu4_defconfig
@@ -0,0 +1,926 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# U-Boot 2017.05 Configuration
+#
+CONFIG_CREATE_ARCH_SYMLINK=y
+# CONFIG_ARC is not set
+CONFIG_ARM=y
+# CONFIG_AVR32 is not set
+# CONFIG_M68K is not set
+# CONFIG_MICROBLAZE is not set
+# CONFIG_MIPS is not set
+# CONFIG_NDS32 is not set
+# CONFIG_NIOS2 is not set
+# CONFIG_PPC is not set
+# CONFIG_SANDBOX is not set
+# CONFIG_SH is not set
+# CONFIG_X86 is not set
+# CONFIG_XTENSA is not set
+CONFIG_SYS_ARCH="arm"
+CONFIG_SYS_CPU="armv7"
+CONFIG_SYS_SOC="exynos"
+CONFIG_SYS_VENDOR="samsung"
+CONFIG_SYS_BOARD="smdk5420"
+CONFIG_SYS_CONFIG_NAME="odroid_xu4"
+
+#
+# ARM architecture
+#
+CONFIG_HAS_VBAR=y
+CONFIG_HAS_THUMB2=y
+CONFIG_CPU_V7=y
+CONFIG_SYS_ARM_ARCH=7
+CONFIG_SYS_CACHE_SHIFT_6=y
+CONFIG_SYS_CACHELINE_SIZE=64
+# CONFIG_ARM_SMCCC is not set
+# CONFIG_SEMIHOSTING is not set
+# CONFIG_SYS_THUMB_BUILD is not set
+# CONFIG_SPL_SYS_THUMB_BUILD is not set
+# CONFIG_SYS_L2CACHE_OFF is not set
+# CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK is not set
+# CONFIG_ARM_CORTEX_CPU_IS_UP is not set
+CONFIG_USE_ARCH_MEMCPY=y
+CONFIG_SPL_USE_ARCH_MEMCPY=y
+CONFIG_USE_ARCH_MEMSET=y
+CONFIG_SPL_USE_ARCH_MEMSET=y
+# CONFIG_ARM64_SUPPORT_AARCH32 is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_TARGET_EDB93XX is not set
+# CONFIG_TARGET_ASPENITE is not set
+# CONFIG_TARGET_GPLUGD is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_KIRKWOOD is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_TARGET_DEVKIT3250 is not set
+# CONFIG_TARGET_WORK_92105 is not set
+# CONFIG_TARGET_MX25PDK is not set
+# CONFIG_TARGET_ZMX25 is not set
+# CONFIG_TARGET_APF27 is not set
+# CONFIG_TARGET_APX4DEVKIT is not set
+# CONFIG_TARGET_XFI3 is not set
+# CONFIG_TARGET_M28EVK is not set
+# CONFIG_TARGET_MX23EVK is not set
+# CONFIG_TARGET_MX28EVK is not set
+# CONFIG_TARGET_MX23_OLINUXINO is not set
+# CONFIG_TARGET_BG0900 is not set
+# CONFIG_TARGET_SANSA_FUZE_PLUS is not set
+# CONFIG_TARGET_SC_SPS_1 is not set
+# CONFIG_ORION5X is not set
+# CONFIG_TARGET_SPEAR300 is not set
+# CONFIG_TARGET_SPEAR310 is not set
+# CONFIG_TARGET_SPEAR320 is not set
+# CONFIG_TARGET_SPEAR600 is not set
+# CONFIG_TARGET_STV0991 is not set
+# CONFIG_TARGET_X600 is not set
+# CONFIG_TARGET_IMX31_PHYCORE is not set
+# CONFIG_TARGET_IMX31_PHYCORE_EET is not set
+# CONFIG_TARGET_MX31ADS is not set
+# CONFIG_TARGET_MX31PDK is not set
+# CONFIG_TARGET_WOODBURN is not set
+# CONFIG_TARGET_WOODBURN_SD is not set
+# CONFIG_TARGET_FLEA3 is not set
+# CONFIG_TARGET_MX35PDK is not set
+# CONFIG_ARCH_BCM283X is not set
+# CONFIG_TARGET_VEXPRESS_CA15_TC2 is not set
+# CONFIG_TARGET_VEXPRESS_CA5X2 is not set
+# CONFIG_TARGET_VEXPRESS_CA9X4 is not set
+# CONFIG_TARGET_BCM23550_W1D is not set
+# CONFIG_TARGET_BCM28155_AP is not set
+# CONFIG_TARGET_BCMCYGNUS is not set
+# CONFIG_TARGET_BCMNSP is not set
+# CONFIG_TARGET_BCMNS2 is not set
+CONFIG_ARCH_EXYNOS=y
+# CONFIG_ARCH_S5PC1XX is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_KEYSTONE is not set
+# CONFIG_ARCH_OMAP2PLUS is not set
+# CONFIG_ARCH_MESON is not set
+# CONFIG_ARCH_MX7ULP is not set
+# CONFIG_ARCH_MX7 is not set
+# CONFIG_ARCH_MX6 is not set
+# CONFIG_ARCH_MX5 is not set
+# CONFIG_ARCH_RMOBILE is not set
+# CONFIG_TARGET_S32V234EVB is not set
+# CONFIG_ARCH_SNAPDRAGON is not set
+# CONFIG_ARCH_SOCFPGA is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_TARGET_TS4600 is not set
+# CONFIG_ARCH_VF610 is not set
+# CONFIG_ARCH_ZYNQ is not set
+# CONFIG_ARCH_ZYNQMP is not set
+# CONFIG_TEGRA is not set
+# CONFIG_TARGET_VEXPRESS64_AEMV8A is not set
+# CONFIG_TARGET_VEXPRESS64_BASE_FVP is not set
+# CONFIG_TARGET_VEXPRESS64_BASE_FVP_DRAM is not set
+# CONFIG_TARGET_VEXPRESS64_JUNO is not set
+# CONFIG_TARGET_LS2080A_EMU is not set
+# CONFIG_TARGET_LS2080A_SIMU is not set
+# CONFIG_TARGET_LS2080AQDS is not set
+# CONFIG_TARGET_LS2080ARDB is not set
+# CONFIG_TARGET_HIKEY is not set
+# CONFIG_TARGET_LS1012AQDS is not set
+# CONFIG_TARGET_LS1012ARDB is not set
+# CONFIG_TARGET_LS1012AFRDM is not set
+# CONFIG_TARGET_LS1021AQDS is not set
+# CONFIG_TARGET_LS1021ATWR is not set
+# CONFIG_TARGET_LS1021AIOT is not set
+# CONFIG_TARGET_LS1043AQDS is not set
+# CONFIG_TARGET_LS1043ARDB is not set
+# CONFIG_TARGET_LS1046AQDS is not set
+# CONFIG_TARGET_LS1046ARDB is not set
+# CONFIG_TARGET_H2200 is not set
+# CONFIG_TARGET_ZIPITZ2 is not set
+# CONFIG_TARGET_COLIBRI_PXA270 is not set
+# CONFIG_ARCH_UNIPHIER is not set
+# CONFIG_STM32 is not set
+# CONFIG_ARCH_STI is not set
+# CONFIG_ARCH_ROCKCHIP is not set
+# CONFIG_TARGET_THUNDERX_88XX is not set
+# CONFIG_ARCH_ASPEED is not set
+# CONFIG_ARCH_EXYNOS4 is not set
+CONFIG_ARCH_EXYNOS5=y
+# CONFIG_ARCH_EXYNOS7 is not set
+CONFIG_SPL_GPIO_SUPPORT=y
+CONFIG_SPL_LIBCOMMON_SUPPORT=y
+CONFIG_SPL_LIBGENERIC_SUPPORT=y
+# CONFIG_TARGET_ODROID_XU3 is not set
+CONFIG_TARGET_ODROID_XU4=y
+# CONFIG_TARGET_ARNDALE is not set
+# CONFIG_TARGET_SMDK5250 is not set
+# CONFIG_TARGET_SNOW is not set
+# CONFIG_TARGET_SPRING is not set
+# CONFIG_TARGET_SMDK5420 is not set
+# CONFIG_TARGET_PEACH_PI is not set
+# CONFIG_TARGET_PEACH_PIT is not set
+CONFIG_SYS_MALLOC_F_LEN=0x400
+# CONFIG_ARMV7_LPAE is not set
+# CONFIG_CMD_DEKBLOB is not set
+CONFIG_IDENT_STRING=" for ODROID-XU4"
+# CONFIG_PRE_CONSOLE_BUFFER is not set
+# CONFIG_VIDEO is not set
+
+#
+# ARM debug
+#
+# CONFIG_DEBUG_LL is not set
+CONFIG_DEFAULT_DEVICE_TREE="exynos5422-odroidxu4"
+CONFIG_SMBIOS_PRODUCT_NAME="smdk5420"
+# CONFIG_AHCI is not set
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_DISTRO_DEFAULTS=y
+CONFIG_SYS_MALLOC_F=y
+CONFIG_EXPERT=y
+# CONFIG_SYS_MALLOC_CLEAR_ON_INIT is not set
+# CONFIG_TOOLS_DEBUG is not set
+# CONFIG_PHYS_64BIT is not set
+
+#
+# Boot images
+#
+CONFIG_FIT=y
+# CONFIG_FIT_SIGNATURE is not set
+# CONFIG_FIT_VERBOSE is not set
+CONFIG_FIT_BEST_MATCH=y
+# CONFIG_SPL_LOAD_FIT is not set
+# CONFIG_OF_BOARD_SETUP is not set
+# CONFIG_OF_SYSTEM_SETUP is not set
+# CONFIG_OF_STDOUT_VIA_ALIAS is not set
+CONFIG_SYS_EXTRA_OPTIONS=""
+CONFIG_ARCH_FIXUP_FDT_MEMORY=y
+
+#
+# API
+#
+# CONFIG_API is not set
+
+#
+# Boot timing
+#
+# CONFIG_BOOTSTAGE is not set
+CONFIG_BOOTSTAGE_USER_COUNT=20
+CONFIG_BOOTSTAGE_STASH_ADDR=0
+CONFIG_BOOTSTAGE_STASH_SIZE=0x1000
+
+#
+# Boot media
+#
+# CONFIG_NAND_BOOT is not set
+# CONFIG_ONENAND_BOOT is not set
+# CONFIG_QSPI_BOOT is not set
+# CONFIG_SATA_BOOT is not set
+# CONFIG_SD_BOOT is not set
+# CONFIG_SPI_BOOT is not set
+
+#
+# Environment
+#
+CONFIG_BOOTDELAY=5
+
+#
+# Console
+#
+CONFIG_MENU=y
+# CONFIG_CONSOLE_RECORD is not set
+CONFIG_SILENT_CONSOLE=y
+# CONFIG_SILENT_U_BOOT_ONLY is not set
+CONFIG_SILENT_CONSOLE_UPDATE_ON_SET=y
+# CONFIG_SILENT_CONSOLE_UPDATE_ON_RELOC is not set
+CONFIG_CONSOLE_MUX=y
+CONFIG_SYS_CONSOLE_IS_IN_ENV=y
+# CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE is not set
+# CONFIG_SYS_CONSOLE_ENV_OVERWRITE is not set
+# CONFIG_SYS_CONSOLE_INFO_QUIET is not set
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_DEFAULT_FDT_FILE=""
+# CONFIG_VERSION_VARIABLE is not set
+CONFIG_DISPLAY_CPUINFO=y
+CONFIG_DISPLAY_BOARDINFO=y
+
+#
+# Start-up hooks
+#
+# CONFIG_ARCH_EARLY_INIT_R is not set
+# CONFIG_ARCH_MISC_INIT is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+
+#
+# SPL / TPL
+#
+CONFIG_SPL_LEGACY_IMAGE_SUPPORT=y
+
+#
+# Command line interface
+#
+CONFIG_CMDLINE=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="Exynos5422 # "
+
+#
+# Autoboot options
+#
+CONFIG_AUTOBOOT=y
+# CONFIG_AUTOBOOT_KEYED is not set
+
+#
+# FASTBOOT
+#
+CONFIG_FASTBOOT=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_CMD_FASTBOOT=y
+CONFIG_ANDROID_BOOT_IMAGE=y
+CONFIG_FASTBOOT_BUF_ADDR=0x20000
+CONFIG_FASTBOOT_BUF_SIZE=0x20000
+CONFIG_FASTBOOT_USB_DEV=0
+CONFIG_FASTBOOT_FLASH=y
+CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_FASTBOOT_GPT_NAME="gpt"
+CONFIG_FASTBOOT_MBR_NAME="mbr"
+
+#
+# Commands
+#
+
+#
+# Info commands
+#
+CONFIG_CMD_BDI=y
+# CONFIG_CMD_CONFIG is not set
+CONFIG_CMD_CONSOLE=y
+# CONFIG_CMD_CPU is not set
+# CONFIG_CMD_LICENSE is not set
+
+#
+# Boot commands
+#
+CONFIG_CMD_BOOTD=y
+CONFIG_CMD_BOOTM=y
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_BOOTEFI=y
+CONFIG_CMD_BOOTEFI_HELLO_COMPILE=y
+# CONFIG_CMD_BOOTEFI_HELLO is not set
+# CONFIG_CMD_BOOTMENU is not set
+CONFIG_CMD_ELF=y
+CONFIG_CMD_FDT=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_RUN=y
+CONFIG_CMD_IMI=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_XIMG=y
+
+#
+# Environment commands
+#
+# CONFIG_CMD_ASKENV is not set
+CONFIG_CMD_EXPORTENV=y
+CONFIG_CMD_IMPORTENV=y
+CONFIG_CMD_EDITENV=y
+# CONFIG_CMD_GREPENV is not set
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_ENV_EXISTS=y
+
+#
+# Memory commands
+#
+CONFIG_CMD_MEMORY=y
+CONFIG_CMD_CRC32=y
+# CONFIG_CMD_MD5SUM is not set
+# CONFIG_LOOPW is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_MX_CYCLIC is not set
+CONFIG_CMD_MEMINFO=y
+# CONFIG_CMD_UNZIP is not set
+# CONFIG_CMD_ZIP is not set
+CONFIG_CMD_DMC=y
+
+#
+# Device access commands
+#
+# CONFIG_CMD_CLK is not set
+CONFIG_CMD_DM=y
+# CONFIG_CMD_DEMO is not set
+CONFIG_CMD_LOADB=y
+CONFIG_CMD_LOADS=y
+CONFIG_CMD_FLASH=y
+# CONFIG_CMD_GPT is not set
+# CONFIG_CMD_ARMFLASH is not set
+CONFIG_CMD_MMC=y
+# CONFIG_CMD_NAND is not set
+CONFIG_CMD_PART=y
+# CONFIG_CMD_SF is not set
+# CONFIG_CMD_SPI is not set
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_DFU=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+# CONFIG_CMD_FPGA is not set
+CONFIG_CMD_GPIO=y
+
+#
+# Shell scripting commands
+#
+CONFIG_CMD_ECHO=y
+CONFIG_CMD_ITEST=y
+CONFIG_CMD_SOURCE=y
+CONFIG_CMD_SETEXPR=y
+
+#
+# Network commands
+#
+CONFIG_CMD_NET=y
+# CONFIG_CMD_TFTPPUT is not set
+# CONFIG_CMD_TFTPSRV is not set
+# CONFIG_CMD_RARP is not set
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PXE=y
+CONFIG_CMD_NFS=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+# CONFIG_CMD_CDP is not set
+# CONFIG_CMD_SNTP is not set
+# CONFIG_CMD_DNS is not set
+# CONFIG_CMD_LINK_LOCAL is not set
+
+#
+# Misc commands
+#
+# CONFIG_CMD_BSP is not set
+# CONFIG_CMD_BKOPS_ENABLE is not set
+CONFIG_CMD_CACHE=y
+# CONFIG_CMD_DISPLAY is not set
+# CONFIG_CMD_LED is not set
+# CONFIG_CMD_DATE is not set
+CONFIG_CMD_TIME=y
+CONFIG_CMD_MISC=y
+# CONFIG_CMD_TIMER is not set
+# CONFIG_CMD_QFW is not set
+
+#
+# Power commands
+#
+CONFIG_CMD_PMIC=y
+CONFIG_CMD_REGULATOR=y
+
+#
+# Security commands
+#
+# CONFIG_CMD_AES is not set
+# CONFIG_CMD_BLOB is not set
+
+#
+# Firmware commands
+#
+
+#
+# Filesystem commands
+#
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+# CONFIG_CMD_FS_UUID is not set
+
+#
+# Debug commands
+#
+# CONFIG_CMD_BEDBUG is not set
+# CONFIG_CMD_DIAG is not set
+# CONFIG_CMD_UBI is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITIONS=y
+# CONFIG_MAC_PARTITION is not set
+CONFIG_DOS_PARTITION=y
+CONFIG_ISO_PARTITION=y
+# CONFIG_AMIGA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+CONFIG_EFI_PARTITION_ENTRIES_OFF=0
+CONFIG_PARTITION_UUIDS=y
+# CONFIG_PARTITION_TYPE_GUID is not set
+CONFIG_SUPPORT_OF_CONTROL=y
+
+#
+# Device Tree Control
+#
+CONFIG_OF_CONTROL=y
+# CONFIG_OF_BOARD_FIXUP is not set
+CONFIG_OF_SEPARATE=y
+# CONFIG_OF_EMBED is not set
+CONFIG_NET=y
+# CONFIG_NET_RANDOM_ETHADDR is not set
+# CONFIG_NETCONSOLE is not set
+CONFIG_NET_TFTP_VARS=y
+CONFIG_BOOTP_PXE_CLIENTARCH=0x15
+CONFIG_BOOTP_VCI_STRING="U-Boot.armv7"
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_DM=y
+CONFIG_DM_WARN=y
+CONFIG_DM_DEVICE_REMOVE=y
+CONFIG_DM_STDIO=y
+CONFIG_DM_SEQ_ALIAS=y
+# CONFIG_SPL_DM_SEQ_ALIAS is not set
+# CONFIG_REGMAP is not set
+# CONFIG_SPL_REGMAP is not set
+# CONFIG_DEVRES is not set
+CONFIG_SIMPLE_BUS=y
+CONFIG_OF_TRANSLATE=y
+CONFIG_ADC=y
+CONFIG_ADC_EXYNOS=y
+# CONFIG_ADC_SANDBOX is not set
+# CONFIG_BLK is not set
+# CONFIG_BLOCK_CACHE is not set
+
+#
+# SATA/SCSI device support
+#
+
+#
+# Clock
+#
+# CONFIG_CLK is not set
+# CONFIG_CPU is not set
+
+#
+# Hardware crypto devices
+#
+# CONFIG_FSL_CAAM is not set
+# CONFIG_SYS_FSL_SEC_BE is not set
+# CONFIG_SYS_FSL_SEC_LE is not set
+
+#
+# Demo for driver model
+#
+# CONFIG_DM_DEMO is not set
+
+#
+# DFU support
+#
+CONFIG_USB_FUNCTION_DFU=y
+# CONFIG_DFU_TFTP is not set
+CONFIG_DFU_MMC=y
+# CONFIG_DFU_NAND is not set
+# CONFIG_DFU_RAM is not set
+# CONFIG_DFU_SF is not set
+
+#
+# DMA Support
+#
+# CONFIG_DMA is not set
+# CONFIG_TI_EDMA3 is not set
+
+#
+# FPGA support
+#
+# CONFIG_FPGA_ALTERA is not set
+# CONFIG_FPGA_XILINX is not set
+
+#
+# GPIO Support
+#
+CONFIG_DM_GPIO=y
+# CONFIG_ALTERA_PIO is not set
+# CONFIG_DWAPB_GPIO is not set
+# CONFIG_AT91_GPIO is not set
+# CONFIG_ATMEL_PIO4 is not set
+# CONFIG_INTEL_BROADWELL_GPIO is not set
+# CONFIG_IMX_RGPIO2P is not set
+# CONFIG_LPC32XX_GPIO is not set
+# CONFIG_MSM_GPIO is not set
+# CONFIG_PCF8575_GPIO is not set
+# CONFIG_ROCKCHIP_GPIO is not set
+# CONFIG_TEGRA_GPIO is not set
+# CONFIG_TEGRA186_GPIO is not set
+# CONFIG_VYBRID_GPIO is not set
+# CONFIG_DM_74X164 is not set
+# CONFIG_DM_PCA953X is not set
+# CONFIG_MPC85XX_GPIO is not set
+
+#
+# I2C support
+#
+CONFIG_DM_I2C=y
+CONFIG_DM_I2C_COMPAT=y
+# CONFIG_I2C_SET_DEFAULT_BUS_NUM is not set
+# CONFIG_DM_I2C_GPIO is not set
+# CONFIG_SYS_I2C_FSL is not set
+# CONFIG_SYS_I2C_DW is not set
+# CONFIG_SYS_I2C_INTEL is not set
+# CONFIG_SYS_I2C_ROCKCHIP is not set
+# CONFIG_SYS_I2C_MVTWSI is not set
+# CONFIG_I2C_MUX is not set
+CONFIG_DM_KEYBOARD=y
+# CONFIG_CROS_EC_KEYB is not set
+# CONFIG_I8042_KEYB is not set
+
+#
+# LED Support
+#
+# CONFIG_LED is not set
+# CONFIG_LED_STATUS is not set
+
+#
+# Mailbox Controller Support
+#
+# CONFIG_DM_MAILBOX is not set
+
+#
+# Memory Controller drivers
+#
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MISC is not set
+# CONFIG_CROS_EC is not set
+# CONFIG_FSL_SEC_MON is not set
+# CONFIG_MXC_OCOTP is not set
+# CONFIG_NUVOTON_NCT6102D is not set
+# CONFIG_PWRSEQ is not set
+# CONFIG_PCA9551_LED is not set
+# CONFIG_WINBOND_W83627 is not set
+
+#
+# MMC Host controller Support
+#
+CONFIG_MMC=y
+CONFIG_GENERIC_MMC=y
+# CONFIG_DM_MMC is not set
+# CONFIG_SPL_MMC_TINY is not set
+CONFIG_MMC_DW=y
+CONFIG_MMC_DW_EXYNOS=y
+# CONFIG_MMC_DW_K3 is not set
+# CONFIG_MMC_MXC is not set
+# CONFIG_MMC_MXS is not set
+# CONFIG_MMC_PCI is not set
+# CONFIG_MMC_OMAP_HS is not set
+CONFIG_MMC_SDHCI=y
+# CONFIG_MMC_SDHCI_SDMA is not set
+# CONFIG_MMC_SDHCI_KONA is not set
+CONFIG_MMC_SDHCI_S5P=y
+# CONFIG_MMC_SDHCI_SPEAR is not set
+# CONFIG_MMC_SDHCI_STI is not set
+
+#
+# MTD Support
+#
+# CONFIG_MTD is not set
+# CONFIG_MTD_NOR_FLASH is not set
+
+#
+# NAND Device Support
+#
+# CONFIG_NAND_DENALI is not set
+# CONFIG_NAND_VF610_NFC is not set
+# CONFIG_NAND_PXA3XX is not set
+# CONFIG_NAND_ARASAN is not set
+# CONFIG_NAND_ZYNQ is not set
+
+#
+# Generic NAND options
+#
+
+#
+# SPI Flash Support
+#
+CONFIG_DM_SPI_FLASH=y
+# CONFIG_SPI_FLASH is not set
+
+#
+# UBI support
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_BITBANGMII is not set
+# CONFIG_MV88E6352_SWITCH is not set
+# CONFIG_PHYLIB is not set
+# CONFIG_DM_ETH is not set
+# CONFIG_NETDEVICES is not set
+# CONFIG_PCI is not set
+# CONFIG_MVEBU_COMPHY_SUPPORT is not set
+
+#
+# Pin controllers
+#
+CONFIG_PINCTRL=y
+CONFIG_PINCTRL_FULL=y
+CONFIG_PINCTRL_GENERIC=y
+CONFIG_PINMUX=y
+CONFIG_PINCONF=y
+# CONFIG_PINCTRL_AT91 is not set
+# CONFIG_PINCTRL_AT91PIO4 is not set
+# CONFIG_PINCTRL_ROCKCHIP_RK3036 is not set
+# CONFIG_PINCTRL_ROCKCHIP_RK3188 is not set
+# CONFIG_PINCTRL_ROCKCHIP_RK3288 is not set
+# CONFIG_PINCTRL_ROCKCHIP_RK3328 is not set
+# CONFIG_PINCTRL_ROCKCHIP_RK3399 is not set
+# CONFIG_PINCTRL_SINGLE is not set
+# CONFIG_PINCTRL_STM32 is not set
+# CONFIG_PINCTRL_EXYNOS7420 is not set
+
+#
+# Power
+#
+
+#
+# Power Domain Support
+#
+# CONFIG_POWER_DOMAIN is not set
+CONFIG_DM_PMIC=y
+CONFIG_PMIC_CHILDREN=y
+CONFIG_SPL_PMIC_CHILDREN=y
+# CONFIG_PMIC_ACT8846 is not set
+# CONFIG_PMIC_AS3722 is not set
+# CONFIG_DM_PMIC_PFUZE100 is not set
+# CONFIG_DM_PMIC_MAX77686 is not set
+# CONFIG_DM_PMIC_MAX8998 is not set
+# CONFIG_PMIC_MAX8997 is not set
+# CONFIG_PMIC_PM8916 is not set
+# CONFIG_PMIC_RK808 is not set
+CONFIG_PMIC_S2MPS11=y
+# CONFIG_DM_PMIC_SANDBOX is not set
+# CONFIG_PMIC_S5M8767 is not set
+# CONFIG_PMIC_RN5T567 is not set
+# CONFIG_PMIC_TPS65090 is not set
+# CONFIG_PMIC_PALMAS is not set
+# CONFIG_PMIC_LP873X is not set
+# CONFIG_POWER_MC34VR500 is not set
+CONFIG_DM_REGULATOR=y
+# CONFIG_SPL_DM_REGULATOR is not set
+# CONFIG_REGULATOR_PWM is not set
+# CONFIG_DM_REGULATOR_FIXED is not set
+# CONFIG_DM_REGULATOR_GPIO is not set
+# CONFIG_DM_PWM is not set
+# CONFIG_PWM_SANDBOX is not set
+# CONFIG_RAM is not set
+
+#
+# Remote Processor drivers
+#
+
+#
+# Reset Controller Support
+#
+# CONFIG_DM_RESET is not set
+
+#
+# Real Time Clock
+#
+# CONFIG_DM_RTC is not set
+
+#
+# Serial drivers
+#
+CONFIG_BAUDRATE=115200
+CONFIG_REQUIRE_SERIAL_CONSOLE=y
+CONFIG_SERIAL_PRESENT=y
+CONFIG_SPL_SERIAL_PRESENT=y
+CONFIG_DM_SERIAL=y
+# CONFIG_SPL_DM_SERIAL is not set
+# CONFIG_TPL_DM_SERIAL is not set
+# CONFIG_DEBUG_UART is not set
+# CONFIG_DEBUG_UART_SKIP_INIT is not set
+# CONFIG_ALTERA_JTAG_UART is not set
+# CONFIG_ALTERA_UART is not set
+# CONFIG_ATMEL_USART is not set
+# CONFIG_FSL_LPUART is not set
+# CONFIG_MVEBU_A3700_UART is not set
+# CONFIG_SYS_NS16550 is not set
+# CONFIG_MSM_SERIAL is not set
+# CONFIG_PXA_SERIAL is not set
+
+#
+# Sound support
+#
+# CONFIG_SOUND is not set
+
+#
+# SPI Support
+#
+CONFIG_DM_SPI=y
+# CONFIG_ALTERA_SPI is not set
+# CONFIG_CADENCE_QSPI is not set
+# CONFIG_DESIGNWARE_SPI is not set
+# CONFIG_EXYNOS_SPI is not set
+# CONFIG_FSL_DSPI is not set
+# CONFIG_ICH_SPI is not set
+# CONFIG_MVEBU_A3700_SPI is not set
+# CONFIG_ROCKCHIP_SPI is not set
+# CONFIG_TEGRA114_SPI is not set
+# CONFIG_TEGRA20_SFLASH is not set
+# CONFIG_TEGRA20_SLINK is not set
+# CONFIG_TEGRA210_QSPI is not set
+# CONFIG_XILINX_SPI is not set
+# CONFIG_OMAP3_SPI is not set
+# CONFIG_FSL_ESPI is not set
+# CONFIG_FSL_QSPI is not set
+# CONFIG_TI_QSPI is not set
+
+#
+# SPMI support
+#
+# CONFIG_SPMI is not set
+
+#
+# System reset device drivers
+#
+# CONFIG_SYSRESET is not set
+# CONFIG_DM_THERMAL is not set
+
+#
+# Timer Support
+#
+# CONFIG_TIMER is not set
+
+#
+# TPM support
+#
+CONFIG_USB=y
+CONFIG_DM_USB=y
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_HOST=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_DWC3=y
+# CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_EHCI is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_UHCI_HCD is not set
+CONFIG_USB_DWC3=y
+# CONFIG_USB_DWC3_HOST is not set
+CONFIG_USB_DWC3_GADGET=y
+
+#
+# Platform Glue Driver Support
+#
+# CONFIG_USB_DWC3_OMAP is not set
+
+#
+# PHY Subsystem
+#
+# CONFIG_USB_DWC3_PHY_OMAP is not set
+CONFIG_USB_DWC3_PHY_SAMSUNG=y
+
+#
+# MUSB Controller Driver
+#
+# CONFIG_USB_MUSB_HOST is not set
+# CONFIG_USB_MUSB_GADGET is not set
+# CONFIG_USB_MUSB_TI is not set
+
+#
+# ULPI drivers
+#
+
+#
+# USB peripherals
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_KEYBOARD is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_BCM_UDC_OTG_PHY is not set
+# CONFIG_USB_GADGET_DWC2_OTG is not set
+# CONFIG_CI_UDC is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_DUALSPEED=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Samsung"
+CONFIG_G_DNL_VENDOR_NUM=0x04e8
+CONFIG_G_DNL_PRODUCT_NUM=0x6601
+CONFIG_USBNET_DEVADDR="de:ad:be:ef:00:01"
+
+#
+# Graphics support
+#
+# CONFIG_DM_VIDEO is not set
+CONFIG_SYS_WHITE_ON_BLACK=y
+
+#
+# TrueType Fonts
+#
+# CONFIG_VIDEO_VESA is not set
+# CONFIG_VIDEO_LCD_ANX9804 is not set
+# CONFIG_VIDEO_LCD_SSD2828 is not set
+# CONFIG_VIDEO_MVEBU is not set
+# CONFIG_I2C_EDID is not set
+# CONFIG_DISPLAY is not set
+# CONFIG_VIDEO_TEGRA20 is not set
+CONFIG_VIDEO_BRIDGE=y
+# CONFIG_VIDEO_BRIDGE_PARADE_PS862X is not set
+# CONFIG_VIDEO_BRIDGE_NXP_PTN3460 is not set
+# CONFIG_LCD is not set
+
+#
+# WATCHDOG support
+#
+# CONFIG_ULP_WATCHDOG is not set
+# CONFIG_PHYS_TO_BUS is not set
+
+#
+# File systems
+#
+# CONFIG_FS_CBFS is not set
+# CONFIG_FS_CRAMFS is not set
+
+#
+# Library routines
+#
+# CONFIG_CC_OPTIMIZE_LIBS_FOR_SPEED is not set
+CONFIG_HAVE_PRIVATE_LIBGCC=y
+CONFIG_USE_PRIVATE_LIBGCC=y
+CONFIG_SYS_HZ=1000
+# CONFIG_USE_TINY_PRINTF is not set
+CONFIG_REGEX=y
+# CONFIG_LIB_RAND is not set
+# CONFIG_SPL_TINY_MEMSET is not set
+# CONFIG_CMD_DHRYSTONE is not set
+
+#
+# Security support
+#
+# CONFIG_AES is not set
+# CONFIG_RSA is not set
+# CONFIG_TPM is not set
+
+#
+# Hashing Support
+#
+# CONFIG_SHA1 is not set
+# CONFIG_SHA256 is not set
+# CONFIG_SHA_HW_ACCEL is not set
+CONFIG_MD5=y
+
+#
+# Compression Support
+#
+# CONFIG_LZ4 is not set
+CONFIG_ERRNO_STR=y
+CONFIG_OF_LIBFDT=y
+# CONFIG_OF_LIBFDT_OVERLAY is not set
+# CONFIG_SPL_OF_LIBFDT is not set
+# CONFIG_FDT_FIXUP_PARTITIONS is not set
+
+#
+# System tables
+#
+CONFIG_GENERATE_SMBIOS_TABLE=y
+CONFIG_SMBIOS_MANUFACTURER="samsung"
+CONFIG_EFI_LOADER=y
+# CONFIG_UNIT_TEST is not set
diff --git a/drivers/mmc/mmc.c b/drivers/mmc/mmc.c
old mode 100644
new mode 100755
index 38d2e07dd5..0d092371c6
--- a/drivers/mmc/mmc.c
+++ b/drivers/mmc/mmc.c
@@ -20,6 +20,10 @@
 #include <memalign.h>
 #include <linux/list.h>
 #include <div64.h>
+#include <asm/gpio.h>
+#include <asm/io.h>
+#include <samsung/misc.h>
+
 #include "mmc_private.h"
 
 static const unsigned int sd_au_size[] = {
@@ -495,7 +499,6 @@ static int mmc_complete_op_cond(struct mmc *mmc)
 	return 0;
 }
 
-
 static int mmc_send_ext_csd(struct mmc *mmc, u8 *ext_csd)
 {
 	struct mmc_cmd cmd;
@@ -517,6 +520,26 @@ static int mmc_send_ext_csd(struct mmc *mmc, u8 *ext_csd)
 	return err;
 }
 
+#if defined(CONFIG_TARGET_ODROID_XU3) || defined(CONFIG_TARGET_ODROID_XU4)
+int mmc_rst_n_func_status(struct mmc *mmc)
+{
+	int err;
+	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, ext_csd, MMC_MAX_BLOCK_LEN);
+
+	err = mmc_send_ext_csd(mmc, ext_csd);
+	if (err) {
+		puts("Could not get ext_csd register values\n");
+		return err;
+	}
+	return	ext_csd[EXT_CSD_RST_N_FUNCTION];
+}
+#else
+int mmc_rst_n_func_status(struct mmc *mmc)
+{
+	return	0;
+}
+#endif
+
 int mmc_switch(struct mmc *mmc, u8 set, u8 index, u8 value)
 {
 	struct mmc_cmd cmd;
@@ -1848,6 +1871,43 @@ int mmc_initialize(bd_t *bis)
 	print_mmc_devices(',');
 #endif
 
+#if defined(CONFIG_TARGET_ODROID_XU3) || defined(CONFIG_TARGET_ODROID_XU4)
+	struct mmc *mmc;
+	int err, dev;
+
+	/* eMMC reset port pull-up/down off for samsung eMMC */
+	if (!gpio_request(EXYNOS5420_GPIO_D10, "reset")) {
+		gpio_set_pull(EXYNOS5420_GPIO_D10, S5P_GPIO_PULL_NONE);
+		gpio_free(EXYNOS5420_GPIO_D10);
+	}
+
+	for (dev = 0; dev < CONFIG_SYS_MMC_MAX_DEVICE; dev++) {
+		mmc = find_mmc_device(dev);
+		if (mmc) {
+			err = mmc_init(mmc);
+		} else {
+			/* Can not find no more channels */
+			break;
+		}
+		if (err)
+			return err;
+		printf("MMC Device %d (%s): ", dev, IS_SD(mmc) ? " SD " : "eMMC");
+		print_size(mmc->capacity, "\n");
+		if (!IS_SD(mmc)) {
+			/* status read */
+			err = mmc_rst_n_func_status(mmc);
+			printf("Info eMMC rst_n_func status = %s\n",
+				err ? "enabled" : "disabled");
+			/*
+			 if h/w rst function disabled
+			 send EXT_CSD_RST_N_FUNCTION command for hardware reset
+			*/
+			if (!err)
+				mmc_set_rst_n_function(mmc, 1);
+		}
+	}
+	printf("\n");
+#endif
 	mmc_do_preinit();
 	return 0;
 }
@@ -1885,3 +1945,49 @@ int mmc_set_bkops_enable(struct mmc *mmc)
 	return 0;
 }
 #endif
+
+#ifdef CONFIG_SUPPORT_EMMC_BOOT
+int emmc_boot_open(struct mmc *mmc)
+{
+	int err;
+	struct mmc_cmd cmd;
+
+	/* Boot ack enable, boot partition enable , boot partition access */
+	cmd.cmdidx = MMC_CMD_SWITCH;
+	cmd.resp_type = MMC_RSP_R1b;
+	cmd.cmdarg = ((3<<24)|(179<<16)|(((1<<6)|(1<<3)|(1<<0))<<8));
+
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+	if (err)
+		return err;
+
+	/* 4bit transfer mode at booting time. */
+	cmd.cmdidx = MMC_CMD_SWITCH;
+	cmd.resp_type = MMC_RSP_R1b;
+	cmd.cmdarg = ((3<<24)|(177<<16)|((1<<0)<<8));
+
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+int emmc_boot_close(struct mmc *mmc)
+{
+	int err;
+	struct mmc_cmd cmd;
+
+	/* Boot ack enable, boot partition enable , boot partition access */
+	cmd.cmdidx = MMC_CMD_SWITCH;
+	cmd.resp_type = MMC_RSP_R1b;
+	cmd.cmdarg = ((3<<24)|(179<<16)|(((1<<6)|(1<<3)|(0<<0))<<8));
+
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+#endif
\ No newline at end of file
diff --git a/drivers/mmc/mmc_boot.c b/drivers/mmc/mmc_boot.c
old mode 100644
new mode 100755
index 6d77ce95e7..ac257b92cc
--- a/drivers/mmc/mmc_boot.c
+++ b/drivers/mmc/mmc_boot.c
@@ -121,8 +121,14 @@ int mmc_set_part_conf(struct mmc *mmc, u8 ack, u8 part_num, u8 access)
  *
  * Returns 0 on success.
  */
+#include <malloc.h>
+#include <memalign.h>
+
 int mmc_set_rst_n_function(struct mmc *mmc, u8 enable)
 {
-	return mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_RST_N_FUNCTION,
-			  enable);
+	if(!mmc_rst_n_func_status(mmc)) {
+		return mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_RST_N_FUNCTION,
+				  enable);
+	}
+	return	0;
 }
diff --git a/drivers/usb/gadget/Makefile b/drivers/usb/gadget/Makefile
old mode 100644
new mode 100755
index 7258099c1c..aba46236ec
--- a/drivers/usb/gadget/Makefile
+++ b/drivers/usb/gadget/Makefile
@@ -44,5 +44,9 @@ obj-y += core.o
 obj-y += ep0.o
 obj-$(CONFIG_DW_UDC) += designware_udc.o
 obj-$(CONFIG_CPU_PXA27X) += pxa27x_udc.o
+else
+ifdef CONFIG_TARGET_ODROID_XU4
+obj-y += usbd3-ss.o
+endif
 endif
 endif
diff --git a/drivers/usb/gadget/fastboot-ss.c b/drivers/usb/gadget/fastboot-ss.c
new file mode 100755
index 0000000000..55229ea713
--- /dev/null
+++ b/drivers/usb/gadget/fastboot-ss.c
@@ -0,0 +1,507 @@
+/*
+ * Copyright (c) 2010 Samsung Electronics Co., Ltd.
+ *              http://www.samsung.com/
+ *
+ * Platform dependant code for Fastboot
+ *
+ * Base code of USB connection part is usbd-ss.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <fastboot.h>
+
+#if defined(CONFIG_FASTBOOT)
+
+#define FBOOT_USBD_IS_CONNECTED() (1)
+#define FBOOT_USBD_DETECT_IRQ() EXYNOS_USBD_DETECT_IRQ()
+#define FBOOT_USBD_CLEAR_IRQ()  EXYNOS_USBD_CLEAR_IRQ()
+#define VENDOR_ID 	0x18D1
+#define PRODUCT_ID	0x0002
+#define FB_PKT_SZ	64 // full-speed mode
+#define OK	0
+#define ERROR	-1
+
+/* In high speed mode packets are 512
+   In full speed mode packets are 64 */
+#define RX_ENDPOINT_MAXIMUM_PACKET_SIZE_2_0  (0x0200)//512
+#define RX_ENDPOINT_MAXIMUM_PACKET_SIZE_1_1  (0x0040)// 64
+#define TX_ENDPOINT_MAXIMUM_PACKET_SIZE_2_0  (0x0200)
+#define TX_ENDPOINT_MAXIMUM_PACKET_SIZE_1_1  (0x0040)
+
+/* String 0 is the language id */
+#define DEVICE_STRING_MANUFACTURER_INDEX  1
+#define DEVICE_STRING_PRODUCT_INDEX       2
+#define DEVICE_STRING_SERIAL_NUMBER_INDEX 3
+#define DEVICE_STRING_CONFIG_INDEX        4
+#define DEVICE_STRING_INTERFACE_INDEX     5
+#define DEVICE_STRING_MAX_INDEX           DEVICE_STRING_INTERFACE_INDEX
+#define DEVICE_STRING_LANGUAGE_ID         0x0409 /* English (United States) */
+
+//static char *device_strings[DEVICE_STRING_MANUFACTURER_INDEX+1];
+static char *device_strings[DEVICE_STRING_MAX_INDEX+1];
+static struct cmd_fastboot_interface *fastboot_interface = NULL;
+/* The packet size is dependend of the speed mode
+   In high speed mode packets are 512
+   In full speed mode packets are 64
+   Set to maximum of 512 */
+
+/* Note: The start address must be double word aligned */
+char* reply_msg;
+unsigned int transfer_size;
+u32 fboot_response_flag=0;
+
+/* codes representing languages */
+const u8 fboot_string_desc1[] = /* Manufacturer */
+{
+	(0x16+2), STRING_DESCRIPTOR,
+	'G', 0x0, 'o', 0x0, 'o', 0x0, 'g', 0x0, 'l', 0x0,
+	'e', 0x0, ',', 0x0, ' ', 0x0, 'I', 0x0, 'n', 0x0,
+	'c', 0x0
+};
+
+const u8 fboot_string_desc2[] = /* Product */
+{
+	(0x16+2), STRING_DESCRIPTOR,
+	'A', 0x0, 'n', 0x0, 'd', 0x0, 'r', 0x0, 'o', 0x0,
+	'i', 0x0, 'd', 0x0, ' ', 0x0, '1', 0x0, '.', 0x0,
+	'0', 0x0
+};
+
+const u8 fboot_string_desc3[] = /* Test Serial ID */
+{
+	(0x16+2), STRING_DESCRIPTOR,
+	'S', 0x0, 'M', 0x0, 'D', 0x0, 'K', 0x0,
+	'E', 0x0,'X', 0x0, 'Y', 0x0, 'N', 0x0, 'O', 0x0, 'S', 0x0, '-', 0x0, '0', 0x0, '1', 0x0
+};
+
+/* setting the device qualifier descriptor and a string descriptor */
+const u8 fboot_qualifier_desc[] =
+{
+	0x0a,	/*  0 desc size */
+	0x06,	/*  1 desc type (DEVICE_QUALIFIER)*/
+	0x00,	/*  2 USB release */
+	0x02,	/*  3 => 2.00*/
+	0xFF,	/*  4 class */
+	0x42,	/*  5 subclass */
+	0x03,	/*  6 protocol */
+	64,	/*  7 max pack size */
+	0x01,	/*  8 number of other-speed configuration */
+	0x00,	/*  9 reserved */
+};
+
+volatile usbdev3_trb_ptr_t g_pBulkInTrb;
+
+/* extern function from usbd3-ss.c */
+void exynos_usb_phy_on(void);
+int exynos_usb_wait_cable_insert(void);
+
+void fboot_usbctl_init(void)
+{
+	exynos_usb_phy_on();
+}
+
+int fboot_usb_int_bulkin(const char *buffer, unsigned int buffer_size)
+{
+	usbdev3_trb_ctrl_t usbdev3_trb_ctrl;
+	usbdev3_trb_ptr_t pBulkInTrb;
+	u32 usCapTrbBufSiz, uLastBufSize;
+	u32 i;
+
+	// Set TRB for multiple Bulk IN Packet
+	usCapTrbBufSiz = TRB_BUF_SIZ_LIMIT/oUsbDev3.m_uBulkEPMaxPktSize*oUsbDev3.m_uBulkEPMaxPktSize;
+	g_uCntOfBulkInTrb = buffer_size/usCapTrbBufSiz;
+
+	if ((buffer_size%usCapTrbBufSiz) != 0)
+		g_uCntOfBulkInTrb++;
+
+	g_pBulkInTrb = (usbdev3_trb_ptr_t)exynos_usb_malloc(g_uCntOfBulkInTrb*sizeof(usbdev3_trb_t), USBDEV3_MDWIDTH/8);
+
+	if (g_pBulkInTrb == NULL)
+		Assert(0);
+
+	pBulkInTrb = g_pBulkInTrb;
+	// Fill the Trbs
+	usbdev3_trb_ctrl.data = 0;
+	usbdev3_trb_ctrl.b.lst = 0;
+	usbdev3_trb_ctrl.b.chn = 1;
+	usbdev3_trb_ctrl.b.csp = 0;
+	usbdev3_trb_ctrl.b.trb_ctrl = (u32)TRB_CTRL_NORMAL;
+	usbdev3_trb_ctrl.b.isp_imi = 1;
+	usbdev3_trb_ctrl.b.ioc = 0;
+	usbdev3_trb_ctrl.b.strmid_sofn = 0;
+
+	for(i=0;i<(g_uCntOfBulkInTrb-1);i++, pBulkInTrb++)
+		exynos_usb_fill_trb(pBulkInTrb, (u32)(buffer+usCapTrbBufSiz*i), usCapTrbBufSiz, usbdev3_trb_ctrl.data, 1);
+
+	usbdev3_trb_ctrl.b.lst = 1;
+	usbdev3_trb_ctrl.b.chn = 0;
+	usbdev3_trb_ctrl.b.ioc = 1;
+	uLastBufSize = buffer_size-usCapTrbBufSiz*i;
+	exynos_usb_fill_trb(pBulkInTrb, (u32)(buffer+usCapTrbBufSiz*i), uLastBufSize, usbdev3_trb_ctrl.data, 1);
+
+	// . Issue Start Xfer for multiple Bulk IN Packet
+	//------------------------------------
+	if (!exynos_usb_start_ep_xfer(USBDEV3_EP_DIR_IN, BULK_IN_EP, (u32)g_pBulkInTrb, 0, &oUsbDev3.m_uTriIn[BULK_IN_EP]))
+	{
+		return 0;
+	}
+
+	return 1;
+}
+
+void fboot_usb_handle_ep_in_xfer_complete(void)
+{
+	if (fboot_response_flag) {
+		exynos_usb_free((u32)g_pBulkInTrb);
+		fboot_response_flag=0;
+	}
+
+	return;
+}
+
+int fboot_usb_handle_ep_out_xfer_complete(void)
+{
+	u32 usRxCnt;
+	usbdev3_trb_ctrl_t usbdev3_trb_ctrl;
+
+	// Check whether TRB was finished successfully or not
+	if ((g_pBulkOutTrb0->control.b.hwo != 0)||(g_pBulkOutTrb0->status.b.trb_sts != 0))
+	{
+		Assert(0);
+	}
+
+	usRxCnt = oUsbDev3.m_uBulkEPMaxPktSize - g_pBulkOutTrb0->status.b.buf_siz;
+
+	if (usRxCnt < oUsbDev3.m_uBulkEPMaxPktSize)
+		g_ucTempDownBuf[usRxCnt] = 0;
+
+	/* Pass this up to the interface's handler */
+	if (fastboot_interface && fastboot_interface->rx_handler) {
+		/* Call rx_handler at common/cmd_fastboot.c */
+		if (!fastboot_interface->rx_handler(g_ucTempDownBuf, usRxCnt))
+			;//OK
+	}
+
+	// . Set TRB for 1st Bulk Out Packet
+	//-----------------------------
+	usbdev3_trb_ctrl.data = 0;
+	usbdev3_trb_ctrl.b.lst = 1;
+	usbdev3_trb_ctrl.b.trb_ctrl = (u32)TRB_CTRL_NORMAL;
+	usbdev3_trb_ctrl.b.isp_imi = 1;
+	usbdev3_trb_ctrl.b.ioc = 1;
+	usbdev3_trb_ctrl.b.strmid_sofn = 0;
+
+	exynos_usb_fill_trb(g_pBulkOutTrb0, (u32)g_ucTempDownBuf, oUsbDev3.m_uBulkEPMaxPktSize, usbdev3_trb_ctrl.data, 1);
+
+	// . Issue Start Xfer for 1st Bulk Out Packet
+	//------------------------------------
+	if (!exynos_usb_start_ep_xfer(USBDEV3_EP_DIR_OUT, BULK_OUT_EP, (u32)g_pBulkOutTrb0, 0, &oUsbDev3.m_uTriOut[BULK_OUT_EP]))
+	{
+		return 0;
+	}
+
+	return 1;
+}
+
+void fboot_usb_set_descriptors_tlb(void)
+{
+	/* Standard device descriptor */
+	oUsbDev3.m_oDesc.oDescDevice.bLength=DEVICE_DESC_SIZE;	/*0x12*/
+	oUsbDev3.m_oDesc.oDescDevice.bDescriptorType=DEVICE_DESCRIPTOR;
+	if (oUsbDev3.m_eSpeed == USBDEV3_SPEED_SUPER) {
+		oUsbDev3.m_oDesc.oDescDevice.bMaxPacketSize0=SUPER_SPEED_CONTROL_PKT_EXP_SZ;
+	} else {
+		oUsbDev3.m_oDesc.oDescDevice.bMaxPacketSize0=oUsbDev3.m_uControlEPMaxPktSize;
+	}
+	oUsbDev3.m_oDesc.oDescDevice.bDeviceClass=0x0; /* 0x0*/
+	oUsbDev3.m_oDesc.oDescDevice.bDeviceSubClass=0x0;
+	oUsbDev3.m_oDesc.oDescDevice.bDeviceProtocol=0x0;
+	oUsbDev3.m_oDesc.oDescDevice.idVendorL=VENDOR_ID&0xff;//0xB4;	/**/
+	oUsbDev3.m_oDesc.oDescDevice.idVendorH=VENDOR_ID>>8;//0x0B;	/**/
+	oUsbDev3.m_oDesc.oDescDevice.idProductL=PRODUCT_ID&0xff;//0xFF; /**/
+	oUsbDev3.m_oDesc.oDescDevice.idProductH=PRODUCT_ID>>8;//0x0F; /**/
+	oUsbDev3.m_oDesc.oDescDevice.bcdDeviceL=0x00;
+	oUsbDev3.m_oDesc.oDescDevice.bcdDeviceH=0x01;
+	oUsbDev3.m_oDesc.oDescDevice.iManufacturer=DEVICE_STRING_MANUFACTURER_INDEX; /* index of string descriptor */
+	oUsbDev3.m_oDesc.oDescDevice.iProduct=DEVICE_STRING_PRODUCT_INDEX;	/* index of string descriptor */
+	oUsbDev3.m_oDesc.oDescDevice.iSerialNumber=DEVICE_STRING_SERIAL_NUMBER_INDEX;
+	oUsbDev3.m_oDesc.oDescDevice.bNumConfigurations=0x1;
+	if (oUsbDev3.m_eSpeed == USBDEV3_SPEED_SUPER) {
+		oUsbDev3.m_oDesc.oDescDevice.bcdUSBL=0x00;
+		oUsbDev3.m_oDesc.oDescDevice.bcdUSBH=0x03; 	// Ver 3.0
+	} else if (oUsbDev3.m_eSpeed == USBDEV3_SPEED_HIGH) {
+		oUsbDev3.m_oDesc.oDescDevice.bcdUSBL=0x00;
+		oUsbDev3.m_oDesc.oDescDevice.bcdUSBH=0x02; 	// Ver 2.0
+	} else if (oUsbDev3.m_eSpeed == USBDEV3_SPEED_FULL) {
+		oUsbDev3.m_oDesc.oDescDevice.bcdUSBL=0x10;
+		oUsbDev3.m_oDesc.oDescDevice.bcdUSBH=0x01; 	// Ver 2.0
+	}
+
+	/* Standard configuration descriptor */
+	oUsbDev3.m_oDesc.oDescConfig.bLength=CONFIG_DESC_SIZE; /* 0x9 bytes */
+	oUsbDev3.m_oDesc.oDescConfig.bDescriptorType=CONFIGURATION_DESCRIPTOR;
+	if (oUsbDev3.m_eSpeed == USBDEV3_SPEED_SUPER)
+		oUsbDev3.m_oDesc.oDescConfig.wTotalLengthL=CONFIG_SS_DESC_TOTAL_SIZE;
+	else
+		oUsbDev3.m_oDesc.oDescConfig.wTotalLengthL=CONFIG_DESC_TOTAL_SIZE;
+	oUsbDev3.m_oDesc.oDescConfig.wTotalLengthH=0;
+	oUsbDev3.m_oDesc.oDescConfig.bNumInterfaces=1;
+	/* dbg	  descConf.bConfigurationValue=2; // why 2? There's no reason.*/
+	oUsbDev3.m_oDesc.oDescConfig.bConfigurationValue=1;
+	oUsbDev3.m_oDesc.oDescConfig.iConfiguration=0;
+	oUsbDev3.m_oDesc.oDescConfig.bmAttributes=CONF_ATTR_DEFAULT|CONF_ATTR_SELFPOWERED; /* bus powered only.*/
+	oUsbDev3.m_oDesc.oDescConfig.maxPower=25; /* draws 50mA current from the USB bus.*/
+
+	/* Standard interface descriptor */
+	oUsbDev3.m_oDesc.oDescInterface.bLength=INTERFACE_DESC_SIZE; /* 9*/
+	oUsbDev3.m_oDesc.oDescInterface.bDescriptorType=INTERFACE_DESCRIPTOR;
+	oUsbDev3.m_oDesc.oDescInterface.bInterfaceNumber=0x0;
+	oUsbDev3.m_oDesc.oDescInterface.bAlternateSetting=0x0; /* ?*/
+	oUsbDev3.m_oDesc.oDescInterface.bNumEndpoints = 2;	/* # of endpoints except EP0*/
+	oUsbDev3.m_oDesc.oDescInterface.bInterfaceClass=	FASTBOOT_INTERFACE_CLASS;// 0xff; /* 0x0 ?*/
+	oUsbDev3.m_oDesc.oDescInterface.bInterfaceSubClass=	FASTBOOT_INTERFACE_SUB_CLASS;// 0x42;
+	oUsbDev3.m_oDesc.oDescInterface.bInterfaceProtocol=	FASTBOOT_INTERFACE_PROTOCOL;//0x03;
+	oUsbDev3.m_oDesc.oDescInterface.iInterface=0x0;
+
+	if (oUsbDev3.m_eSpeed == USBDEV3_SPEED_SUPER) {
+		/* Standard endpoint0 descriptor */
+		oUsbDev3.m_oSSDesc.oDescEp0.bLength=ENDPOINT_DESC_SIZE;
+		oUsbDev3.m_oSSDesc.oDescEp0.bDescriptorType=ENDPOINT_DESCRIPTOR;
+		oUsbDev3.m_oSSDesc.oDescEp0.bEndpointAddress=BULK_IN_EP|EP_ADDR_IN;
+		oUsbDev3.m_oSSDesc.oDescEp0.bmAttributes=EP_ATTR_BULK;
+		oUsbDev3.m_oSSDesc.oDescEp0.wMaxPacketSizeL=(u8)oUsbDev3.m_uBulkEPMaxPktSize; /* 64*/
+		oUsbDev3.m_oSSDesc.oDescEp0.wMaxPacketSizeH=(u8)(oUsbDev3.m_uBulkEPMaxPktSize>>8);
+		oUsbDev3.m_oSSDesc.oDescEp0.bInterval=0x0; /* not used */
+
+		oUsbDev3.m_oSSDesc.oDescEp0Comp.bLength=6;
+		oUsbDev3.m_oSSDesc.oDescEp0Comp.bDescriptorType=0x30;
+		oUsbDev3.m_oSSDesc.oDescEp0Comp.bMaxBurst=15;
+		oUsbDev3.m_oSSDesc.oDescEp0Comp.bmAttributes=0;
+		oUsbDev3.m_oSSDesc.oDescEp0Comp.wBytesPerInterval=0;
+
+		/* Standard endpoint1 descriptor */
+		oUsbDev3.m_oSSDesc.oDescEp1.bLength=ENDPOINT_DESC_SIZE;
+		oUsbDev3.m_oSSDesc.oDescEp1.bDescriptorType=ENDPOINT_DESCRIPTOR;
+		oUsbDev3.m_oSSDesc.oDescEp1.bEndpointAddress=BULK_OUT_EP|EP_ADDR_OUT;
+		oUsbDev3.m_oSSDesc.oDescEp1.bmAttributes=EP_ATTR_BULK;
+		oUsbDev3.m_oSSDesc.oDescEp1.wMaxPacketSizeL=(u8)oUsbDev3.m_uBulkEPMaxPktSize; /* 64*/
+		oUsbDev3.m_oSSDesc.oDescEp1.wMaxPacketSizeH=(u8)(oUsbDev3.m_uBulkEPMaxPktSize>>8);
+		oUsbDev3.m_oSSDesc.oDescEp1.bInterval=0x0; /* not used */
+
+		oUsbDev3.m_oSSDesc.oDescEp1Comp.bLength=6;
+		oUsbDev3.m_oSSDesc.oDescEp1Comp.bDescriptorType=0x30;
+		oUsbDev3.m_oSSDesc.oDescEp1Comp.bMaxBurst=15;
+		oUsbDev3.m_oSSDesc.oDescEp1Comp.bmAttributes=0;
+		oUsbDev3.m_oSSDesc.oDescEp1Comp.wBytesPerInterval=0;
+
+		// Standard BOS(Binary Object Store) descriptor
+		oUsbDev3.m_oSSDesc.oDescBos.bLength = BOS_DESC_SIZE;
+		oUsbDev3.m_oSSDesc.oDescBos.bDescriptorType = 0x0F;
+		oUsbDev3.m_oSSDesc.oDescBos.wTotalLength = BOS_DESC_TOTAL_SIZE;
+		oUsbDev3.m_oSSDesc.oDescBos.bNumDeviceCaps = 3;
+
+		oUsbDev3.m_oSSDesc.oDescUsb20Ext.bLength = USB20_EXT_CAP_DESC_SIZE;
+		oUsbDev3.m_oSSDesc.oDescUsb20Ext.bDescriptorType = 0x10;
+		oUsbDev3.m_oSSDesc.oDescUsb20Ext.bDevCapabilityType = USB_CAP_20_EXT;
+		oUsbDev3.m_oSSDesc.oDescUsb20Ext.bmAttributes = 0x2;
+
+		oUsbDev3.m_oSSDesc.oDescSuperCap.bLength = SUPER_CAP_DESC_SIZE;
+		oUsbDev3.m_oSSDesc.oDescSuperCap.bDescriptorType = 0x10;
+		oUsbDev3.m_oSSDesc.oDescSuperCap.bDevCapabilityType = USB_CAP_SS;
+		oUsbDev3.m_oSSDesc.oDescSuperCap.bmAttributes = 0x0;
+		oUsbDev3.m_oSSDesc.oDescSuperCap.wSpeedsSupported = 0xC;
+		oUsbDev3.m_oSSDesc.oDescSuperCap.bFunctionalitySupport = 2;
+		/* TODO: set correct value */
+		oUsbDev3.m_oSSDesc.oDescSuperCap.bU1DevExitLat = 0x4;
+		oUsbDev3.m_oSSDesc.oDescSuperCap.wU2DevExitLat = 0x4;
+
+		oUsbDev3.m_oSSDesc.oDescContainCap.bLength = CONTAIN_CAP_DESC_SIZE;
+		oUsbDev3.m_oSSDesc.oDescContainCap.bDescriptorType = 0x10;
+		oUsbDev3.m_oSSDesc.oDescContainCap.bDevCapabilityType = USB_CAP_CID;
+		oUsbDev3.m_oSSDesc.oDescContainCap.bReserved = 0x0;
+		memset(oUsbDev3.m_oSSDesc.oDescContainCap.containerID, 0x0, 16);
+	}
+	else {
+		/* Standard endpoint0 descriptor */
+		oUsbDev3.m_oDesc.oDescEp0.bLength=ENDPOINT_DESC_SIZE;
+		oUsbDev3.m_oDesc.oDescEp0.bDescriptorType=ENDPOINT_DESCRIPTOR;
+		oUsbDev3.m_oDesc.oDescEp0.bEndpointAddress=BULK_IN_EP|EP_ADDR_IN;
+		oUsbDev3.m_oDesc.oDescEp0.bmAttributes=EP_ATTR_BULK;
+		oUsbDev3.m_oDesc.oDescEp0.wMaxPacketSizeL=(u8)oUsbDev3.m_uBulkEPMaxPktSize; /* 64*/
+		oUsbDev3.m_oDesc.oDescEp0.wMaxPacketSizeH=(u8)(oUsbDev3.m_uBulkEPMaxPktSize>>8);
+		oUsbDev3.m_oDesc.oDescEp0.bInterval=0x0; /* not used */
+
+		/* Standard endpoint1 descriptor */
+		oUsbDev3.m_oDesc.oDescEp1.bLength=ENDPOINT_DESC_SIZE;
+		oUsbDev3.m_oDesc.oDescEp1.bDescriptorType=ENDPOINT_DESCRIPTOR;
+		oUsbDev3.m_oDesc.oDescEp1.bEndpointAddress=BULK_OUT_EP|EP_ADDR_OUT;
+		oUsbDev3.m_oDesc.oDescEp1.bmAttributes=EP_ATTR_BULK;
+		oUsbDev3.m_oDesc.oDescEp1.wMaxPacketSizeL=(u8)oUsbDev3.m_uBulkEPMaxPktSize; /* 64*/
+		oUsbDev3.m_oDesc.oDescEp1.wMaxPacketSizeH=(u8)(oUsbDev3.m_uBulkEPMaxPktSize>>8);
+		oUsbDev3.m_oDesc.oDescEp1.bInterval=0x0; /* not used */
+	}
+}
+
+int  fboot_usb_int_hndlr(void)
+{
+	return exynos_udc_int_hndlr();
+}
+
+//-----------------------------------------------------------------------------------
+// FASTBOOT codes
+//-----------------------------------------------------------------------------------
+
+static void set_serial_number(void)
+{
+	char *dieid = env_get("dieid#");
+	if (dieid == NULL) {
+		device_strings[DEVICE_STRING_SERIAL_NUMBER_INDEX] = "SLSI0123";
+	} else {
+		static char serial_number[32];
+		int len;
+
+		memset(&serial_number[0], 0, 32);
+		len = strlen(dieid);
+		if (len > 30)
+			len = 30;
+
+		strncpy(&serial_number[0], dieid, len);
+
+		device_strings[DEVICE_STRING_SERIAL_NUMBER_INDEX] =
+			&serial_number[0];
+	}
+}
+
+/* Initizes the board specific fastboot
+   Returns 0 on success
+   Returns 1 on failure */
+int fastboot_init(struct cmd_fastboot_interface *interface)
+{
+	int ret = 1;
+
+	// usbd init
+	fboot_usbctl_init();
+
+	device_strings[DEVICE_STRING_MANUFACTURER_INDEX]  = "Samsung S.LSI";
+	device_strings[DEVICE_STRING_PRODUCT_INDEX]       = "smdk";
+	set_serial_number();
+	/* These are just made up */
+	device_strings[DEVICE_STRING_CONFIG_INDEX]        = "Android Fastboot";
+	device_strings[DEVICE_STRING_INTERFACE_INDEX]     = "Android Fastboot";
+
+	/* The interface structure */
+	fastboot_interface = interface;
+	fastboot_interface->product_name                  = device_strings[DEVICE_STRING_PRODUCT_INDEX];
+	fastboot_interface->serial_no                     = device_strings[DEVICE_STRING_SERIAL_NUMBER_INDEX];
+	fastboot_interface->nand_block_size               = CFG_FASTBOOT_PAGESIZE * 64;
+	fastboot_interface->transfer_buffer               = (unsigned char *) CFG_FASTBOOT_TRANSFER_BUFFER;
+	fastboot_interface->transfer_buffer_size          = CFG_FASTBOOT_TRANSFER_BUFFER_SIZE;
+
+	memset((unsigned char *) CFG_FASTBOOT_TRANSFER_BUFFER, 0x0, FASTBOOT_REBOOT_MAGIC_SIZE);
+
+	reply_msg = (char *)exynos_usb_malloc(512, USBDEV3_MDWIDTH/8);
+
+	ret = 0;	// This is a fake return value, because we do not initialize USB yet!
+
+	return ret;
+}
+
+/* Cleans up the board specific fastboot */
+void fastboot_shutdown(void)
+{
+	/* when operation is done, usbd must be stopped */
+	exynos_usb_stop();
+	is_fastboot = 0;
+}
+
+int fastboot_fifo_size(void)
+{
+	return (oUsbDev3.m_eSpeed == USBDEV3_SPEED_HIGH) ? RX_ENDPOINT_MAXIMUM_PACKET_SIZE_2_0 : RX_ENDPOINT_MAXIMUM_PACKET_SIZE_1_1;
+}
+
+/*
+ * Handles board specific usb protocol exchanges
+ * Returns 0 on success
+ * Returns 1 on disconnects, break out of loop
+ * Returns 2 if no USB activity detected
+ * Returns -1 on failure, unhandled usb requests and other error conditions
+*/
+int fastboot_poll(void)
+{
+	//printf("DEBUG: %s is called.\n", __FUNCTION__);
+	/* No activity */
+	int ret = FASTBOOT_INACTIVE;
+
+	if (!exynos_usb_wait_cable_insert() && !is_fastboot) {
+		exynos_usbctl_init();
+		exynos_usbc_activate();
+		is_fastboot = 1;
+	}
+
+	/* A disconnect happended, this signals that the cable
+	   has been disconnected, return immediately */
+	if (!FBOOT_USBD_IS_CONNECTED()) {
+		return FASTBOOT_DISCONNECT;
+	} else if (FBOOT_USBD_DETECT_IRQ()) {
+		if (!fboot_usb_int_hndlr())
+			ret = FASTBOOT_OK;
+		else
+			ret = FASTBOOT_ERROR;
+		FBOOT_USBD_CLEAR_IRQ();
+	}
+
+	return ret;
+}
+
+
+/* Send a status reply to the client app
+   buffer does not have to be null terminated.
+   buffer_size must be not be larger than what is returned by
+   fastboot_fifo_size
+   Returns 0 on success
+   Returns 1 on failure */
+int fastboot_tx_status(const char *buffer, unsigned int buffer_size, const u32 need_sync_flag)
+{
+	/* fastboot client only reads back at most 64 */
+	transfer_size = 64 < buffer_size ? 64 : buffer_size;
+
+	if (fboot_response_flag)
+		printf(" Response tx Warnning\n");
+
+	memcpy(reply_msg, buffer, transfer_size);
+	fboot_response_flag=1;
+	fboot_usb_int_bulkin(reply_msg, transfer_size);
+
+	if (need_sync_flag)
+	{
+		while(fboot_response_flag)
+			fastboot_poll();
+	}
+	return 1;
+}
+
+/* Returns 0 on success
+   Returns 1 on failure */
+int fastboot_tx_mem(const char *buffer, unsigned int buffer_size)
+{
+	if (!fboot_usb_int_bulkin(buffer, buffer_size))
+		return 0;
+	return 1;
+}
+
+/* A board specific variable handler.
+   The size of the buffers is governed by the fastboot spec.
+   rx_buffer is at most 57 bytes
+   tx_buffer is at most 60 bytes
+   Returns 0 on success
+   Returns 1 on failure */
+int fastboot_getvar(const char *rx_buffer, char *tx_buffer)
+{
+	/* Place board specific variables here */
+	return 1;
+}
+
+#endif /* CONFIG_FASTBOOT */
diff --git a/drivers/usb/gadget/usbd3-ss.c b/drivers/usb/gadget/usbd3-ss.c
new file mode 100755
index 0000000000..9c971e60c4
--- /dev/null
+++ b/drivers/usb/gadget/usbd3-ss.c
@@ -0,0 +1,2557 @@
+/*
+ * drivers/usb/gadget/usbd3-ss.c
+ *
+ * (C) Copyright 2011
+ * Yulgon Kim, Samsung Erectronics, yulgon.kim@samsung.com.
+ *	- only support for EXYNOS5210
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <malloc.h>
+
+#if defined(CONFIG_ARCH_EXYNOS5)
+#include <command.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/clk.h>
+#include "usbd3-ss.h"
+
+#undef USBD3_DBG
+#ifdef USBD3_DBG
+#define DBG_USBD3(fmt, args...)	DBG_USBD3("[%s:%d] " fmt, __FUNCTION__, __LINE__, ##args)
+#else
+#define DBG_USBD3(fmt, args...) do { } while (0)
+#endif
+
+#define Assert(value) value ? : printf("[%s:%d] Assert(%d) \n", __func__, __LINE__, value)
+
+#define USBDEVICE3_LINK_BASE		(oUsbDev3.m_uLinkBaseRegs)
+#define USBDEVICE3_PHYCTRL_BASE		(oUsbDev3.m_uPhyBaseRegs)
+
+/* codes representing languages */
+const u8 string_desc0[] =
+{
+	4, STRING_DESCRIPTOR, LANGID_US_L, LANGID_US_H,
+};
+
+const u8 dnw_string_desc1[] = /* Manufacturer */
+{
+	(0x14+2), STRING_DESCRIPTOR,
+	'S', 0x0, 'y', 0x0, 's', 0x0, 't', 0x0, 'e', 0x0,
+	'm', 0x0, ' ', 0x0, 'M', 0x0, 'C', 0x0, 'U', 0x0,
+};
+
+const u8 dnw_string_desc2[] = /* Product */
+{
+	(0x2a+2), STRING_DESCRIPTOR,
+	'S', 0x0, 'E', 0x0, 'C', 0x0, ' ', 0x0, 'S', 0x0,
+	'3', 0x0, 'C', 0x0, '6', 0x0, '4', 0x0, '0', 0x0,
+	'0', 0x0, 'X', 0x0, ' ', 0x0, 'T', 0x0, 'e', 0x0,
+	's', 0x0, 't', 0x0, ' ', 0x0, 'B', 0x0, '/', 0x0,
+	'D', 0x0
+};
+
+/* setting the device qualifier descriptor and a string descriptor */
+const u8 qualifier_desc[] =
+{
+	0x0a,	/*  0 desc size */
+	0x06,	/*  1 desc type (DEVICE_QUALIFIER)*/
+	0x00,	/*  2 USB release */
+	0x02,	/*  3 => 2.00*/
+	0xFF,	/*  4 class */
+	0x00,	/*  5 subclass */
+	0x00,	/*  6 protocol */
+	64,	/*  7 max pack size */
+	0x01,	/*  8 number of other-speed configuration */
+	0x00,	/*  9 reserved */
+};
+
+const u8 config_full[] =
+{
+	0x09,	/*  0 desc size */
+	0x07,	/*  1 desc type (other speed)*/
+	0x20,	/*  2 Total length of data returned */
+	0x00,	/*  3 */
+	0x01,	/*  4 Number of interfaces supported by this speed configuration */
+	0x01,	/*  5 value to use to select configuration */
+	0x00,	/*  6 index of string desc */
+		/*  7 same as configuration desc */
+	CONF_ATTR_DEFAULT|CONF_ATTR_SELFPOWERED,
+	0x19,	/*  8 same as configuration desc */
+
+};
+
+const u8 config_full_total[] =
+{
+  0x09, 0x07 ,0x20 ,0x00 ,0x01 ,0x01 ,0x00 ,0xC0 ,0x19,
+  0x09 ,0x04 ,0x00 ,0x00 ,0x02 ,0xff ,0x00 ,0x00 ,0x00,
+  0x07 ,0x05 ,0x83 ,0x02 ,0x40 ,0x00 ,0x00,
+  0x07 ,0x05 ,0x04 ,0x02 ,0x40 ,0x00 ,0x00
+};
+
+const u8 config_high[] =
+{
+	0x09,	/*  0 desc size */
+	0x07,	/*  1 desc type (other speed)*/
+	0x20,	/*  2 Total length of data returned */
+	0x00,	/*  3 */
+	0x01,	/*  4 Number of interfaces supported by this speed configuration */
+	0x01,	/*  5 value to use to select configuration */
+	0x00,	/*  6 index of string desc */
+		/*  7 same as configuration desc */
+	CONF_ATTR_DEFAULT|CONF_ATTR_SELFPOWERED,
+	0x19,	/*  8 same as configuration desc */
+
+};
+
+const u8 config_high_total[] =
+{
+  0x09, 0x07 ,0x20 ,0x00 ,0x01 ,0x01 ,0x00 ,0xC0 ,0x19,
+  0x09 ,0x04 ,0x00 ,0x00 ,0x02 ,0xff ,0x00 ,0x00 ,0x00,
+  0x07 ,0x05 ,0x81 ,0x02 ,0x00 ,0x02 ,0x00,
+  0x07 ,0x05 ,0x02 ,0x02 ,0x00 ,0x02 ,0x00
+};
+
+const u8 set_sel[6];
+
+/*32 <cfg desc>+<if desc>+<endp0 desc>+<endp1 desc>*/
+#define CONFIG_DESC_TOTAL_SIZE	\
+	(CONFIG_DESC_SIZE+INTERFACE_DESC_SIZE+ENDPOINT_DESC_SIZE*2)
+#define CONFIG_SS_DESC_TOTAL_SIZE	\
+	(CONFIG_DESC_SIZE+INTERFACE_DESC_SIZE+ENDPOINT_DESC_SIZE*2+ENDPOINT_COMP_DESC_SIZE*2)
+#define BOS_DESC_TOTAL_SIZE	\
+	(BOS_DESC_SIZE+USB20_EXT_CAP_DESC_SIZE+SUPER_CAP_DESC_SIZE+CONTAIN_CAP_DESC_SIZE)
+#define TEST_PKT_SIZE 53
+
+#define USB_CAP_20_EXT  0x2
+#define USB_CAP_SS      0x3
+#define USB_CAP_CID     0x4
+
+#define USB_PHY_REF_CLK (EXTREF_24MHz)
+
+#define CONFIG_PHY_CRPORT
+
+u8 test_pkt [TEST_PKT_SIZE] = {
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/*JKJKJKJK x 9*/
+	0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,	/*JJKKJJKK x 8*/
+	0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,	/*JJJJKKKK x 8*/
+	0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,	/*JJJJJJJKKKKKKK x8 - '1'*/
+	0x7F,0xBF,0xDF,0xEF,0xF7,0xFB,0xFD,		/*'1' + JJJJJJJK x 8*/
+	0xFC,0x7E,0xBF,0xDF,0xEF,0xF7,0xFB,0xFD,0x7E	/*{JKKKKKKK x 10},JK*/
+};
+
+//=====================================================================
+// global varibles used in several functions
+USBDEV3 oUsbDev3;
+USB_GET_STATUS oStatusGet;
+USB_INTERFACE_GET oInterfaceGet;
+
+u16 g_usConfig;
+u16 g_usUploadPktLength=0;
+u8 g_bTransferEp0 = 0;
+
+u8 g_bSuspendResumeDBG_USBD3;
+
+u8 g_bUsingUsbDownAddr = 0;
+u32 g_uUsbDownAddr = 0;
+
+u32 *g_uUsbDevCtrlInBufferPtr=NULL;
+u32 *g_uUsbDevCtrlOutBufferPtr=NULL;
+u32 *g_uUsbDevBulkOutTmpBufferPtr=NULL;
+u32 *g_uUsbDevBulkOutBufferPtr=NULL;
+u8 bCalled_SetEndPoint = 0;
+
+volatile usbdev3_trb_ptr_t g_pBulkOutTrb0;
+
+volatile usbdev3_trb_ptr_t g_pBulkOutTrbArray_Base;
+volatile usbdev3_trb_ptr_t g_pBulkInTrbArray_Base;
+
+u8 *g_ucTempDownBuf;
+u32 g_uCntOfDescOutComplete = 0;
+u32 g_uCntOfBulkOutTrb, g_uCntOfBulkInTrb;
+u8 g_bIsBulkOutXferDone = 0;
+u8 g_bIsBulkInXferDone = 0;
+
+//=====================================================================
+// For usb download
+
+unsigned int exynos_usbd_dn_addr = 0;
+unsigned int exynos_usbd_dn_cnt = 0;
+int is_fastboot = 0;
+int DNW;
+int exynos_got_header = 0;
+int exynos_receive_done = 0;
+
+extern ulong virt_to_phy_exynos5210(ulong addr);
+static u32 exynos_usb_malloc(u32 uSize, u32 uAlign);
+static void exynos_usb_free(u32 uAddr);
+static void exynos_usb_fill_trb(usbdev3_trb_ptr_t pTrb, u32 uBufAddr, u32 uLen, u32 uTrbCtrl, u32 uHwo);
+static int exynos_usb_start_ep_xfer(USBDEV3_EP_DIR_e eEpDir, u8 ucEpNum, u32 uTrbAddr, u32 uStrmidSofn, u32 *uTri);
+
+u32 EXYNOS_USBD_DETECT_IRQ(void)
+{
+	if (oUsbDev3.m_cable != CONNECTED)
+		return 0;
+
+	return readl(rGEVNTCOUNT0);
+}
+
+void EXYNOS_USBD_CLEAR_IRQ(void)
+{
+	do {
+		;
+	} while (0);
+}
+
+#include "fastboot-ss.c"
+
+void exynos_usb_phy_on(void)
+{
+	writel(0x1, USB_DEVICE_PHY_CONTROL);
+	writel(0x1, USB_DEVICE1_PHY_CONTROL);
+}
+
+static void exynoy_usb_phy_off(void)
+{
+	usb3_phy_utmi_t usbdev3_phy_utmi;
+
+	usbdev3_phy_utmi.data = 0x0;
+	usbdev3_phy_utmi.b.otg_disable = 0x1;
+	usbdev3_phy_utmi.b.force_sleep = 0x1;
+	usbdev3_phy_utmi.b.force_suspend = 0x1;
+
+	oUsbDev3.m_uPhyBaseRegs = USBDEVICE3_PHYCTRL_CH0_BASE;
+	writel(usbdev3_phy_utmi.data, EXYNOS_PHY_UTMI);
+	oUsbDev3.m_uPhyBaseRegs = USBDEVICE3_PHYCTRL_CH1_BASE;
+	writel(usbdev3_phy_utmi.data, EXYNOS_PHY_UTMI);
+
+	writel(0x0, USB_DEVICE_PHY_CONTROL);
+	writel(0x0, USB_DEVICE1_PHY_CONTROL);
+}
+
+static void exynos_usb_init_phy(void)
+{
+	usb3_phy_utmi_t usbdev3_phy_utmi;
+	usbdev3_phy_clkpwr_t usbdev3_phy_clkpwr;
+	u32 eClkFreq = USB_PHY_REF_CLK;
+
+	/* Reset PHY configuration */
+	writel(0x00000000, EXYNOS_PHY_REG0);
+	writel(0x24d466e4, EXYNOS_PHY_PARAM0); //must
+	writel(0x00000000, EXYNOS_PHY_RESUME);
+
+	writel(0x08000000, EXYNOS_PHY_LINKSYSTEM); // clear [8] : force_vbusvalid bit, [7] : force_bvalid
+	writel(0x03fff818, EXYNOS_PHY_PARAM1); //must
+	writel(0x00000004, EXYNOS_PHY_BATCHG); // PHY CLK Mux. (1<<2) : w_FREECLK, (0<<2) : w_PHYCLK
+	if (eClkFreq == DIFF_100MHz)
+		writel(readl(EXYNOS_PHY_PARAM0) | (0x1<<31), EXYNOS_PHY_PARAM0); // use 100MHz clk
+	usbdev3_phy_utmi.data = 0x0;
+	usbdev3_phy_utmi.b.otg_disable = 0x1;
+
+	writel(usbdev3_phy_utmi.data, EXYNOS_PHY_UTMI);
+
+	usbdev3_phy_clkpwr.data = 0;
+
+	switch(eClkFreq){
+		case DIFF_100MHz:
+			usbdev3_phy_clkpwr.b.fsel = 0x27;
+			usbdev3_phy_clkpwr.b.refclksel = 2; // DIFF PAD
+			usbdev3_phy_clkpwr.b.mpll_multiplier = 0x19;
+			usbdev3_phy_clkpwr.b.ref_clkdiv2 = 0;
+			usbdev3_phy_clkpwr.b.ssc_ref_clk_sel = 0x00;
+			break;
+		case EXTREF_50MHz:
+			usbdev3_phy_clkpwr.b.fsel = 0x7;
+			usbdev3_phy_clkpwr.b.refclksel = 3; // REFCLK_SINGLE
+			usbdev3_phy_clkpwr.b.mpll_multiplier = 0x32;
+			usbdev3_phy_clkpwr.b.ref_clkdiv2 = 0;
+			usbdev3_phy_clkpwr.b.ssc_ref_clk_sel = 0x00;
+			break;
+		case EXTREF_20MHz:
+			usbdev3_phy_clkpwr.b.fsel = 0x4;
+			usbdev3_phy_clkpwr.b.refclksel = 3; // REFCLK_SINGLE
+			usbdev3_phy_clkpwr.b.mpll_multiplier = 0x7d;
+			usbdev3_phy_clkpwr.b.ref_clkdiv2 = 0;
+			usbdev3_phy_clkpwr.b.ssc_ref_clk_sel = 0x00;
+			break;
+		case EXTREF_19_2MHz:
+			usbdev3_phy_clkpwr.b.fsel = 0x3;
+			usbdev3_phy_clkpwr.b.refclksel = 3; // REFCLK_SINGLE
+			usbdev3_phy_clkpwr.b.mpll_multiplier = 0x02;
+			usbdev3_phy_clkpwr.b.ref_clkdiv2 = 0;
+			usbdev3_phy_clkpwr.b.ssc_ref_clk_sel = 0x88;
+			break;
+		case EXTREF_24MHz:
+		default:
+			usbdev3_phy_clkpwr.b.fsel = 0x5;
+			usbdev3_phy_clkpwr.b.refclksel = 3; // REFCLK_SINGLE
+			usbdev3_phy_clkpwr.b.mpll_multiplier = 0x68;
+			usbdev3_phy_clkpwr.b.ref_clkdiv2 = 0;
+			usbdev3_phy_clkpwr.b.ssc_ref_clk_sel = 0x88;
+			break;
+	}
+
+	usbdev3_phy_clkpwr.b.commononn = 1;		// pll blocks are powered in suspend or sleep mode
+	usbdev3_phy_clkpwr.b.portreset = 1;		// assert port_reset
+	usbdev3_phy_clkpwr.b.retenablen = 1;		// normal operating mode
+	usbdev3_phy_clkpwr.b.ref_clkdiv2 = 0;
+	usbdev3_phy_clkpwr.b.ref_ssp_en = 1;
+	usbdev3_phy_clkpwr.b.ssc_en = 1;
+	usbdev3_phy_clkpwr.b.ssc_range = 0;
+	usbdev3_phy_clkpwr.b.ssc_ref_clk_sel = 0x0;
+
+	writel(usbdev3_phy_clkpwr.data, EXYNOS_PHY_CLKPWR);
+	usbdev3_phy_clkpwr.b.portreset = 0;
+	udelay(10);
+	writel(usbdev3_phy_clkpwr.data, EXYNOS_PHY_CLKPWR);
+}
+
+static void exynos_usb_phy_crport_handshake(usb3_phy_reg0_t *phy_reg0)
+{
+	usb3_phy_reg1_t phy_reg1;
+	u32 usec = 100;
+
+	writel(phy_reg0->data, EXYNOS_PHY_REG0);
+
+	do {
+		phy_reg1.data = readl(EXYNOS_PHY_REG1);
+		if (phy_reg1.b.cr_ack)
+			break;
+	} while (usec-- > 0);
+
+	if (!usec)
+		printf("CRPORT handshake timeout (0x%08x)\n", phy_reg0->data);
+}
+
+static void exynos_phy_crport_ctrl(u16 addr, u16 data)
+{
+	usb3_phy_reg0_t phy_reg0;
+
+	/* Write Address */
+	phy_reg0.data = 0;
+	phy_reg0.b.cr_data_in = addr;
+	phy_reg0.b.cr_cap_addr = 1;
+	exynos_usb_phy_crport_handshake(&phy_reg0);
+	phy_reg0.b.cr_cap_addr = 0;
+	exynos_usb_phy_crport_handshake(&phy_reg0);
+
+	/* Write Data */
+	phy_reg0.data = 0;
+	phy_reg0.b.cr_data_in = data;
+	phy_reg0.b.cr_cap_data = 1;
+	exynos_usb_phy_crport_handshake(&phy_reg0);
+	phy_reg0.b.cr_cap_data = 0;
+	exynos_usb_phy_crport_handshake(&phy_reg0);
+
+	/* Execute write operation */
+	phy_reg0.data = 0;
+	phy_reg0.b.cr_data_in = data;
+	phy_reg0.b.cr_write = 1;
+	exynos_usb_phy_crport_handshake(&phy_reg0);
+	phy_reg0.b.cr_write = 0;
+	exynos_usb_phy_crport_handshake(&phy_reg0);
+}
+
+static void exynos_usb_crport_config(void)
+{
+	exynos_phy_crport_ctrl(0x15, 0xA409);
+	exynos_phy_crport_ctrl(0x12, 0xA000);
+}
+
+static u32 exynos_usb_malloc(u32 uSize, u32 uAlign)
+{
+	u32 uAddr, uTemp1, uTemp2, uTemp3;
+	u32 uAddr_aligned;
+	u32 uAllocHwMem_AlignConstraint = 64;
+
+	// get the GCD(Great Common Divider)
+	uTemp2 = uAlign;
+	uTemp3 = uAllocHwMem_AlignConstraint;
+	while(uTemp3)
+	{
+		uTemp1 = uTemp2%uTemp3;
+		uTemp2 = uTemp3;
+		uTemp3 = uTemp1;
+	}
+
+	// get the LCM(Least Common Multiple)
+	uAlign = uAlign*uAllocHwMem_AlignConstraint/uTemp2;
+	//TODO : check align
+	uAddr = (u32)malloc(uSize + uAlign);
+	uTemp2 = uAddr % uAlign;
+
+	uAddr_aligned = uAddr + (uAlign - uTemp2);
+	*(u32 *)(uAddr_aligned-4) = uAddr;
+
+	memset((void *)uAddr, 0, uSize);
+	DBG_USBD3("exynos_usb_malloc:Addr=0x%08x[0x%08x], Size=%d, Align=%d\n\n", uAddr, uAddr_aligned, uSize, uAlign);
+
+	return uAddr_aligned;
+}
+
+static void exynos_usb_free(u32 uAddr)
+{
+	u32 uFree_addr;
+	if (uAddr != 0)
+	{
+		uFree_addr = *(u32 *)(uAddr - 4);
+		free((u8 *)uFree_addr);
+	}
+	DBG_USBD3("\n\nexynos_usb_free:0x%08x[0x%8x]\n\n", uAddr, uFree_addr);
+}
+
+static void exynos_usb_print_ep0_pkt(u8 *pt, u8 count)
+{
+	int i;
+	DBG_USBD3("[DBG:");
+	for(i=0;i<count;i++)
+		DBG_USBD3("%x,", pt[i]);
+	DBG_USBD3("]\n");
+}
+
+static void exynos_usb_set_descriptor_tlb(void)
+{
+	// Standard device descriptor
+	oUsbDev3.m_oDesc.oDescDevice.bLength=DEVICE_DESC_SIZE;
+	oUsbDev3.m_oDesc.oDescDevice.bDescriptorType=DEVICE_DESCRIPTOR;
+	oUsbDev3.m_oDesc.oDescDevice.bDeviceClass=0xFF;
+	oUsbDev3.m_oDesc.oDescDevice.bDeviceSubClass=0x0;
+	oUsbDev3.m_oDesc.oDescDevice.bDeviceProtocol=0x0;
+	if (oUsbDev3.m_eSpeed == USBDEV3_SPEED_SUPER) {
+		oUsbDev3.m_oDesc.oDescDevice.bMaxPacketSize0=SUPER_SPEED_CONTROL_PKT_EXP_SZ;
+	} else {
+		oUsbDev3.m_oDesc.oDescDevice.bMaxPacketSize0=oUsbDev3.m_uControlEPMaxPktSize;
+	}
+	oUsbDev3.m_oDesc.oDescDevice.idVendorL=0xE8;
+	oUsbDev3.m_oDesc.oDescDevice.idVendorH=0x04;
+	oUsbDev3.m_oDesc.oDescDevice.idProductL=0x34;
+	oUsbDev3.m_oDesc.oDescDevice.idProductH=0x12;
+	oUsbDev3.m_oDesc.oDescDevice.bcdDeviceL=0x00;
+	oUsbDev3.m_oDesc.oDescDevice.bcdDeviceH=0x01;
+	oUsbDev3.m_oDesc.oDescDevice.iManufacturer=0x1; // index of string descriptor
+	oUsbDev3.m_oDesc.oDescDevice.iProduct=0x2;	// index of string descriptor
+	oUsbDev3.m_oDesc.oDescDevice.iSerialNumber=0x0;
+	oUsbDev3.m_oDesc.oDescDevice.bNumConfigurations=0x1;
+
+	// khs. this should be changed, and also other descriptors should be changed
+	if (oUsbDev3.m_eSpeed == USBDEV3_SPEED_SUPER) {
+		oUsbDev3.m_oDesc.oDescDevice.bcdUSBL=0x00;
+		oUsbDev3.m_oDesc.oDescDevice.bcdUSBH=0x03; 	// Ver 3.0
+	} else if (oUsbDev3.m_eSpeed == USBDEV3_SPEED_HIGH) {
+		oUsbDev3.m_oDesc.oDescDevice.bcdUSBL=0x00;
+		oUsbDev3.m_oDesc.oDescDevice.bcdUSBH=0x02; 	// Ver 2.0
+	} else if (oUsbDev3.m_eSpeed == USBDEV3_SPEED_FULL) {
+		oUsbDev3.m_oDesc.oDescDevice.bcdUSBL=0x10;
+		oUsbDev3.m_oDesc.oDescDevice.bcdUSBH=0x01; 	// Ver 2.0
+	}
+
+	// Standard configuration descriptor
+	oUsbDev3.m_oDesc.oDescConfig.bLength=CONFIG_DESC_SIZE; // 0x9 bytes
+	oUsbDev3.m_oDesc.oDescConfig.bDescriptorType=CONFIGURATION_DESCRIPTOR;
+	if (oUsbDev3.m_eSpeed == USBDEV3_SPEED_SUPER)
+		oUsbDev3.m_oDesc.oDescConfig.wTotalLengthL=CONFIG_SS_DESC_TOTAL_SIZE;
+	else
+		oUsbDev3.m_oDesc.oDescConfig.wTotalLengthL=CONFIG_DESC_TOTAL_SIZE;
+	oUsbDev3.m_oDesc.oDescConfig.wTotalLengthH=0;
+	oUsbDev3.m_oDesc.oDescConfig.bNumInterfaces=1;
+	oUsbDev3.m_oDesc.oDescConfig.bConfigurationValue=1;
+	oUsbDev3.m_oDesc.oDescConfig.iConfiguration=0;
+	oUsbDev3.m_oDesc.oDescConfig.bmAttributes=CONF_ATTR_DEFAULT|CONF_ATTR_SELFPOWERED; // bus powered only.
+	oUsbDev3.m_oDesc.oDescConfig.maxPower=25; // draws 50mA current from the USB bus.
+
+	// Standard interface descriptor
+	oUsbDev3.m_oDesc.oDescInterface.bLength=INTERFACE_DESC_SIZE; // 9
+	oUsbDev3.m_oDesc.oDescInterface.bDescriptorType=INTERFACE_DESCRIPTOR;
+	oUsbDev3.m_oDesc.oDescInterface.bInterfaceNumber=0x0;
+	oUsbDev3.m_oDesc.oDescInterface.bAlternateSetting=0x0; // ?
+	oUsbDev3.m_oDesc.oDescInterface.bNumEndpoints = 2;	// # of endpoints except EP0
+	oUsbDev3.m_oDesc.oDescInterface.bInterfaceClass=0xff; // 0x0 ?
+	oUsbDev3.m_oDesc.oDescInterface.bInterfaceSubClass=0x0;
+	oUsbDev3.m_oDesc.oDescInterface.bInterfaceProtocol=0x0;
+	oUsbDev3.m_oDesc.oDescInterface.iInterface=0x0;
+
+	if (oUsbDev3.m_eSpeed == USBDEV3_SPEED_SUPER) {
+		/* Standard endpoint0 descriptor */
+		oUsbDev3.m_oSSDesc.oDescEp0.bLength=ENDPOINT_DESC_SIZE;
+		oUsbDev3.m_oSSDesc.oDescEp0.bDescriptorType=ENDPOINT_DESCRIPTOR;
+		oUsbDev3.m_oSSDesc.oDescEp0.bEndpointAddress=BULK_IN_EP|EP_ADDR_IN;
+		oUsbDev3.m_oSSDesc.oDescEp0.bmAttributes=EP_ATTR_BULK;
+		oUsbDev3.m_oSSDesc.oDescEp0.wMaxPacketSizeL=(u8)oUsbDev3.m_uBulkEPMaxPktSize; /* 64*/
+		oUsbDev3.m_oSSDesc.oDescEp0.wMaxPacketSizeH=(u8)(oUsbDev3.m_uBulkEPMaxPktSize>>8);
+		oUsbDev3.m_oSSDesc.oDescEp0.bInterval=0x0; /* not used */
+
+		oUsbDev3.m_oSSDesc.oDescEp0Comp.bLength=6;
+		oUsbDev3.m_oSSDesc.oDescEp0Comp.bDescriptorType=0x30;
+		oUsbDev3.m_oSSDesc.oDescEp0Comp.bMaxBurst=15;
+		oUsbDev3.m_oSSDesc.oDescEp0Comp.bmAttributes=0;
+		oUsbDev3.m_oSSDesc.oDescEp0Comp.wBytesPerInterval=0;
+
+		/* Standard endpoint1 descriptor */
+		oUsbDev3.m_oSSDesc.oDescEp1.bLength=ENDPOINT_DESC_SIZE;
+		oUsbDev3.m_oSSDesc.oDescEp1.bDescriptorType=ENDPOINT_DESCRIPTOR;
+		oUsbDev3.m_oSSDesc.oDescEp1.bEndpointAddress=BULK_OUT_EP|EP_ADDR_OUT;
+		oUsbDev3.m_oSSDesc.oDescEp1.bmAttributes=EP_ATTR_BULK;
+		oUsbDev3.m_oSSDesc.oDescEp1.wMaxPacketSizeL=(u8)oUsbDev3.m_uBulkEPMaxPktSize; /* 64*/
+		oUsbDev3.m_oSSDesc.oDescEp1.wMaxPacketSizeH=(u8)(oUsbDev3.m_uBulkEPMaxPktSize>>8);
+		oUsbDev3.m_oSSDesc.oDescEp1.bInterval=0x0; /* not used */
+
+		oUsbDev3.m_oSSDesc.oDescEp1Comp.bLength=6;
+		oUsbDev3.m_oSSDesc.oDescEp1Comp.bDescriptorType=0x30;
+		oUsbDev3.m_oSSDesc.oDescEp1Comp.bMaxBurst=15;
+		oUsbDev3.m_oSSDesc.oDescEp1Comp.bmAttributes=0;
+		oUsbDev3.m_oSSDesc.oDescEp1Comp.wBytesPerInterval=0;
+
+		// Standard BOS(Binary Object Store) descriptor
+		oUsbDev3.m_oSSDesc.oDescBos.bLength = BOS_DESC_SIZE;
+		oUsbDev3.m_oSSDesc.oDescBos.bDescriptorType = 0x0F;
+		oUsbDev3.m_oSSDesc.oDescBos.wTotalLength = BOS_DESC_TOTAL_SIZE;
+		oUsbDev3.m_oSSDesc.oDescBos.bNumDeviceCaps = 3;
+
+		oUsbDev3.m_oSSDesc.oDescUsb20Ext.bLength = USB20_EXT_CAP_DESC_SIZE;
+		oUsbDev3.m_oSSDesc.oDescUsb20Ext.bDescriptorType = 0x10;
+		oUsbDev3.m_oSSDesc.oDescUsb20Ext.bDevCapabilityType = USB_CAP_20_EXT;
+		oUsbDev3.m_oSSDesc.oDescUsb20Ext.bmAttributes = 0x2;
+
+		oUsbDev3.m_oSSDesc.oDescSuperCap.bLength = SUPER_CAP_DESC_SIZE;
+		oUsbDev3.m_oSSDesc.oDescSuperCap.bDescriptorType = 0x10;
+		oUsbDev3.m_oSSDesc.oDescSuperCap.bDevCapabilityType = USB_CAP_SS;
+		oUsbDev3.m_oSSDesc.oDescSuperCap.bmAttributes = 0x0;
+		oUsbDev3.m_oSSDesc.oDescSuperCap.wSpeedsSupported = 0xC;
+		oUsbDev3.m_oSSDesc.oDescSuperCap.bFunctionalitySupport = 2;
+		/* TODO: set correct value */
+		oUsbDev3.m_oSSDesc.oDescSuperCap.bU1DevExitLat = 0x4;
+		oUsbDev3.m_oSSDesc.oDescSuperCap.wU2DevExitLat = 0x4;
+
+		oUsbDev3.m_oSSDesc.oDescContainCap.bLength = CONTAIN_CAP_DESC_SIZE;
+		oUsbDev3.m_oSSDesc.oDescContainCap.bDescriptorType = 0x10;
+		oUsbDev3.m_oSSDesc.oDescContainCap.bDevCapabilityType = USB_CAP_CID;
+		oUsbDev3.m_oSSDesc.oDescContainCap.bReserved = 0x0;
+		memset(oUsbDev3.m_oSSDesc.oDescContainCap.containerID, 0x0, 16);
+	}
+	else {
+		/* Standard endpoint0 descriptor */
+		oUsbDev3.m_oDesc.oDescEp0.bLength=ENDPOINT_DESC_SIZE;
+		oUsbDev3.m_oDesc.oDescEp0.bDescriptorType=ENDPOINT_DESCRIPTOR;
+		oUsbDev3.m_oDesc.oDescEp0.bEndpointAddress=BULK_IN_EP|EP_ADDR_IN;
+		oUsbDev3.m_oDesc.oDescEp0.bmAttributes=EP_ATTR_BULK;
+		oUsbDev3.m_oDesc.oDescEp0.wMaxPacketSizeL=(u8)oUsbDev3.m_uBulkEPMaxPktSize; /* 64*/
+		oUsbDev3.m_oDesc.oDescEp0.wMaxPacketSizeH=(u8)(oUsbDev3.m_uBulkEPMaxPktSize>>8);
+		oUsbDev3.m_oDesc.oDescEp0.bInterval=0x0; /* not used */
+
+		/* Standard endpoint1 descriptor */
+		oUsbDev3.m_oDesc.oDescEp1.bLength=ENDPOINT_DESC_SIZE;
+		oUsbDev3.m_oDesc.oDescEp1.bDescriptorType=ENDPOINT_DESCRIPTOR;
+		oUsbDev3.m_oDesc.oDescEp1.bEndpointAddress=BULK_OUT_EP|EP_ADDR_OUT;
+		oUsbDev3.m_oDesc.oDescEp1.bmAttributes=EP_ATTR_BULK;
+		oUsbDev3.m_oDesc.oDescEp1.wMaxPacketSizeL=(u8)oUsbDev3.m_uBulkEPMaxPktSize; /* 64*/
+		oUsbDev3.m_oDesc.oDescEp1.wMaxPacketSizeH=(u8)(oUsbDev3.m_uBulkEPMaxPktSize>>8);
+		oUsbDev3.m_oDesc.oDescEp1.bInterval=0x0; /* not used */
+	}
+}
+
+static void exynos_usb_softreset_phy(u8 ucSet)
+{
+	usbdev3_gusb2phycfg_t usbdev3_gusb2phycfg;
+	usbdev3_gusb3pipectl_t usbdev3_gusb3pipectl;
+
+	usbdev3_gusb2phycfg.data = readl(rGUSB2PHYCFG);
+	usbdev3_gusb2phycfg.b.phy_soft_reset = ucSet;
+	writel(usbdev3_gusb2phycfg.data, rGUSB2PHYCFG);
+
+	usbdev3_gusb3pipectl.data = readl(rGUSB3PIPECTL);
+	usbdev3_gusb3pipectl.b.phy_soft_reset = ucSet;
+	writel(usbdev3_gusb3pipectl.data, rGUSB3PIPECTL);
+}
+
+static void exynos_usb_softreset_core(void)
+{
+	usbdev3_dctl_t usbdev3_dctl;
+
+	usbdev3_dctl.data = readl(rDCTL);
+	usbdev3_dctl.b.core_soft_reset = 1;
+	//usbdev3_dctl.b.run_stop = 0;
+	writel(usbdev3_dctl.data, rDCTL);
+
+	do
+	{
+		udelay(10);
+		usbdev3_dctl.data = readl(rDCTL);
+	} while (usbdev3_dctl.b.core_soft_reset == 1);
+
+	udelay(10);	// s/w must wait at least 3 phy clocks(1/60Mz * 3 = 48ns) before accessing the phy domain
+}
+
+static void exynos_usb_enable_eventinterrupt(void)
+{
+	usbdev3_gevntsiz_t usbdev3_gevntsiz;
+
+	usbdev3_gevntsiz.data = readl(rGEVNTSIZ0);
+	usbdev3_gevntsiz.b.event_int_mask = 0;
+	writel(usbdev3_gevntsiz.data, rGEVNTSIZ0);
+}
+
+static void exynos_usb_disable_eventinterrupt(void)
+{
+	usbdev3_gevntsiz_t usbdev3_gevntsiz;
+
+	usbdev3_gevntsiz.data = readl(rGEVNTSIZ0);
+	usbdev3_gevntsiz.b.event_int_mask = 1;
+	writel(usbdev3_gevntsiz.data, rGEVNTSIZ0);
+}
+
+static void exynos_usb_flush_eventbuffer(void)
+{
+	u32 uEventCount;
+
+	uEventCount = readl(rGEVNTCOUNT0) & 0xffff;
+
+	writel(uEventCount, rGEVNTCOUNT0);
+}
+
+static int exynos_usb_wait_ep_cmd_complete(USBDEV3_EP_DIR_e eEpDir, u8 ucEpNum, u32 uSec)
+{
+	usbdev3_depcmd_t usbdev3_depcmd;
+	u32 uEpCmdAddr = (eEpDir==USBDEV3_EP_DIR_IN)? rDIEPCMD(ucEpNum) : rDOEPCMD(ucEpNum);
+
+	do {
+		usbdev3_depcmd.data = readl(uEpCmdAddr);
+
+		if (!(usbdev3_depcmd.b.cmd_active))
+		{
+			DBG_USBD3("Complete: D%cEPCMD(%d)=0x%08x\n",
+				(eEpDir==USBDEV3_EP_DIR_IN)? 'I' : 'O', ucEpNum, usbdev3_depcmd.data);
+			return 1;
+		}
+
+		udelay(1);
+		uSec--;
+	} while (uSec > 0);
+
+	DBG_USBD3("TimeOver: D%cEPCMD(%d)=0x%08x\n",
+		(eEpDir==USBDEV3_EP_DIR_IN)? 'I' : 'O', ucEpNum, usbdev3_depcmd.data);
+	return 0;
+}
+
+static int exynos_usb_set_ep_cfg(USBDEV3_EP_DIR_e eEpDir, u8 ucEpNum, u32 uPar0, u32 uPar1)
+{
+	usbdev3_depcmd_t usbdev3_depcmd;
+	u32 uEpCmdAddr = (eEpDir==USBDEV3_EP_DIR_IN)? rDIEPCMD(ucEpNum) : rDOEPCMD(ucEpNum);
+	u32 uEpPar0Addr = (eEpDir==USBDEV3_EP_DIR_IN)? rDIEPCMDPAR0(ucEpNum) : rDOEPCMDPAR0(ucEpNum);
+	u32 uEpPar1Addr = (eEpDir==USBDEV3_EP_DIR_IN)? rDIEPCMDPAR1(ucEpNum) : rDOEPCMDPAR1(ucEpNum);
+
+
+	writel(uPar1, uEpPar1Addr);
+	writel(uPar0, uEpPar0Addr);
+
+	usbdev3_depcmd.data = 0;
+	usbdev3_depcmd.b.cmd_type = DEPCMD_CMD_SET_EP_CFG;
+	usbdev3_depcmd.b.cmd_active = 1;
+	writel(usbdev3_depcmd.data, uEpCmdAddr);
+
+	if (!exynos_usb_wait_ep_cmd_complete(eEpDir, ucEpNum, CMDCOMPLETEWAIT_UNIT))
+	{
+		return 0;
+	}
+
+	return 1;
+}
+
+static int exynos_usb_set_ep_xfer_rsrc_cfg(USBDEV3_EP_DIR_e eEpDir, u8 ucEpNum, u32 uPar0)
+{
+	usbdev3_depcmd_t usbdev3_depcmd;
+	u32 uEpCmdAddr = (eEpDir==USBDEV3_EP_DIR_IN)? rDIEPCMD(ucEpNum) : rDOEPCMD(ucEpNum);
+	u32 uEpPar0Addr = (eEpDir==USBDEV3_EP_DIR_IN)? rDIEPCMDPAR0(ucEpNum) : rDOEPCMDPAR0(ucEpNum);
+
+	writel(uPar0, uEpPar0Addr);
+
+	usbdev3_depcmd.data = 0;
+	usbdev3_depcmd.b.cmd_type = DEPCMD_CMD_SET_EP_XFER_RSRC_CFG;
+	usbdev3_depcmd.b.cmd_active = 1;
+	writel(usbdev3_depcmd.data, uEpCmdAddr);
+
+	if (!exynos_usb_wait_ep_cmd_complete(eEpDir, ucEpNum, CMDCOMPLETEWAIT_UNIT))
+	{
+		return 0;
+	}
+
+	return 1;
+}
+
+static void exynos_usb_enable_ep(USBDEV3_EP_DIR_e eEpDir, u8 ucEpNum)
+{
+	u32 uEpEnaIdx;
+
+	uEpEnaIdx = ucEpNum*2;
+
+	if (eEpDir == USBDEV3_EP_DIR_IN)
+	{
+		uEpEnaIdx++;
+	}
+
+	writel(readl(rDALEPENA) | (1<<uEpEnaIdx), rDALEPENA);
+}
+
+static int exynos_usb_activate_ep0(void)
+{
+	usbdev3_depcmd_t usbdev3_depcmd;
+	usbdev3_depcmdpar0_set_ep_cfg_t usbdev3_depcmdpar0_set_ep_cfg;
+	usbdev3_depcmdpar1_set_ep_cfg_t usbdev3_depcmdpar1_set_ep_cfg;
+
+	// . Start New Configuration
+	//-----------------------
+	usbdev3_depcmd.data = 0;
+	usbdev3_depcmd.b.cmd_type = DEPCMD_CMD_START_NEW_CFG;
+	usbdev3_depcmd.b.cmd_active = 1;
+	writel(usbdev3_depcmd.data, rDOEPCMD(0));
+	if (!exynos_usb_wait_ep_cmd_complete(USBDEV3_EP_DIR_OUT, 0, CMDCOMPLETEWAIT_UNIT))
+	{
+		return 0;
+	}
+
+	// . Issue Set Ep Configuraton for EP0-OUT
+	//------------------------------------
+	usbdev3_depcmdpar0_set_ep_cfg.data = 0;
+	usbdev3_depcmdpar0_set_ep_cfg.b.ep_type = USBDEV3_EP_CTRL;
+	usbdev3_depcmdpar0_set_ep_cfg.b.mps = oUsbDev3.m_uControlEPMaxPktSize;	// should be reconfigured after ConnectDone event
+
+	usbdev3_depcmdpar1_set_ep_cfg.data = 0;
+	usbdev3_depcmdpar1_set_ep_cfg.b.xfer_cmpl_en = 1;
+	//usbdev3_depcmdpar1_set_ep_cfg.b.xfer_in_prog_en = 1;
+	usbdev3_depcmdpar1_set_ep_cfg.b.xfer_nrdy_en = 1;
+	usbdev3_depcmdpar1_set_ep_cfg.b.ep_dir = USBDEV3_EP_DIR_OUT;
+	usbdev3_depcmdpar1_set_ep_cfg.b.ep_num = 0;
+
+	if (!exynos_usb_set_ep_cfg(USBDEV3_EP_DIR_OUT, 0, usbdev3_depcmdpar0_set_ep_cfg.data, usbdev3_depcmdpar1_set_ep_cfg.data))
+	{
+		return 0;
+	}
+
+	// . Issue Set Ep Xfer Resource for EP0-OUT
+	//------------------------------------
+	if (!exynos_usb_set_ep_xfer_rsrc_cfg(USBDEV3_EP_DIR_OUT, 0, 1))
+	{
+		return 0;
+	}
+
+	// . Issue Set Ep Configuraton for EP0-IN
+	//------------------------------------
+	usbdev3_depcmdpar0_set_ep_cfg.data = 0;
+	usbdev3_depcmdpar0_set_ep_cfg.b.ep_type = USBDEV3_EP_CTRL;
+	usbdev3_depcmdpar0_set_ep_cfg.b.mps = oUsbDev3.m_uControlEPMaxPktSize;	// should be reconfigured after ConnectDone event
+
+	usbdev3_depcmdpar1_set_ep_cfg.data = 0;
+	usbdev3_depcmdpar1_set_ep_cfg.b.xfer_cmpl_en = 1;
+	//usbdev3_depcmdpar1_set_ep_cfg.b.xfer_in_prog_en = 1;
+	usbdev3_depcmdpar1_set_ep_cfg.b.xfer_nrdy_en = 1;
+	usbdev3_depcmdpar1_set_ep_cfg.b.ep_dir = USBDEV3_EP_DIR_IN;
+	usbdev3_depcmdpar1_set_ep_cfg.b.ep_num = 0;
+
+	if (!exynos_usb_set_ep_cfg(USBDEV3_EP_DIR_IN, 0, usbdev3_depcmdpar0_set_ep_cfg.data, usbdev3_depcmdpar1_set_ep_cfg.data))
+	{
+		return 0;
+	}
+
+	// . Issue Set Ep Xfer Resource for EP0-IN
+	//------------------------------------
+	if (!exynos_usb_set_ep_xfer_rsrc_cfg(USBDEV3_EP_DIR_IN, 0, 1))
+	{
+		return 0;
+	}
+
+	return 1;
+}
+
+static int exynos_usb_activate_ep(USBDEV3_EP_DIR_e eEpDir, u8 ucEpNum)
+{
+	usbdev3_depcmd_t usbdev3_depcmd;
+	usbdev3_depcmdpar0_set_ep_cfg_t usbdev3_depcmdpar0_set_ep_cfg;
+	usbdev3_depcmdpar1_set_ep_cfg_t usbdev3_depcmdpar1_set_ep_cfg;
+
+
+	if (oUsbDev3.m_bEPs_Enabled == 0)
+	{
+		oUsbDev3.m_bEPs_Enabled = 1;
+
+		// . Start New Configuration
+		//-----------------------
+		usbdev3_depcmd.data = 0;
+		usbdev3_depcmd.b.param = 2;	// XferRscIdx = 2 in case of non-EP0, XferRscIdx = 0 in case of EP0
+		usbdev3_depcmd.b.cmd_type = DEPCMD_CMD_START_NEW_CFG;
+		usbdev3_depcmd.b.cmd_active = 1;
+		writel(usbdev3_depcmd.data, rDOEPCMD(0));
+		if (!exynos_usb_wait_ep_cmd_complete(USBDEV3_EP_DIR_OUT, 0, CMDCOMPLETEWAIT_UNIT))
+		{
+			return 0;
+		}
+	}
+
+
+	// . Issue Set Ep Configuraton
+	//------------------------------------
+	usbdev3_depcmdpar0_set_ep_cfg.data = 0;
+	usbdev3_depcmdpar0_set_ep_cfg.b.ep_type = USBDEV3_EP_BULK;
+	usbdev3_depcmdpar0_set_ep_cfg.b.mps = oUsbDev3.m_uBulkEPMaxPktSize;
+
+	if (eEpDir == USBDEV3_EP_DIR_IN)
+	{
+		usbdev3_depcmdpar0_set_ep_cfg.b.fifo_num = ucEpNum;
+	}
+
+	usbdev3_depcmdpar0_set_ep_cfg.b.brst_siz = 0;	// khs. should find best value
+
+
+	usbdev3_depcmdpar1_set_ep_cfg.data = 0;
+	usbdev3_depcmdpar1_set_ep_cfg.b.xfer_cmpl_en = 1;
+	//usbdev3_depcmdpar1_set_ep_cfg.b.xfer_in_prog_en = 1;
+	//usbdev3_depcmdpar1_set_ep_cfg.b.xfer_nrdy_en = 1;		// when using preset transfer, this interrupt can be disabled
+	usbdev3_depcmdpar1_set_ep_cfg.b.ep_dir = (u32)eEpDir;
+	usbdev3_depcmdpar1_set_ep_cfg.b.ep_num = ucEpNum;
+
+	if (!exynos_usb_set_ep_cfg(eEpDir, ucEpNum, usbdev3_depcmdpar0_set_ep_cfg.data, usbdev3_depcmdpar1_set_ep_cfg.data))
+	{
+		return 0;
+	}
+
+	// . Issue Set Ep Xfer Resource
+	//--------------------------
+	if (!exynos_usb_set_ep_xfer_rsrc_cfg(eEpDir, ucEpNum, 1))
+	{
+		return 0;
+	}
+
+	return 1;
+}
+
+static void exynos_usb_runstop_device(u8 ucSet)
+{
+	usbdev3_dctl_t usbdev3_dctl;
+
+	usbdev3_dctl.data = readl(rDCTL);
+	usbdev3_dctl.b.run_stop = ucSet;
+	writel(usbdev3_dctl.data, rDCTL);
+}
+
+static int exynos_usb_start_ep_xfer(USBDEV3_EP_DIR_e eEpDir, u8 ucEpNum, u32 uTrbAddr, u32 uStrmidSofn, u32 *uTri)
+{
+	usbdev3_depcmd_t usbdev3_depcmd;
+	u32 uEpCmdAddr = (eEpDir==USBDEV3_EP_DIR_IN)? rDIEPCMD(ucEpNum) : rDOEPCMD(ucEpNum);
+	u32 uEpPar0Addr = (eEpDir==USBDEV3_EP_DIR_IN)? rDIEPCMDPAR0(ucEpNum) : rDOEPCMDPAR0(ucEpNum);
+	u32 uEpPar1Addr = (eEpDir==USBDEV3_EP_DIR_IN)? rDIEPCMDPAR1(ucEpNum) : rDOEPCMDPAR1(ucEpNum);
+
+
+	writel(virt_to_phys((void *)uTrbAddr), uEpPar1Addr);
+	writel(0, uEpPar0Addr);
+
+	usbdev3_depcmd.data = 0;
+	usbdev3_depcmd.b.cmd_type = DEPCMD_CMD_START_XFER;
+	usbdev3_depcmd.b.cmd_active = 1;
+	usbdev3_depcmd.b.param = uStrmidSofn;
+	writel(usbdev3_depcmd.data, uEpCmdAddr);
+
+	if (!exynos_usb_wait_ep_cmd_complete(eEpDir, ucEpNum, CMDCOMPLETEWAIT_UNIT))
+	{
+		return 0;
+	}
+
+	// . Get the Tranfer Resource Index from the start transfer command
+	//--------------------------------------------------------
+	usbdev3_depcmd.data = readl(uEpCmdAddr);
+	*uTri = usbdev3_depcmd.b.param & 0x7f;
+
+	return 1;
+}
+
+static void exynos_usb_fill_trb(usbdev3_trb_ptr_t pTrb, u32 uBufAddr, u32 uLen, u32 uTrbCtrl, u32 uHwo)
+{
+	pTrb->buf_ptr_l = virt_to_phys((void *)uBufAddr);
+	pTrb->buf_ptr_h = 0;
+
+	pTrb->status.data = 0;
+	pTrb->status.b.buf_siz = uLen;
+
+	pTrb->control.data = uTrbCtrl & 0xfffffffeU;
+
+	// must do this last => why?
+	if (uHwo)
+	{
+		pTrb->control.b.hwo = 1;
+	}
+
+}
+
+static int exynos_usb_start_ep0_setup_rx(void)
+{
+	usbdev3_trb_ctrl_t usbdev3_trb_ctrl;
+
+	// . Set TRB for Setup
+	//------------------
+	usbdev3_trb_ctrl.data = 0;
+	usbdev3_trb_ctrl.b.lst = 1;
+	usbdev3_trb_ctrl.b.trb_ctrl = (u32)TRB_CTRL_SETUP;
+	usbdev3_trb_ctrl.b.isp_imi = 1;
+	usbdev3_trb_ctrl.b.ioc = 1;
+	usbdev3_trb_ctrl.b.strmid_sofn = 0;
+
+	exynos_usb_fill_trb(oUsbDev3.m_oSetupTrbPtr, (u32)&oUsbDev3.m_oDeviceRequest,
+		oUsbDev3.m_uControlEPMaxPktSize, usbdev3_trb_ctrl.data, 1);
+
+	// . Issue Start Xfer for EP0-OUT
+	//----------------------------
+	if (!exynos_usb_start_ep_xfer(USBDEV3_EP_DIR_OUT, 0, (u32)oUsbDev3.m_oSetupTrbPtr, 0, &oUsbDev3.m_uTriOut[0]))
+	{
+		return 0;
+	}
+
+	return 1;
+}
+
+static int exynos_usb_init_core(USBDEV3_SPEED_e eSpeed)
+{
+	usbdev3_gsbuscfg0_t usbdev3_gsbuscfg0;
+	usbdev3_gsbuscfg1_t usbdev3_gsbuscfg1;
+	usbdev3_gusb2phycfg_t usbdev3_gusb2phycfg;
+	usbdev3_gusb3pipectl_t usbdev3_gusb3pipectl;
+	usbdev3_gevntsiz_t usbdev3_gevntsiz;
+	usbdev3_dcfg_t usbdev3_dcfg;
+	usbdev3_devten_t usbdev3_devten;
+	u32 uData = 0;
+
+	// . to soft-reset core
+	//-----------------
+	exynos_usb_softreset_core();
+	// . to crport configuration
+	//-----------------
+	exynos_usb_crport_config();
+	// . to configure GSBUSCFG0/1
+	//   khs. I should find best setting value for our AP system
+	//----------------------------------------------
+	usbdev3_gsbuscfg0.data = 0;
+	//usbdev3_gsbuscfg0.b.incr_xbrst_ena = 1;
+	//usbdev3_gsbuscfg0.b.incr_4brst_ena = 1;
+	//usbdev3_gsbuscfg0.b.incr_8brst_ena = 1;
+	usbdev3_gsbuscfg0.b.incr_16brst_ena = 1;
+	writel(usbdev3_gsbuscfg0.data, rGSBUSCFG0);
+
+	usbdev3_gsbuscfg1.data = 0x00000300;	// reset value
+	writel(usbdev3_gsbuscfg1.data, rGSBUSCFG1);
+
+	// . to configure GTXTHRCFG/GRXTHRCFG
+	//------------------------------------------------
+		// skipped because this sfr is only valid in the host mode
+
+	// . to check IP version
+	//-------------------
+	uData = readl(rGSNPSID);
+	DBG_USBD3("IP version is %1x.%03x\n", (uData&0xf000)>>12, (uData&0x0fff));
+
+	// . to set usb 2.0 phy-related configuration parmeters
+	//---------------------------------------------
+	usbdev3_gusb2phycfg.data = readl(rGUSB2PHYCFG);
+	usbdev3_gusb2phycfg.b.turnaround_time = 9;
+	writel(usbdev3_gusb2phycfg.data, rGUSB2PHYCFG);
+
+	// . to set usb 3.0 phy-related configuration parmeters
+	//	(I should find proper setting value)
+	//---------------------------------------------
+	usbdev3_gusb3pipectl.data = 0x00260002;	// reset value
+	// usbdev3_gusb3pipectl.data = 0x00240002;	// clear suspend bit
+	writel(usbdev3_gusb3pipectl.data, rGUSB3PIPECTL);
+
+	// . to set tx fifo sizes
+	//------------------
+		// skipped because of using default setting
+
+
+	// . to set rx fifo sizes
+	//-------------------
+		// skipped because of using default setting
+
+
+	// . to initialize the Event Buffer registers
+	//-------------------------------------
+	writel(0, rGEVNTADR_HI0);
+	oUsbDev3.m_CurrentEventPosition = 0;
+	writel(virt_to_phys((void *)oUsbDev3.m_pEventBuffer), rGEVNTADR_LO0);
+	usbdev3_gevntsiz.data = 0;
+	usbdev3_gevntsiz.b.event_siz = 4*USBDEV3_EVENT_BUFFER_COUNT;
+	usbdev3_gevntsiz.b.event_int_mask = 0;
+	writel(usbdev3_gevntsiz.data, rGEVNTSIZ0);
+	writel(0, rGEVNTCOUNT0);
+
+	// . to set Gloval Control Register
+	//	khs. I should find proper setting value
+	//--------------------------------
+		// writel(rGCTL, 0x30c02000);
+
+	// . to set Device Config. Register
+	//-----------------------------
+	usbdev3_dcfg.data = 0;
+	usbdev3_dcfg.b.dev_speed = (u32) eSpeed;
+	usbdev3_dcfg.b.dev_addr = 0;
+	usbdev3_dcfg.b.per_fr_int = 2;	// 90%
+	usbdev3_dcfg.b.intr_num = 0;
+	usbdev3_dcfg.b.num_rx_buf = 1;		// khs. 1(simulation code) or 4(reset value)?
+#ifdef USBDEV3_LPM_CAPABLE
+	usbdev3_dcfg.b.lpm_cap = 1;
+#endif
+	writel(usbdev3_dcfg.data, rDCFG);
+
+	// . to enable Global and Device interrupts
+	//	(I should find proper setting value)
+	//------------------------------------
+	exynos_usb_disable_eventinterrupt();
+	exynos_usb_flush_eventbuffer();
+	exynos_usb_enable_eventinterrupt();
+
+	usbdev3_devten.data = 0;
+	usbdev3_devten.b.disconn_evt_en = 1;
+	usbdev3_devten.b.usb_reset_en = 1;
+	usbdev3_devten.b.conn_done_en = 1;
+	//usbdev3_devten.b.usb_lnk_sts_chng_en = 1;
+		//usbdev3_devten.b.wake_up_en = 1;
+		//usbdev3_devten.b.errtic_err_en = 1;
+		//usbdev3_devten.b.cmd_cmplt_en = 1;
+	usbdev3_devten.b.evnt_overflow_en = 1;
+	writel(usbdev3_devten.data, rDEVTEN);
+
+	// . to activate EP0
+	//----------------
+	if (!exynos_usb_activate_ep0())
+	{
+		DBG_USBD3("Activate Ep0 Fail\n");
+		return -1;
+	}
+
+	// . to start EP0 to receive SETUP packets
+	//----------------------------------
+	if (!exynos_usb_start_ep0_setup_rx())
+	{
+		DBG_USBD3("Start Ep0 Setup Rx Fail\n");
+		return -1;
+	}
+
+	// . to enable EP0-OUT/IN in DALEPENA register
+	//----------------------------------------
+	exynos_usb_enable_ep(USBDEV3_EP_DIR_OUT, 0);
+	exynos_usb_enable_ep(USBDEV3_EP_DIR_IN, 0);
+
+	// . to set the Run/Stop bit
+	//----------------------
+
+	return 0;
+}
+
+static void exynos_usb_handle_disconnect_int(void)
+{
+	oUsbDev3.m_eUsbDev3State = USBDEV3_STATE_DEFAULT;
+}
+
+static int exynos_usb_end_ep_xfer(USBDEV3_EP_DIR_e eEpDir, u8 ucEpNum, u32 uTri)
+{
+	usbdev3_depcmd_t usbdev3_depcmd;
+	u32 uEpCmdAddr = (eEpDir==USBDEV3_EP_DIR_IN)? rDIEPCMD(ucEpNum) : rDOEPCMD(ucEpNum);
+
+	usbdev3_depcmd.data = 0;
+	usbdev3_depcmd.b.cmd_type = DEPCMD_CMD_END_XFER;
+	usbdev3_depcmd.b.cmd_active = 1;
+	//usbdev3_depcmd.b.hipri_forcerm = 1;
+	usbdev3_depcmd.b.param = uTri;
+	writel(usbdev3_depcmd.data, uEpCmdAddr);
+
+	if (!exynos_usb_wait_ep_cmd_complete(eEpDir, ucEpNum, (10*CMDCOMPLETEWAIT_UNIT)))	// wait time is longer than others'
+	{
+		return 0;
+	}
+
+	return 1;
+}
+
+static void exynos_usb_handle_reset_int(void)
+{
+	u32 uEpNum;
+	usbdev3_dcfg_t usbdev3_dcfg;
+	usbdev3_dsts_t usbdev3_dsts;
+	usbdev3_dgcmd_t usbdev3_dgcmd;
+	// . Stop All Transfers except for default control EP0
+	//-------------------------------------------
+	// stop any active xfers on the non-EP0 IN endpoints
+	for (uEpNum = 1; uEpNum < TOTL_EP_COUNT; uEpNum++)
+	{
+		if (oUsbDev3.m_uTriIn[uEpNum])
+		{
+			exynos_usb_end_ep_xfer(USBDEV3_EP_DIR_IN, uEpNum, oUsbDev3.m_uTriIn[uEpNum]);
+			oUsbDev3.m_uTriIn[uEpNum] = 0;
+		}
+	}
+
+	// stop any active xfers on the non-EP0 OUT endpoints
+	for (uEpNum = 1; uEpNum < TOTL_EP_COUNT; uEpNum++)
+	{
+		if (oUsbDev3.m_uTriOut[uEpNum])
+		{
+			exynos_usb_end_ep_xfer(USBDEV3_EP_DIR_OUT, uEpNum, oUsbDev3.m_uTriOut[uEpNum]);
+			oUsbDev3.m_uTriOut[uEpNum] = 0;
+		}
+	}
+
+	// . Flush all FIFOs
+	//---------------
+	usbdev3_dgcmd.data= 0;
+	usbdev3_dgcmd.b.cmd_type = DGCMD_CMD_ALL_FIFO_FLUSH;
+	usbdev3_dgcmd.b.cmd_active = 1;
+	writel(usbdev3_dgcmd.data, rDGCMD);
+
+	// wait until command is completed
+	do
+	{
+		udelay(1);
+		usbdev3_dgcmd.data = readl(rDGCMD);
+	}while(usbdev3_dgcmd.b.cmd_active);
+
+	// wait until Rx FIFO becomes empty
+	do
+	{
+		udelay(1);
+		usbdev3_dsts.data = readl(rDSTS);
+	}while(!(usbdev3_dsts.b.rx_fifo_empty));
+
+	// . Issue a DEPCSTALL command for any stalled EP
+	//--------------------------------------------
+	// this routine is necessary???
+
+	// . Set Device Address to 0
+	//-----------------------
+	usbdev3_dcfg.data = readl(rDCFG);
+	usbdev3_dcfg.b.dev_addr = 0;
+	writel(usbdev3_dcfg.data, rDCFG);
+
+	// . Set Device State to Default
+	//--------------------------
+	oUsbDev3.m_eUsbDev3State = USBDEV3_STATE_DEFAULT;
+}
+
+static void exynos_usb_set_maxpktsizes(USBDEV3_SPEED_e eSpeed)
+{
+	oUsbDev3.m_eSpeed = eSpeed;
+
+	if (eSpeed == USBDEV3_SPEED_SUPER)
+	{
+		oUsbDev3.m_uControlEPMaxPktSize = SUPER_SPEED_CONTROL_PKT_SIZE;
+		oUsbDev3.m_uBulkEPMaxPktSize = SUPER_SPEED_BULK_PKT_SIZE;
+	}
+	else if (eSpeed == USBDEV3_SPEED_HIGH)
+	{
+		oUsbDev3.m_uControlEPMaxPktSize = HIGH_SPEED_CONTROL_PKT_SIZE;
+		oUsbDev3.m_uBulkEPMaxPktSize = HIGH_SPEED_BULK_PKT_SIZE;
+	}
+	else
+	{
+		oUsbDev3.m_uControlEPMaxPktSize = FULL_SPEED_CONTROL_PKT_SIZE;
+		oUsbDev3.m_uBulkEPMaxPktSize = FULL_SPEED_BULK_PKT_SIZE;
+	}
+}
+
+static void exynos_usb_get_connected_speed(USBDEV3_SPEED_e *eSpeed)
+{
+	usbdev3_dsts_t usbdev3_dsts;
+
+	usbdev3_dsts.data = readl(rDSTS);
+
+	*eSpeed = (USBDEV3_SPEED_e)usbdev3_dsts.b.connect_speed;
+}
+
+static void exynos_usb_handle_connect_done_int(void)
+{
+	USBDEV3_SPEED_e eSpeed;
+	usbdev3_gusb2phycfg_t usbdev3_gusb2phycfg;
+	usbdev3_gusb3pipectl_t usbdev3_gusb3pipectl;
+
+	usbdev3_depcmdpar0_set_ep_cfg_t usbdev3_depcmdpar0_set_ep_cfg;
+	usbdev3_depcmdpar1_set_ep_cfg_t usbdev3_depcmdpar1_set_ep_cfg;
+
+	oUsbDev3.m_uEp0State = EP0_STATE_INIT;
+
+	// . Get the connected speed
+	//------------------------
+	exynos_usb_get_connected_speed(&eSpeed);
+
+	// . Suspend the Inactive PHY
+	//-------------------------
+	if (eSpeed == USBDEV3_SPEED_SUPER)
+	{
+		usbdev3_gusb2phycfg.data = readl(rGUSB2PHYCFG);
+		usbdev3_gusb2phycfg.b.suspend_usb2_phy = 1;
+		writel(usbdev3_gusb2phycfg.data, rGUSB2PHYCFG);
+	}
+	else
+	{
+		usbdev3_gusb3pipectl.data = readl(rGUSB3PIPECTL);
+		usbdev3_gusb3pipectl.b.suspend_usb3_ss_phy = 1;
+		writel(usbdev3_gusb3pipectl.data, rGUSB3PIPECTL);
+	}
+
+	// . Set Max Packet Size based on enumerated speed
+	//----------------------------------------------
+	switch(eSpeed) {
+		case USBDEV3_SPEED_SUPER :
+			exynos_usb_set_maxpktsizes(USBDEV3_SPEED_SUPER);
+			DBG_USBD3("(Enumerated Speed : Super)\n");
+			break;
+
+		case USBDEV3_SPEED_HIGH :
+			exynos_usb_set_maxpktsizes(USBDEV3_SPEED_HIGH);
+			DBG_USBD3("(Enumerated Speed : High)\n");
+			break;
+
+		case USBDEV3_SPEED_FULL :
+			exynos_usb_set_maxpktsizes(USBDEV3_SPEED_FULL);
+			DBG_USBD3("(Enumerated Speed : Full)\n");
+			break;
+
+		default :
+			return;
+	}
+
+	// . Issue Set Ep Configuraton for EP0-OUT/IN based on the connected speed
+	//----------------------------------------------------------------
+	usbdev3_depcmdpar0_set_ep_cfg.data = 0;
+	usbdev3_depcmdpar0_set_ep_cfg.b.ep_type = USBDEV3_EP_CTRL;
+	usbdev3_depcmdpar0_set_ep_cfg.b.mps = oUsbDev3.m_uControlEPMaxPktSize;
+	usbdev3_depcmdpar0_set_ep_cfg.b.ign_dsnum = 1;	// to avoid resetting the sequnece number
+
+	usbdev3_depcmdpar1_set_ep_cfg.data = 0;
+	usbdev3_depcmdpar1_set_ep_cfg.b.xfer_cmpl_en = 1;
+	//usbdev3_depcmdpar1_set_ep_cfg.b.xfer_in_prog_en = 1;
+	usbdev3_depcmdpar1_set_ep_cfg.b.xfer_nrdy_en = 1;
+	usbdev3_depcmdpar1_set_ep_cfg.b.ep_dir = USBDEV3_EP_DIR_OUT;
+	usbdev3_depcmdpar1_set_ep_cfg.b.ep_num = 0;
+
+	if (!exynos_usb_set_ep_cfg(USBDEV3_EP_DIR_OUT, 0, usbdev3_depcmdpar0_set_ep_cfg.data, usbdev3_depcmdpar1_set_ep_cfg.data))
+	{
+		return ;
+	}
+
+	usbdev3_depcmdpar1_set_ep_cfg.b.ep_dir = USBDEV3_EP_DIR_IN;
+	if (!exynos_usb_set_ep_cfg(USBDEV3_EP_DIR_IN, 0, usbdev3_depcmdpar0_set_ep_cfg.data, usbdev3_depcmdpar1_set_ep_cfg.data))
+	{
+		return ;
+	}
+
+	// . Prepare Descriptor Table
+	//------------------------
+	if (is_fastboot)
+		fboot_usb_set_descriptors_tlb();
+	else
+		exynos_usb_set_descriptor_tlb();
+}
+
+static void exynos_usb_handle_dev_event(usbdev3_devt_t uDevEvent)
+{
+	switch (uDevEvent.b.evt_type)
+	{
+		case DEVT_DISCONN:
+			DBG_USBD3("Disconnect\n");
+			exynos_usb_handle_disconnect_int();
+			break;
+
+		case DEVT_USBRESET:
+			DBG_USBD3("USB Reset\n");
+			exynos_usb_handle_reset_int();
+			break;
+
+		case DEVT_CONNDONE:
+			DBG_USBD3("Connect Done\n");
+			exynos_usb_handle_connect_done_int();
+			break;
+
+		case DEVT_WKUP:
+			DBG_USBD3("Wakeup\n");
+			//USBDEV3_HandleWakeupDetectedInt();
+			break;
+
+		case DEVT_ULST_CHNG:
+			DBG_USBD3("Link Status Change\n");
+			//USBDEV3_HandleLinkStatusChange();
+			break;
+
+		case DEVT_EOPF:
+			DBG_USBD3("End of Periodic Frame\n");
+			//USBDEV3_HandleEndPeriodicFrameInt();
+			break;
+
+		case DEVT_SOF:
+			DBG_USBD3("Start of Frame\n");
+			//USBDEV3_HandleSofInt();
+			break;
+
+		case DEVT_ERRATICERR:
+			DBG_USBD3("Erratic Error\n");
+			break;
+
+		case DEVT_CMD_CMPL:
+			DBG_USBD3("Command Complete\n");
+			break;
+
+		case DEVT_OVERFLOW:
+			DBG_USBD3("Overflow\n");
+			break;
+
+		default:
+			DBG_USBD3("Unknown event!\n");
+	}
+
+}
+
+static void exynos_usb_handle_ep0_in_xfer_complete(void)
+{
+	switch (oUsbDev3.m_uEp0State) {
+		case EP0_STATE_IN_DATA_PHASE:
+			oUsbDev3.m_uEp0State = EP0_STATE_OUT_WAIT_NRDY;
+			break;
+
+		case EP0_STATE_IN_STATUS_PHASE:
+			oUsbDev3.m_uEp0State = EP0_STATE_INIT;
+
+			// . to start EP0 to receive SETUP packets
+			//----------------------------------
+			if (!exynos_usb_start_ep0_setup_rx())
+			{
+				return;
+			}
+			break;
+
+		// khs. this routine is abnormal case, and handling for this case is not prepared.
+		default :
+			DBG_USBD3("\nError : [EP0-InXferComplete]Not Supported @%d\n", oUsbDev3.m_uEp0State);
+			break;
+	}
+}
+
+static void exynos_usb_handle_ep_in_xfer_complete(void)
+{
+	g_uCntOfDescOutComplete = 0;
+
+	g_bIsBulkInXferDone = 1;
+
+	exynos_usb_free((u32)g_pBulkInTrbArray_Base);
+
+	oUsbDev3.m_pUpPt += oUsbDev3.m_uUploadSize;
+	DBG_USBD3("DMA IN : Transfer Complete\n");
+	if (oUsbDev3.m_uUploadSize > 0) {
+		exynos_receive_done = 1;
+		printf("Upload Done!! Upload Address: 0x%x, Upload Filesize:0x%x\n",
+				oUsbDev3.m_uUploadAddr, (oUsbDev3.m_uUploadSize));
+	}
+
+}
+
+static int exynos_usb_start_ep0_in_xfer(u32 pBufAddr, u32 uLen)
+{
+	usbdev3_trb_ctrl_t usbdev3_trb_ctrl;
+
+	usbdev3_trb_ctrl.data = 0;
+
+	if (oUsbDev3.m_uEp0State == EP0_STATE_IN_STATUS_PHASE) {
+		if (oUsbDev3.m_bEp0ThreeStage)
+			usbdev3_trb_ctrl.b.trb_ctrl = (u32)TRB_CTRL_STATUS_3;
+		else
+			usbdev3_trb_ctrl.b.trb_ctrl = (u32)TRB_CTRL_STATUS_2;
+	} else {
+		usbdev3_trb_ctrl.b.trb_ctrl = (u32)TRB_CTRL_CTLDATA_1ST;
+	}
+
+	usbdev3_trb_ctrl.b.lst = 1;
+	usbdev3_trb_ctrl.b.isp_imi = 1;
+	usbdev3_trb_ctrl.b.ioc = 1;
+	usbdev3_trb_ctrl.b.strmid_sofn = 0;
+
+	exynos_usb_fill_trb(oUsbDev3.m_oInTrbPtr, pBufAddr, uLen, usbdev3_trb_ctrl.data, 1);
+
+	// . Issue Start Xfer for EP0-IN
+	//----------------------------
+	if (!exynos_usb_start_ep_xfer(USBDEV3_EP_DIR_IN, 0, (u32)oUsbDev3.m_oInTrbPtr, 0, &oUsbDev3.m_uTriIn[0]))
+	{
+		return 0;
+	}
+
+	return 1;
+}
+
+static int exynos_usb_start_ep0_out_xfer(u32 pBufAddr, u32 uLen)
+{
+	usbdev3_trb_ctrl_t usbdev3_trb_ctrl;
+
+	usbdev3_trb_ctrl.data = 0;
+
+	if (oUsbDev3.m_uEp0State == EP0_STATE_OUT_STATUS_PHASE) {
+		if (oUsbDev3.m_bEp0ThreeStage)
+			usbdev3_trb_ctrl.b.trb_ctrl = (u32)TRB_CTRL_STATUS_3;
+		else
+			usbdev3_trb_ctrl.b.trb_ctrl = (u32)TRB_CTRL_STATUS_2;
+	} else {
+		usbdev3_trb_ctrl.b.trb_ctrl = (u32)TRB_CTRL_CTLDATA_1ST;
+	}
+
+	usbdev3_trb_ctrl.b.lst = 1;
+	usbdev3_trb_ctrl.b.isp_imi = 1;
+	usbdev3_trb_ctrl.b.ioc = 1;
+	usbdev3_trb_ctrl.b.strmid_sofn = 0;
+
+	exynos_usb_fill_trb(oUsbDev3.m_oOutTrbPtr, pBufAddr, uLen, usbdev3_trb_ctrl.data, 1);
+
+	// . Issue Start Xfer for EP0-OUT
+	//----------------------------
+	if (!exynos_usb_start_ep_xfer(USBDEV3_EP_DIR_OUT, 0, (u32)oUsbDev3.m_oOutTrbPtr, 0, &oUsbDev3.m_uTriOut[0]))
+	{
+		return 0;
+	}
+
+	return 1;
+}
+
+static void exynos_usb_setup_in_status_phase(void)
+{
+
+	DBG_USBD3("Setup EP0 IN ZLP\n");
+
+	oUsbDev3.m_uEp0State = EP0_STATE_IN_STATUS_PHASE;
+
+	exynos_usb_start_ep0_in_xfer(oUsbDev3.m_uStatusBufAddr, 0);
+}
+
+static void exynos_usb_setup_out_status_phase(void)
+{
+	DBG_USBD3("Setup EP0 OUT ZLP\n");
+
+	oUsbDev3.m_uEp0State = EP0_STATE_OUT_STATUS_PHASE;
+
+	exynos_usb_start_ep0_out_xfer((u32)&oUsbDev3.m_oDeviceRequest, 0);
+}
+
+static void exynos_usb_handle_ep0_in_xfer_not_ready(void)
+{
+	switch (oUsbDev3.m_uEp0State) {
+		case EP0_STATE_IN_WAIT_NRDY:
+			// . to setup in-status phase
+			exynos_usb_setup_in_status_phase();
+			break;
+
+		// khs. this routine is abnormal case, and handling for this case is not prepared.
+		default :
+			DBG_USBD3("\nError : [EP0-InXferNotReady]Not Supported @%d\n", oUsbDev3.m_uEp0State);
+			break;
+	}
+}
+
+static void exynos_usb_handle_ep_in_event(usbdev3_depevt_t uEpInEvent)
+{
+	u32 uEpNum = uEpInEvent.b.ep_num/2;		// 1,3,5,7,...
+
+	DBG_USBD3("[EP%d] IN State = 0x%x Type = 0x%x[%x]\n", uEpNum, oUsbDev3.m_uEp0State, uEpInEvent.b.evt_type, uEpInEvent.data);
+	switch (uEpInEvent.b.evt_type)
+	{
+		case DEPEVT_EVT_XFER_CMPL:
+			DBG_USBD3("[EP%d] IN xfer complete @%d\n", uEpNum, oUsbDev3.m_uEp0State);
+			if (uEpNum == 0)
+				exynos_usb_handle_ep0_in_xfer_complete();
+			else if (uEpNum == BULK_IN_EP) {
+				if (is_fastboot)
+					fboot_usb_handle_ep_in_xfer_complete();
+				else
+					exynos_usb_handle_ep_in_xfer_complete();
+			}
+			else
+				Assert(0);
+			break;
+
+		case DEPEVT_EVT_XFER_IN_PROG:
+			DBG_USBD3("[EP%d] IN xfer in progress @%d\n", uEpNum, oUsbDev3.m_uEp0State);
+			break;
+
+		case DEPEVT_EVT_XFER_NRDY:
+			DBG_USBD3("[EP%d] IN xfer not ready @%d\n", uEpNum, oUsbDev3.m_uEp0State);
+			if (uEpNum == 0)
+				exynos_usb_handle_ep0_in_xfer_not_ready();
+			break;
+
+		case DEPEVT_EVT_FIFOXRUN:
+			DBG_USBD3("[EP%d] IN FIFO Underrun Error @%d\n", uEpNum, oUsbDev3.m_uEp0State);
+			break;
+
+		case DEPEVT_EVT_STRM_EVT:
+			DBG_USBD3("[EP%d] IN Stream Event @%d\n", uEpNum, oUsbDev3.m_uEp0State);
+			break;
+
+		case DEPEVT_EVT_EPCMD_CMPL:
+			DBG_USBD3("[EP%d] IN Command Complete @%d\n", uEpNum, oUsbDev3.m_uEp0State);
+			break;
+
+		default:
+			DBG_USBD3("Unknown event!\n");
+	}
+}
+
+static int exynos_usb_prepare_1st_bulk_out_trb(void)
+{
+	usbdev3_trb_ctrl_t usbdev3_trb_ctrl;
+
+	g_bIsBulkOutXferDone = 0;
+	g_bIsBulkInXferDone = 0;
+
+	g_pBulkOutTrb0 = (usbdev3_trb_ptr_t)exynos_usb_malloc(sizeof(usbdev3_trb_t), USBDEV3_MDWIDTH/8);
+	if (g_pBulkOutTrb0 == NULL)
+	{
+		Assert(0);
+	}
+	/* size + 1 is for fastboot */
+	g_ucTempDownBuf = (u8 *)exynos_usb_malloc(4096 + 1, USBDEV3_MDWIDTH/8);
+
+	if (g_ucTempDownBuf == NULL)
+	{
+		Assert(0);
+	}
+
+	// . Set TRB for 1st Bulk Out Packet
+	//-----------------------------
+	usbdev3_trb_ctrl.data = 0;
+	usbdev3_trb_ctrl.b.lst = 1;
+	usbdev3_trb_ctrl.b.trb_ctrl = (u32)TRB_CTRL_NORMAL;
+	usbdev3_trb_ctrl.b.isp_imi = 1;
+	usbdev3_trb_ctrl.b.ioc = 1;
+	usbdev3_trb_ctrl.b.strmid_sofn = 0;
+
+	exynos_usb_fill_trb(g_pBulkOutTrb0, (u32)g_ucTempDownBuf, oUsbDev3.m_uBulkEPMaxPktSize, usbdev3_trb_ctrl.data, 1);
+
+	// . Issue Start Xfer for 1st Bulk Out Packet
+	//------------------------------------
+	if (!exynos_usb_start_ep_xfer(USBDEV3_EP_DIR_OUT, BULK_OUT_EP, (u32)g_pBulkOutTrb0, 0, &oUsbDev3.m_uTriOut[BULK_OUT_EP]))
+	{
+		return 0;
+	}
+	return 1;
+}
+
+void exynos_usb_handle_setup(void)
+{
+	const u8 *string_desc1, *string_desc2, *string_desc3;
+	usbdev3_dcfg_t usbdev3_dcfg;
+	u32 uRemoteWakeUp = 0;
+
+	exynos_usb_print_ep0_pkt((u8 *)&oUsbDev3.m_oDeviceRequest, 8);
+
+	// . sort Request type
+	//-------------------
+	switch(oUsbDev3.m_oDeviceRequest.bmRequestType & 0x60) {
+		case STANDARD_TYPE:
+			break;
+
+		case CLASS_TYPE:
+			DBG_USBD3("Class Type Request is not supported yet\n");
+			return;
+
+		case VENDOR_TYPE:
+			DBG_USBD3("Vendor Type Request is not supported yet\n");
+			return;
+
+		default:
+			DBG_USBD3("0x%02x Type Request is not supported yet\n", oUsbDev3.m_oDeviceRequest.bmRequestType & 0x60);
+			return;
+	}
+
+	// . distinguish host2dev from dev2host
+	if (oUsbDev3.m_oDeviceRequest.bmRequestType & 0x80)
+		oUsbDev3.m_uEp0State = EP0_STATE_IN_DATA_PHASE;
+	else
+		oUsbDev3.m_uEp0State = EP0_STATE_OUT_DATA_PHASE;
+
+	// . find requestlength and decide whether control xfer is 2 stage or 3 stage
+	oUsbDev3.m_uDeviceRequestLength = (u32)((oUsbDev3.m_oDeviceRequest.wLength_H << 8) | oUsbDev3.m_oDeviceRequest.wLength_L);
+
+	oUsbDev3.m_bEp0ThreeStage = 1;
+
+	if (oUsbDev3.m_uDeviceRequestLength == 0)
+	{
+		oUsbDev3.m_uEp0State = EP0_STATE_IN_WAIT_NRDY;
+		oUsbDev3.m_bEp0ThreeStage = 0;
+	}
+
+
+	// . handle standard type request
+	//-----------------------------
+	switch(oUsbDev3.m_oDeviceRequest.bRequest) {
+		case STANDARD_SET_ADDRESS:
+			usbdev3_dcfg.data = readl(rDCFG);
+			usbdev3_dcfg.b.dev_addr = oUsbDev3.m_oDeviceRequest.wValue_L;
+			writel(usbdev3_dcfg.data, rDCFG);
+
+			DBG_USBD3("\n MCU >> Set Address : %d \n", usbdev3_dcfg.b.dev_addr);
+
+			oUsbDev3.m_eUsbDev3State = USBDEV3_STATE_ADDRESSED;
+			break;
+
+		case STANDARD_SET_DESCRIPTOR:
+			DBG_USBD3("\n MCU >> Set Descriptor \n");
+			break;
+
+		case STANDARD_SET_CONFIGURATION:
+			DBG_USBD3("\n MCU >> Set Configuration \n");
+			if (oUsbDev3.m_eSpeed == USBDEV3_SPEED_SUPER)
+				printf("Super speed enumeration success\n");
+			g_usConfig = oUsbDev3.m_oDeviceRequest.wValue_L; // Configuration value in configuration descriptor
+			oUsbDev3.m_eUsbDev3State = USBDEV3_STATE_CONFIGURED;
+
+			// . to activate endpoints for bulk xfer
+			exynos_usb_activate_ep(USBDEV3_EP_DIR_IN, BULK_IN_EP);
+			exynos_usb_activate_ep(USBDEV3_EP_DIR_OUT, BULK_OUT_EP);
+
+			// . to enable endpoints for bulk xfer
+			exynos_usb_enable_ep(USBDEV3_EP_DIR_IN, BULK_IN_EP);
+			exynos_usb_enable_ep(USBDEV3_EP_DIR_OUT, BULK_OUT_EP);
+
+			exynos_usb_prepare_1st_bulk_out_trb();
+			break;
+
+		case STANDARD_GET_CONFIGURATION:
+			exynos_usb_start_ep0_in_xfer((u32)&g_usConfig, 1);
+			break;
+
+		case STANDARD_GET_DESCRIPTOR:
+			switch (oUsbDev3.m_oDeviceRequest.wValue_H)
+			{
+				case DEVICE_DESCRIPTOR:
+					oUsbDev3.m_uDeviceRequestLength = (u32)((oUsbDev3.m_oDeviceRequest.wLength_H << 8) |
+						oUsbDev3.m_oDeviceRequest.wLength_L);
+					DBG_USBD3("\n MCU >> Get Device Descriptor = 0x%x \n",oUsbDev3.m_uDeviceRequestLength);
+
+					if (oUsbDev3.m_uDeviceRequestLength<=DEVICE_DESC_SIZE)
+					{
+						exynos_usb_start_ep0_in_xfer(((u32)&(oUsbDev3.m_oDesc.oDescDevice))+0, oUsbDev3.m_uDeviceRequestLength);
+					}
+					else
+					{
+						exynos_usb_start_ep0_in_xfer(((u32)&(oUsbDev3.m_oDesc.oDescDevice))+0, DEVICE_DESC_SIZE);
+					}
+					break;
+
+				case CONFIGURATION_DESCRIPTOR:
+					oUsbDev3.m_uDeviceRequestLength = (u32)((oUsbDev3.m_oDeviceRequest.wLength_H << 8) |
+						oUsbDev3.m_oDeviceRequest.wLength_L);
+					DBG_USBD3("\n MCU >> Get Configuration Descriptor = 0x%x \n",oUsbDev3.m_uDeviceRequestLength);
+
+					if (oUsbDev3.m_uDeviceRequestLength > CONFIG_DESC_SIZE){
+					// === GET_DESCRIPTOR:CONFIGURATION+INTERFACE+ENDPOINT0+ENDPOINT1 ===
+					// Windows98 gets these 4 descriptors all together by issuing only a request.
+					// Windows2000 gets each descriptor seperately.
+					// oUsbDev3.m_uEpZeroTransferLength = CONFIG_DESC_TOTAL_SIZE;
+						if(oUsbDev3.m_uDeviceRequestLength<=oUsbDev3.m_oDesc.oDescConfig.wTotalLengthL)
+						{
+							exynos_usb_start_ep0_in_xfer(((u32)&(oUsbDev3.m_oDesc.oDescConfig))+0, oUsbDev3.m_uDeviceRequestLength);
+						}
+						else
+						{
+							exynos_usb_start_ep0_in_xfer(((u32)&(oUsbDev3.m_oDesc.oDescConfig))+0, oUsbDev3.m_oDesc.oDescConfig.wTotalLengthL);
+						}
+					}
+					else		// for win2k
+					{
+						if(oUsbDev3.m_uDeviceRequestLength<=CONFIG_DESC_SIZE)
+						{
+							exynos_usb_start_ep0_in_xfer(((u32)&(oUsbDev3.m_oDesc.oDescConfig))+0, oUsbDev3.m_uDeviceRequestLength);
+						}
+						else
+						{
+							exynos_usb_start_ep0_in_xfer(((u32)&(oUsbDev3.m_oDesc.oDescConfig))+0, CONFIG_DESC_SIZE);
+						}
+					}
+					break;
+
+				case STRING_DESCRIPTOR :
+					DBG_USBD3("\n MCU >> Get String Descriptor \n");
+					if (is_fastboot) {
+						string_desc1 = fboot_string_desc1;
+						string_desc2 = fboot_string_desc2;
+						string_desc3 = fboot_string_desc3;
+					} else {
+						string_desc1 = dnw_string_desc1;
+						string_desc2 = dnw_string_desc2;
+					}
+
+					switch(oUsbDev3.m_oDeviceRequest.wValue_L)
+					{
+						case 0:
+							exynos_usb_start_ep0_in_xfer((u32)string_desc0, STRING_DESC0_SIZE);
+							break;
+						case 1:
+							exynos_usb_start_ep0_in_xfer((u32)string_desc1, STRING_DESC1_SIZE);
+							break;
+						case 2:
+							exynos_usb_start_ep0_in_xfer((u32)string_desc2, STRING_DESC2_SIZE);
+							break;
+						case 3:
+							exynos_usb_start_ep0_in_xfer((u32)string_desc2, STRING_DESC2_SIZE);
+							break;
+						default:
+								break;
+					}
+					break;
+
+				case ENDPOINT_DESCRIPTOR:
+					DBG_USBD3("\n MCU >> Get Endpoint Descriptor \n");
+					switch(oUsbDev3.m_oDeviceRequest.wValue_L&0xf)
+					{
+						case 0:
+							if (oUsbDev3.m_eSpeed == USBDEV3_SPEED_SUPER)
+								exynos_usb_start_ep0_in_xfer((u32)&(oUsbDev3.m_oSSDesc.oDescEp0), ENDPOINT_DESC_SIZE+ENDPOINT_COMP_DESC_SIZE);
+							else
+								exynos_usb_start_ep0_in_xfer((u32)&(oUsbDev3.m_oDesc.oDescEp0), ENDPOINT_DESC_SIZE);
+							break;
+						case 1:
+							if (oUsbDev3.m_eSpeed == USBDEV3_SPEED_SUPER)
+								exynos_usb_start_ep0_in_xfer((u32)&(oUsbDev3.m_oSSDesc.oDescEp1), ENDPOINT_DESC_SIZE+ENDPOINT_COMP_DESC_SIZE);
+							else
+								exynos_usb_start_ep0_in_xfer((u32)&(oUsbDev3.m_oDesc.oDescEp1), ENDPOINT_DESC_SIZE);
+							break;
+						default:
+							break;
+					}
+					break;
+
+				case DEVICE_QUALIFIER:	// only supported in over 2.0
+					oUsbDev3.m_uDeviceRequestLength = (u32)((oUsbDev3.m_oDeviceRequest.wLength_H << 8) |
+						oUsbDev3.m_oDeviceRequest.wLength_L);
+					DBG_USBD3("\n MCU >> Get Device Qualifier Descriptor = 0x%x \n",oUsbDev3.m_uDeviceRequestLength);
+
+					if(oUsbDev3.m_uDeviceRequestLength<=10)
+					{
+						exynos_usb_start_ep0_in_xfer((u32)qualifier_desc, oUsbDev3.m_uDeviceRequestLength);
+					}
+					else
+					{
+						exynos_usb_start_ep0_in_xfer((u32)qualifier_desc, 10);
+					}
+					break;
+
+				case OTHER_SPEED_CONFIGURATION :
+					DBG_USBD3(("\n MCU >> Get OTHER_SPEED_CONFIGURATION \n"));
+					oUsbDev3.m_uDeviceRequestLength = (u32)((oUsbDev3.m_oDeviceRequest.wLength_H << 8) |
+						oUsbDev3.m_oDeviceRequest.wLength_L);
+
+					if (oUsbDev3.m_eSpeed == USBDEV3_SPEED_HIGH)
+					{
+						if (oUsbDev3.m_uDeviceRequestLength ==9)
+						{
+							exynos_usb_start_ep0_in_xfer((u32)config_high, 9);
+						}
+						else if(oUsbDev3.m_uDeviceRequestLength ==32)
+						{
+							exynos_usb_start_ep0_in_xfer((u32)config_high_total, 32);
+						}
+					}
+					else if (oUsbDev3.m_eSpeed == USBDEV3_SPEED_FULL)
+					{
+						if (oUsbDev3.m_uDeviceRequestLength ==9)
+						{
+							exynos_usb_start_ep0_in_xfer((u32)config_full, 9);
+						}
+						else if(oUsbDev3.m_uDeviceRequestLength ==32)
+						{
+							exynos_usb_start_ep0_in_xfer((u32)config_full_total, 32);
+						}
+					}
+					else	// super
+					{
+						DBG_USBD3("\n %s(line %d)\n", __FILE__, __LINE__);
+						DBG_USBD3("Error : Not implemented yet\n");
+					}
+
+					break;
+				case BOS :
+					if (oUsbDev3.m_uDeviceRequestLength == BOS_DESC_SIZE)
+						exynos_usb_start_ep0_in_xfer((u32)&oUsbDev3.m_oSSDesc.oDescBos, BOS_DESC_SIZE);
+					else
+						exynos_usb_start_ep0_in_xfer((u32)&oUsbDev3.m_oSSDesc.oDescBos, BOS_DESC_TOTAL_SIZE);
+					break;
+			}
+			break;
+
+		case STANDARD_CLEAR_FEATURE:
+			DBG_USBD3("\n MCU >> Clear Feature \n");
+			switch (oUsbDev3.m_oDeviceRequest.bmRequestType)
+			{
+				case DEVICE_RECIPIENT:
+					if (oUsbDev3.m_oDeviceRequest.wValue_L == 1)
+						uRemoteWakeUp = 0;
+					break;
+
+				case ENDPOINT_RECIPIENT:
+					if (oUsbDev3.m_oDeviceRequest.wValue_L == 0)
+					{
+						if ((oUsbDev3.m_oDeviceRequest.wIndex_L & 0x7f) == CONTROL_EP)
+							oStatusGet.EndpointCtrl= 0;
+
+						if ((oUsbDev3.m_oDeviceRequest.wIndex_L & 0x7f) == BULK_IN_EP) // IN  Endpoint
+							oStatusGet.EndpointIn= 0;
+
+						if ((oUsbDev3.m_oDeviceRequest.wIndex_L & 0x7f) == BULK_OUT_EP) // OUT Endpoint
+							oStatusGet.EndpointOut= 0;
+					}
+					break;
+
+				default:
+					break;
+			}
+			break;
+
+		case STANDARD_SET_FEATURE:
+			DBG_USBD3("\n MCU >> Set Feature \n");
+			switch (oUsbDev3.m_oDeviceRequest.bmRequestType)
+			{
+				case DEVICE_RECIPIENT:
+					if (oUsbDev3.m_oDeviceRequest.wValue_L == 1)
+						uRemoteWakeUp = 1;
+						break;
+
+				case ENDPOINT_RECIPIENT:
+					if (oUsbDev3.m_oDeviceRequest.wValue_L == 0)
+					{
+						if ((oUsbDev3.m_oDeviceRequest.wIndex_L & 0x7f) == CONTROL_EP)
+							oStatusGet.EndpointCtrl= 1;
+
+						if ((oUsbDev3.m_oDeviceRequest.wIndex_L & 0x7f) == BULK_IN_EP)
+							oStatusGet.EndpointIn= 1;
+
+						if ((oUsbDev3.m_oDeviceRequest.wIndex_L & 0x7f) == BULK_OUT_EP)
+							oStatusGet.EndpointOut= 1;
+					}
+					break;
+
+				default:
+					break;
+			}
+
+			//=======================================================
+
+			switch (oUsbDev3.m_oDeviceRequest.wValue_L) {
+
+				case EP_STALL:
+					// TBD: additional processing if required
+					break;
+
+
+				case TEST_MODE:
+					if ((0 != oUsbDev3.m_oDeviceRequest.wIndex_L ) ||(0 != oUsbDev3.m_oDeviceRequest.bmRequestType))
+					{
+						DBG_USBD3("\n %s(line %d)\n", __FILE__, __LINE__);
+						DBG_USBD3("Error : Wrong Request Parameter\n");
+						break;
+					}
+
+					switch(oUsbDev3.m_oDeviceRequest.wIndex_H)
+					{
+						usbdev3_dctl_t usbdev3_dctl;
+
+						case TEST_J:
+							//Set Test J
+							exynos_usb_start_ep0_in_xfer((u32)NULL, 0);
+							DBG_USBD3 ("Test_J\n");
+							usbdev3_dctl.data = readl(rDCTL);
+							usbdev3_dctl.b.test_ctrl = (u32)DCTL_TEST_J_MODE;
+							writel(usbdev3_dctl.data, rDCTL);
+							break;
+
+						case TEST_K:
+							//Set Test K
+							exynos_usb_start_ep0_in_xfer((u32)NULL, 0);
+							DBG_USBD3 ("Test_K\n");
+							usbdev3_dctl.data = readl(rDCTL);
+							usbdev3_dctl.b.test_ctrl = (u32)DCTL_TEST_K_MODE;
+							writel(usbdev3_dctl.data, rDCTL);
+							break;
+
+						case TEST_SE0_NAK:
+							//Set Test SE0_NAK
+							exynos_usb_start_ep0_in_xfer((u32)NULL, 0);
+							DBG_USBD3 ("Test_SE0_NAK\n");
+							usbdev3_dctl.data = readl(rDCTL);
+							usbdev3_dctl.b.test_ctrl = (u32)DCTL_TEST_SE0_NAK_MODE;
+							writel(usbdev3_dctl.data, rDCTL);
+							break;
+
+						case TEST_PACKET:
+							//Set Test Packet
+							exynos_usb_start_ep0_in_xfer((u32)NULL, 0);
+
+							// khs. Is this routine necessary?
+							//exynos_usb_start_ep0_in_xfer((u32)TestPkt, TEST_PKT_SIZE);
+
+							DBG_USBD3 ("Test_Packet\n");
+							usbdev3_dctl.data = readl(rDCTL);
+							usbdev3_dctl.b.test_ctrl = (u32)DCTL_TEST_PACKET_MODE;
+							writel(usbdev3_dctl.data, rDCTL);
+							break;
+
+						case TEST_FORCE_ENABLE:
+							//Set Test Force Enable
+							exynos_usb_start_ep0_in_xfer((u32)NULL, 0);
+							DBG_USBD3 ("Test_Force_Enable\n");
+							usbdev3_dctl.data = readl(rDCTL);
+							usbdev3_dctl.b.test_ctrl = (u32)DCTL_TEST_FORCE_ENABLE;
+							writel(usbdev3_dctl.data, rDCTL);
+							break;
+					}
+
+					break;
+
+				default:
+					break;
+			}
+			//=======================================================
+			break;
+
+		case STANDARD_GET_STATUS:
+			switch(oUsbDev3.m_oDeviceRequest.bmRequestType)
+			{
+				case  (0x80):	//device
+					oStatusGet.Device=((u8)uRemoteWakeUp<<1)|0x1;		// SelfPowered
+					exynos_usb_start_ep0_in_xfer((u32)&oStatusGet.Device, 1);
+					break;
+
+				case  (0x81):	//interface
+					oStatusGet.Interface=0;
+					exynos_usb_start_ep0_in_xfer((u32)&oStatusGet.Interface, 1);
+					break;
+
+				case  (0x82):	//endpoint
+					if ((oUsbDev3.m_oDeviceRequest.wIndex_L & 0x7f) == CONTROL_EP)
+						exynos_usb_start_ep0_in_xfer((u32)&oStatusGet.EndpointCtrl, 1);
+
+					if ((oUsbDev3.m_oDeviceRequest.wIndex_L & 0x7f) == BULK_IN_EP)
+						exynos_usb_start_ep0_in_xfer((u32)&oStatusGet.EndpointIn, 1);
+
+					if ((oUsbDev3.m_oDeviceRequest.wIndex_L & 0x7f) == BULK_OUT_EP)
+						exynos_usb_start_ep0_in_xfer((u32)&oStatusGet.EndpointOut, 1);
+					break;
+
+				default:
+					break;
+			}
+			break;
+
+		case STANDARD_GET_INTERFACE:
+			exynos_usb_start_ep0_in_xfer((u32)&oInterfaceGet.AlternateSetting, 1);
+			break;
+
+		case STANDARD_SET_INTERFACE:
+			oInterfaceGet.AlternateSetting= oUsbDev3.m_oDeviceRequest.wValue_L;
+			break;
+
+		case STANDARD_SYNCH_FRAME:
+			break;
+
+		case STANDARD_SET_SEL:
+			oUsbDev3.m_bReq_Set_sel= 1;
+			/* For SET_SEL */
+			exynos_usb_start_ep0_out_xfer((u32)&set_sel, oUsbDev3.m_uControlEPMaxPktSize);
+			DBG_USBD3("Standard Req : SET SEL\n");
+			break;
+
+		case STANDARD_ISOCH_DELY:
+			DBG_USBD3("Standard Req : ISOCH Delay\n");
+			break;
+
+		default:
+			DBG_USBD3("\n %s(line %d)\n", __FILE__, __LINE__);
+			DBG_USBD3("Error : This Request(%d) is not implemented yet\n", oUsbDev3.m_oDeviceRequest.bRequest);
+			break;
+	}
+}
+
+static void exynos_usb_handle_ep0_out_xfer_complete(void)
+{
+	switch (oUsbDev3.m_uEp0State) {
+		case EP0_STATE_INIT:
+			exynos_usb_handle_setup();
+			break;
+
+		case EP0_STATE_OUT_DATA_PHASE:
+			oUsbDev3.m_uEp0State = EP0_STATE_IN_WAIT_NRDY;
+			break;
+
+		case EP0_STATE_OUT_STATUS_PHASE:
+			oUsbDev3.m_uEp0State = EP0_STATE_INIT;
+
+			// . to start EP0 to receive SETUP packets
+			//----------------------------------
+			if (!exynos_usb_start_ep0_setup_rx())
+			{
+				return;
+			}
+			break;
+
+		// khs. this routine is abnormal case, and handling for this case is not prepared.
+		default :
+			DBG_USBD3("\nError : [EP0-OutXferComplete]Not Supported @%d\n", oUsbDev3.m_uEp0State);
+			break;
+	}
+
+}
+
+static void exynos_usb_handle_ep_out_xfer_complete(void)
+{
+	u16	usRxCnt;
+	u16 usCheck;
+	u32 usCapTrbBufSiz;
+	u32 uLastBufSize;
+	u32 i=0;
+	usbdev3_trb_ptr_t pBulkOutTrb;
+	usbdev3_trb_ptr_t pBulkInTrb;
+	usbdev3_trb_ctrl_t usbdev3_trb_ctrl;
+
+	if (g_uCntOfDescOutComplete == 0)
+	{
+		// Check whether TRB was finished successfully or not
+		if ((g_pBulkOutTrb0->control.b.hwo != 0)||(g_pBulkOutTrb0->status.b.trb_sts != 0))
+		{
+			Assert(0);
+		}
+
+		g_uCntOfDescOutComplete++;
+
+		usRxCnt = oUsbDev3.m_uBulkEPMaxPktSize - g_pBulkOutTrb0->status.b.buf_siz;
+
+		exynos_usb_free((u32)g_pBulkOutTrb0);
+
+		if (usRxCnt == 10)		//Upload Request
+		{
+			usCheck = *((u8 *)(g_ucTempDownBuf+8)) + (*((u8 *)(g_ucTempDownBuf+9))<<8);
+
+			if (usCheck == 0x1)
+			{
+				oUsbDev3.m_uUploadAddr =
+					*((u8 *)(g_ucTempDownBuf+0))+
+					(*((u8 *)(g_ucTempDownBuf+1))<<8)+
+					(*((u8 *)(g_ucTempDownBuf+2))<<16)+
+					(*((u8 *)(g_ucTempDownBuf+3))<<24);
+
+				oUsbDev3.m_uUploadSize =
+					*((u8 *)(g_ucTempDownBuf+4))+
+					(*((u8 *)(g_ucTempDownBuf+5))<<8)+
+					(*((u8 *)(g_ucTempDownBuf+6))<<16)+
+					(*((u8 *)(g_ucTempDownBuf+7))<<24);
+
+				exynos_usb_free((u32)g_ucTempDownBuf);
+
+				oUsbDev3.m_pUpPt=(u8 *)oUsbDev3.m_uUploadAddr;
+
+				DBG_USBD3("UploadAddress : 0x%x, UploadSize: %d\n", oUsbDev3.m_uUploadAddr, oUsbDev3.m_uUploadSize);
+
+				if (oUsbDev3.m_uUploadSize>0)
+				{
+					DBG_USBD3("Dma Start for IN PKT \n");
+
+					// buffer_size of TRB should be
+					usCapTrbBufSiz = TRB_BUF_SIZ_LIMIT/oUsbDev3.m_uBulkEPMaxPktSize*oUsbDev3.m_uBulkEPMaxPktSize;
+
+					g_uCntOfBulkInTrb = oUsbDev3.m_uUploadSize/usCapTrbBufSiz;
+
+					if ((oUsbDev3.m_uUploadSize%usCapTrbBufSiz) != 0)
+					{
+						g_uCntOfBulkInTrb++;
+					}
+
+					g_pBulkInTrbArray_Base = (usbdev3_trb_ptr_t)exynos_usb_malloc(g_uCntOfBulkInTrb*sizeof(usbdev3_trb_t), USBDEV3_MDWIDTH/8);
+
+					if (g_pBulkInTrbArray_Base == NULL)
+					{
+						Assert(0);
+					}
+
+					pBulkInTrb = g_pBulkInTrbArray_Base;
+
+
+					// . fill the Trbs
+					//------------------
+					// (Total Buffer size must be in terms of multiple of Max Packet Size)
+					usbdev3_trb_ctrl.data = 0;
+					usbdev3_trb_ctrl.b.lst = 0;
+					usbdev3_trb_ctrl.b.chn = 1;
+					usbdev3_trb_ctrl.b.csp = 0;
+					usbdev3_trb_ctrl.b.trb_ctrl = (u32)TRB_CTRL_NORMAL;
+					usbdev3_trb_ctrl.b.isp_imi = 1;
+					usbdev3_trb_ctrl.b.ioc = 0;
+					usbdev3_trb_ctrl.b.strmid_sofn = 0;
+					for(i=0;i<(g_uCntOfBulkInTrb-1);i++)
+					{
+						exynos_usb_fill_trb(pBulkInTrb, (u32)(oUsbDev3.m_pUpPt+usCapTrbBufSiz*i), usCapTrbBufSiz, usbdev3_trb_ctrl.data, 1);
+						pBulkInTrb++;
+					}
+
+					// i = g_uCntOfBulkInTrb-1, last Trb
+					usbdev3_trb_ctrl.b.lst = 1;
+					usbdev3_trb_ctrl.b.chn = 0;
+					usbdev3_trb_ctrl.b.ioc = 1;
+					uLastBufSize = oUsbDev3.m_uUploadSize-usCapTrbBufSiz*i;
+					exynos_usb_fill_trb(pBulkInTrb, (u32)(oUsbDev3.m_pUpPt+usCapTrbBufSiz*i), uLastBufSize, usbdev3_trb_ctrl.data, 1);
+					//
+					////
+
+					// . Issue Start Xfer for Bulk In Xfer
+					//----------------------------
+					if (!exynos_usb_start_ep_xfer(USBDEV3_EP_DIR_IN, BULK_IN_EP, (u32)g_pBulkInTrbArray_Base, 0, &oUsbDev3.m_uTriIn[BULK_IN_EP]))
+					{
+						return;
+					}
+				}
+			}
+			else
+			{
+				Assert(0);
+			}
+		}
+		else		//Download Request
+		{
+			oUsbDev3.m_uDownloadAddress =
+					*((u8 *)(g_ucTempDownBuf+0))+
+					(*((u8 *)(g_ucTempDownBuf+1))<<8)+
+					(*((u8 *)(g_ucTempDownBuf+2))<<16)+
+					(*((u8 *)(g_ucTempDownBuf+3))<<24);
+			oUsbDev3.m_uDownloadFileSize =
+				*((u8 *)(g_ucTempDownBuf+4))+
+				(*((u8 *)(g_ucTempDownBuf+5))<<8)+
+				(*((u8 *)(g_ucTempDownBuf+6))<<16)+
+				(*((u8 *)(g_ucTempDownBuf+7))<<24);
+
+			if (exynos_usbd_dn_addr)
+			{
+				oUsbDev3.m_uDownloadAddress = exynos_usbd_dn_addr;		// Request usb down Addr
+			}
+
+			oUsbDev3.m_pDownPt=(u8 *)oUsbDev3.m_uDownloadAddress;
+
+			DBG_USBD3("downloadAddress : 0x%x, downloadFileSize: %d\n", oUsbDev3.m_uDownloadAddress, oUsbDev3.m_uDownloadFileSize);
+
+			memcpy((void *)oUsbDev3.m_pDownPt, (void *)(g_ucTempDownBuf+8), usRxCnt-8);
+
+			exynos_usb_free((u32)g_ucTempDownBuf);
+
+			oUsbDev3.m_pDownPt += usRxCnt-8;
+
+			if (oUsbDev3.m_uDownloadFileSize>usRxCnt)	//there are more data to be received
+			{
+
+				usCapTrbBufSiz = TRB_BUF_SIZ_LIMIT/oUsbDev3.m_uBulkEPMaxPktSize*oUsbDev3.m_uBulkEPMaxPktSize;
+
+				g_uCntOfBulkOutTrb = (oUsbDev3.m_uDownloadFileSize-usRxCnt)/usCapTrbBufSiz;
+
+				if ((oUsbDev3.m_uDownloadFileSize-usRxCnt)%usCapTrbBufSiz != 0)
+				{
+					g_uCntOfBulkOutTrb++;
+				}
+
+				g_pBulkOutTrbArray_Base = (usbdev3_trb_ptr_t)exynos_usb_malloc(g_uCntOfBulkOutTrb*sizeof(usbdev3_trb_t), USBDEV3_MDWIDTH/8);
+
+				if (g_pBulkOutTrbArray_Base == NULL)
+				{
+					Assert(0);
+				}
+
+				pBulkOutTrb = (usbdev3_trb_ptr_t)virt_to_phys((void *)g_pBulkOutTrbArray_Base);
+
+				// . fill the Trbs
+				//------------------
+				// (Total Buffer size must be in terms of multiple of Max Packet Size)
+				usbdev3_trb_ctrl.data = 0;
+				usbdev3_trb_ctrl.b.lst = 0;
+				usbdev3_trb_ctrl.b.chn = 1;
+				usbdev3_trb_ctrl.b.csp = 0;
+				usbdev3_trb_ctrl.b.trb_ctrl = (u32)TRB_CTRL_NORMAL;
+				usbdev3_trb_ctrl.b.isp_imi = 1;
+				usbdev3_trb_ctrl.b.ioc = 0;
+				usbdev3_trb_ctrl.b.strmid_sofn = 0;
+
+				for(i=0;i<(g_uCntOfBulkOutTrb-1);i++)
+				{
+					exynos_usb_fill_trb(pBulkOutTrb, (u32)(oUsbDev3.m_pDownPt+usCapTrbBufSiz*i), usCapTrbBufSiz, usbdev3_trb_ctrl.data, 1);
+					pBulkOutTrb++;
+				}
+
+				// i = g_uCntOfBulkOutTrb-1, last Trb
+				usbdev3_trb_ctrl.b.lst = 1;
+				usbdev3_trb_ctrl.b.chn = 0;
+				usbdev3_trb_ctrl.b.ioc = 1;
+				uLastBufSize = (oUsbDev3.m_uDownloadFileSize-usRxCnt)-usCapTrbBufSiz*i;
+				uLastBufSize = ((uLastBufSize+oUsbDev3.m_uBulkEPMaxPktSize-1)/oUsbDev3.m_uBulkEPMaxPktSize)*oUsbDev3.m_uBulkEPMaxPktSize;
+				exynos_usb_fill_trb(pBulkOutTrb, (u32)(oUsbDev3.m_pDownPt+usCapTrbBufSiz*i), uLastBufSize, usbdev3_trb_ctrl.data, 1);
+				//
+				////
+
+				// . Issue Start Xfer for Bulk Out Xfer
+				//----------------------------
+				if (!exynos_usb_start_ep_xfer(USBDEV3_EP_DIR_OUT, BULK_OUT_EP, (u32)g_pBulkOutTrbArray_Base, 0, &oUsbDev3.m_uTriOut[BULK_OUT_EP]))
+				{
+					return;
+				}
+			}
+			else		//there are no more data
+			{
+				g_uCntOfDescOutComplete = 0;
+
+				exynos_receive_done = 1;
+
+				DBG_USBD3("DMA OUT : Transfer Complete\n");
+			}
+		}
+	}
+	else
+	{
+		g_uCntOfDescOutComplete = 0;
+
+		exynos_receive_done = 1;
+
+		exynos_usb_free((u32)g_pBulkOutTrbArray_Base);
+
+		oUsbDev3.m_pDownPt += (oUsbDev3.m_uDownloadFileSize - 8);
+
+		printf("Download Done!! Download Address: 0x%x, Download Filesize:0x%x\n",
+				oUsbDev3.m_uDownloadAddress, (oUsbDev3.m_uDownloadFileSize-10));
+	}
+}
+
+static void exynos_usb_handle_ep0_out_xfer_not_ready(void)
+{
+	switch (oUsbDev3.m_uEp0State) {
+		case EP0_STATE_OUT_WAIT_NRDY:
+			// . to setup out-status phase
+			exynos_usb_setup_out_status_phase();
+			break;
+		// khs. this routine is abnormal case, and handling for this case is not prepared.
+		default :
+			DBG_USBD3("\nError : [EP0-OutXferNotReady]Not Supported @%d\n", oUsbDev3.m_uEp0State);
+			break;
+	}
+}
+
+static void exynos_usb_handle_ep_out_event(usbdev3_depevt_t uEpOutEvent)
+{
+	u32 uEpNum = uEpOutEvent.b.ep_num/2;	// 0,2,4,6,...
+
+	DBG_USBD3("[EP%d] Out State = 0x%x Type = 0x%x[0x%x]\n", uEpNum, oUsbDev3.m_uEp0State, uEpOutEvent.b.evt_type, uEpOutEvent.data);
+	switch (uEpOutEvent.b.evt_type)
+	{
+		case DEPEVT_EVT_XFER_CMPL:
+			DBG_USBD3("[EP%d] OUT xfer complete @%d\n", uEpNum, oUsbDev3.m_uEp0State);
+			if (uEpNum == 0)
+				exynos_usb_handle_ep0_out_xfer_complete();
+			else if (uEpNum == BULK_OUT_EP) {
+				if (is_fastboot)
+					fboot_usb_handle_ep_out_xfer_complete();
+				else
+					exynos_usb_handle_ep_out_xfer_complete();
+			} else
+				Assert(0);
+			break;
+
+		case DEPEVT_EVT_XFER_IN_PROG:
+			DBG_USBD3("[EP%d] OUT xfer in progress @%d\n", uEpNum, oUsbDev3.m_uEp0State);
+			break;
+
+		case DEPEVT_EVT_XFER_NRDY:
+			DBG_USBD3("[EP%d] OUT xfer not ready @%d\n", uEpNum, oUsbDev3.m_uEp0State);
+			if (uEpNum == 0)
+				exynos_usb_handle_ep0_out_xfer_not_ready();
+			else
+				;//
+			break;
+
+		case DEPEVT_EVT_FIFOXRUN:
+			DBG_USBD3("[EP%d] OUT FIFO Overrun Error @%d\n", uEpNum, oUsbDev3.m_uEp0State);
+			break;
+
+		case DEPEVT_EVT_STRM_EVT:
+			DBG_USBD3("[EP%d] OUT Stream Event @%d\n", uEpNum, oUsbDev3.m_uEp0State);
+			break;
+
+		case DEPEVT_EVT_EPCMD_CMPL:
+			DBG_USBD3("[EP%d] OUT Command Complete @%d\n", uEpNum, oUsbDev3.m_uEp0State);
+			break;
+
+		default:
+			DBG_USBD3("Unknown event!\n");
+	}
+
+}
+
+static void exynos_usb_handle_event(void)
+{
+	u16 uEventCount, uLoop=0;
+	u32 uEventBufferCopied;
+
+	// . Get Event Buffer Count
+	//----------------------
+	uEventCount = readl(rGEVNTCOUNT0);
+
+	uEventCount = uEventCount/4;
+
+	if (uEventCount == 0)
+	{
+		return;
+	}
+	else
+	{
+		DBG_USBD3("## Event Count is %d ##\n", uEventCount);
+	}
+
+	while((uEventCount--> 0) && (uLoop < USBDEV3_EVENT_BUFFER_COUNT))
+	{
+		if (oUsbDev3.m_CurrentEventPosition == USBDEV3_EVENT_BUFFER_COUNT)
+		{
+			oUsbDev3.m_CurrentEventPosition = 0;
+		}
+
+		uEventBufferCopied = *(oUsbDev3.m_pEventBuffer + oUsbDev3.m_CurrentEventPosition);	// to avoid that event buffer is overwritten.
+
+		uLoop++;
+		oUsbDev3.m_CurrentEventPosition++;
+
+		writel(4, rGEVNTCOUNT0);	// update event buffer count
+		// core update event buffer whenever event occurs
+		if (uEventBufferCopied == 0)
+		{
+			DBG_USBD3("## Null Event!##\n");
+		}
+		else		// event buffer contains event information
+		{
+			DBG_USBD3("\nLoop%d: Content of %dth Event Buffer is 0x%08x\n", uLoop, oUsbDev3.m_CurrentEventPosition, uEventBufferCopied);
+
+			// Device-Specific Event
+			if (uEventBufferCopied & 0x1)
+			{
+				usbdev3_devt_t usbdev3_devt;
+
+				usbdev3_devt.data = uEventBufferCopied;
+
+				//DBG_USBD3IntR("Device-Specific Event Occurred\n");
+
+				if (usbdev3_devt.b.dev_specific != 0)
+				{
+					DBG_USBD3("Other Core Event\n");
+				}
+
+				exynos_usb_handle_dev_event(usbdev3_devt);
+			}
+			else		// Device Endpoint-Specific Event
+			{
+				usbdev3_depevt_t usbdev3_depevt;
+				u32 uEpNum;
+
+				usbdev3_depevt.data = uEventBufferCopied;
+
+				uEpNum = usbdev3_depevt.b.ep_num;
+
+				if (uEpNum & 1)
+				{
+					DBG_USBD3("IN Endpoint%d Event Occurred\n", (uEpNum/2));
+					exynos_usb_handle_ep_in_event(usbdev3_depevt);
+				}
+				else
+				{
+					DBG_USBD3("OUT Endpoint%d Event Occurred\n", (uEpNum/2));
+					exynos_usb_handle_ep_out_event(usbdev3_depevt);
+				}
+			}
+		}
+	}
+}
+
+struct exynos_usb3_phy {
+	unsigned int reserve1;
+	unsigned int link_system;
+	unsigned int phy_utmi;
+	unsigned int phy_pipe;
+	unsigned int phy_clk_rst;
+	unsigned int phy_reg0;
+	unsigned int phy_reg1;
+	unsigned int phy_param0;
+	unsigned int phy_param1;
+	unsigned int phy_term;
+	unsigned int phy_test;
+	unsigned int phy_adp;
+	unsigned int phy_batchg;
+	unsigned int phy_resume;
+	unsigned int reserve2[3];
+	unsigned int link_port;
+};
+
+int exynos_usb_wait_cable_insert(void)
+{
+	u32 tmp1, tmp2;
+	char ch;
+	int ret = -1;
+	oUsbDev3.m_uPhyBaseRegs = USBDEVICE3_PHYCTRL_CH0_BASE;
+	tmp1 = readl(EXYNOS_PHY_ADP);
+	oUsbDev3.m_uPhyBaseRegs = USBDEVICE3_PHYCTRL_CH1_BASE;
+	tmp2 = readl(EXYNOS_PHY_ADP);
+	oUsbDev3.m_uPhyBaseRegs = 0;
+	if (tmp1 & 0x8 || tmp2 & 0x8) {
+		if(oUsbDev3.m_cable != CONNECTED) {
+			ch = (tmp1 & 0x8) ? 0 : 1;
+			printf("USB cable Connected![CH-%d]\n", ch);
+			ret = 0;
+			oUsbDev3.m_cable = CONNECTED;
+			if (!ch) {
+				oUsbDev3.m_uLinkBaseRegs = USBDEVICE3_LINK_CH0_BASE;
+				oUsbDev3.m_uPhyBaseRegs = USBDEVICE3_PHYCTRL_CH0_BASE;
+			} else {
+				oUsbDev3.m_uLinkBaseRegs = USBDEVICE3_LINK_CH1_BASE;
+				oUsbDev3.m_uPhyBaseRegs = USBDEVICE3_PHYCTRL_CH1_BASE;
+			}
+		}
+	} else {
+		if(oUsbDev3.m_cable == UNCHECKED) {
+			printf("Insert a USB cable into the connector!\n");
+			oUsbDev3.m_cable = DISCONNECTED;
+		} else if(oUsbDev3.m_cable == CONNECTED) {
+			oUsbDev3.m_cable = UNCHECKED;
+			exynos_usb_runstop_device(0);
+			is_fastboot = 0;
+		}
+	}
+	return ret;
+}
+
+int exynos_usbc_activate (void)
+{
+	exynos_usb_runstop_device(1);
+	return 0;
+}
+
+int exynos_usb_stop( void )
+{
+	if(oUsbDev3.m_cable == CONNECTED)
+		exynos_usb_runstop_device(0);
+
+	exynoy_usb_phy_off();
+	oUsbDev3.m_cable = UNCHECKED;
+
+	return 0;
+}
+
+int exynos_udc_int_hndlr(void)
+{
+	exynos_usb_handle_event();
+	return OK;
+}
+
+int exynos_usbctl_init(void)
+{
+	usbdev3_gusb2phycfg_t usbdev3_gusb2phycfg;
+	usbdev3_gusb3pipectl_t usbdev3_gusb3pipectl;
+	usbdev3_gctl_t usbdev3_gctl;
+	USBDEV3_SPEED_e eSpeed = USBDEV3_SPEED_SUPER;
+
+	// . to initialize variables for usb device
+	//--------------------------------
+	// khs. to be implemented more
+	oUsbDev3.m_eSpeed = eSpeed;
+	oUsbDev3.m_eUsbDev3State = USBDEV3_STATE_DEFAULT;
+	oUsbDev3.m_uEp0State = EP0_STATE_UNCONNECTED;
+	oUsbDev3.m_uEp0SubState = 0;
+	oUsbDev3.m_bEPs_Enabled = 0;
+	oUsbDev3.m_bReq_Set_sel = 0;
+	switch(eSpeed)
+	{
+		case USBDEV3_SPEED_SUPER:
+			oUsbDev3.m_uControlEPMaxPktSize = SUPER_SPEED_CONTROL_PKT_SIZE;
+			break;
+
+		case USBDEV3_SPEED_FULL:
+			oUsbDev3.m_uControlEPMaxPktSize = FULL_SPEED_CONTROL_PKT_SIZE;
+			break;
+
+		default :
+			oUsbDev3.m_uControlEPMaxPktSize = HIGH_SPEED_CONTROL_PKT_SIZE;
+			break;
+	}
+
+	// . to allocate initial buffers for usb device
+	//------------------------------------
+	oUsbDev3.m_pEventBuffer = (u32 *)exynos_usb_malloc(4*USBDEV3_EVENT_BUFFER_COUNT, USBDEV3_MDWIDTH/8);
+	oUsbDev3.m_uStatusBufAddr = exynos_usb_malloc(CTRL_BUF_SIZE, USBDEV3_MDWIDTH/8);
+	oUsbDev3.m_oSetupTrbPtr = (usbdev3_trb_ptr_t)exynos_usb_malloc(sizeof(usbdev3_trb_t), USBDEV3_MDWIDTH/8);
+	oUsbDev3.m_oOutTrbPtr = (usbdev3_trb_ptr_t)exynos_usb_malloc(sizeof(usbdev3_trb_t), USBDEV3_MDWIDTH/8);
+	oUsbDev3.m_oInTrbPtr = (usbdev3_trb_ptr_t)exynos_usb_malloc(sizeof(usbdev3_trb_t), USBDEV3_MDWIDTH/8);
+
+	// khs. ep_init 함수 호출을 통한 ep 별 structure 초기화 수행해야할까....?
+
+	// . to set AP system related to usb device (ex. clock source & gating, phy enable)
+	//--------------------------------------------------------------------
+	// - to enable a bus clock for usb dev controller & phy control block
+	//TODO: Enable system clock and so on.
+	/* USBDEV3_HclkUsb3ClkGate(true); */
+	/* USBDEV3_Usb3PhyEnable();		  // USB PHY Enable */
+	exynos_usb_phy_on();
+
+	/* EXYNOS5 EVT1 : PHY should be reset before global register configuration
+	   This sequence cover reset sequence on EXYNOS5 EVT0. */
+	exynos_usb_softreset_phy(1);
+	exynos_usb_init_phy();
+	exynos_usb_softreset_phy(0);
+
+	usbdev3_gusb2phycfg.data = readl(rGUSB2PHYCFG);
+	usbdev3_gusb2phycfg.b.suspend_usb2_phy = 0;
+	usbdev3_gusb2phycfg.b.enable_sleep_n = 0;
+	writel(usbdev3_gusb2phycfg.data, rGUSB2PHYCFG);
+
+	usbdev3_gusb3pipectl.data = readl(rGUSB3PIPECTL);
+	usbdev3_gusb3pipectl.b.suspend_usb3_ss_phy = 0;
+	writel(usbdev3_gusb3pipectl.data, rGUSB3PIPECTL);
+
+	// . to initialize usb device phy
+	//--------------------------
+	usbdev3_gctl.data = readl(rGCTL);
+	usbdev3_gctl.b.core_soft_reset = 1;	// to keep the core in reset state until phy clocks are stable(GCTL의 11번 bit 설명 참조)
+	/*
+	* WORKAROUND: DWC3 revisions <1.90a have a bug
+	* when The device fails to connect at SuperSpeed
+	* and falls back to high-speed mode which causes
+	* the device to enter in a Connect/Disconnect loop
+	*/
+	usbdev3_gctl.b.u2rst_ecn = 1;
+	writel(usbdev3_gctl.data, rGCTL);
+
+	usbdev3_gctl.data = readl(rGCTL);
+	usbdev3_gctl.b.core_soft_reset = 0;	// to keep the core out of reset state after phy clocks are stable(GCTL의 11번 bit 설명 참조)
+	writel(usbdev3_gctl.data, rGCTL);
+
+	usbdev3_gctl.b.pwr_down_scale = ((unsigned int)get_usbdrd_clk()) / 16000;
+	usbdev3_gctl.b.ram_clk_sel = 0; // 00:bus clock, 01:pipe clock, 10:pipe/2 clock
+	usbdev3_gctl.b.DisScramble = 0;
+	writel(usbdev3_gctl.data, rGCTL);
+
+	g_uCntOfDescOutComplete = 0;
+	is_fastboot = 0;
+	// . to initialize usb device controller
+	//------------------------------
+	if (exynos_usb_init_core(eSpeed))
+	{
+		DBG_USBD3("Exynos USB3 Core Init Fail\n");
+		return 0;
+	}
+
+	return 0;
+}
+#endif
diff --git a/drivers/usb/gadget/usbd3-ss.h b/drivers/usb/gadget/usbd3-ss.h
new file mode 100755
index 0000000000..6ac2a86a7f
--- /dev/null
+++ b/drivers/usb/gadget/usbd3-ss.h
@@ -0,0 +1,1178 @@
+/*
+ * drivers/usb/gadget/usbd3-ss.h
+ *
+ * (C) Copyright 2011
+ * Yulgon Kim, Samsung Erectronics, yulgon.kim@samsung.com.
+ *	- only support for S5PC510
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __EXYNOS_USBD_SS_H__
+#define __EXYNOS_USBD_SS_H__
+
+#include <asm/byteorder.h>
+#include <asm/arch/cpu.h>
+#include <mach/usb.h>
+#include <asm/io.h>
+
+//==========================
+// Define
+//==========================
+#define CONTROL_EP			0
+#define BULK_IN_EP			1
+#define BULK_OUT_EP			2
+#define TOTL_EP_COUNT			16
+
+#define USBDEV3_MDWIDTH			64	// master data bus width
+#define USBDEV3_DATA_BUF_SIZ		16384	// 16KB
+
+#define CMDCOMPLETEWAIT_UNIT		1000
+
+#define RX_FIFO_SIZE			1024
+#define NPTX_FIFO_START_ADDR		RX_FIFO_SIZE
+#define NPTX_FIFO_SIZE			256
+#define PTX_FIFO_SIZE			256
+
+#define CTRL_BUF_SIZE			128		//512
+
+// string descriptor
+#define LANGID_US_L			(0x09)
+#define LANGID_US_H			(0x04)
+
+// Feature Selectors
+#define EP_STALL          		0
+#define DEVICE_REMOTE_WAKEUP		1
+#define TEST_MODE			2
+
+/* Test Mode Selector*/
+#define TEST_J				1
+#define TEST_K				2
+#define TEST_SE0_NAK			3
+#define TEST_PACKET			4
+#define TEST_FORCE_ENABLE		5
+
+#define USB_DEVICE			0
+#define USB_HOST			1
+#define USB_OTG				2
+
+#define FULL_SPEED_CONTROL_PKT_SIZE	64
+#define FULL_SPEED_BULK_PKT_SIZE	64
+
+#define HIGH_SPEED_CONTROL_PKT_SIZE	64
+#define HIGH_SPEED_BULK_PKT_SIZE	512
+
+#define SUPER_SPEED_CONTROL_PKT_EXP_SZ	9	// 2^9 = 512
+#define SUPER_SPEED_CONTROL_PKT_SIZE	512
+#define SUPER_SPEED_BULK_PKT_SIZE	1024
+
+typedef struct {
+	u8 bLength;
+	u8 bDescriptorType;
+	u8 bcdUSBL;
+	u8 bcdUSBH;
+	u8 bDeviceClass;
+	u8 bDeviceSubClass;
+	u8 bDeviceProtocol;
+	u8 bMaxPacketSize0;
+	u8 idVendorL;
+	u8 idVendorH;
+	u8 idProductL;
+	u8 idProductH;
+	u8 bcdDeviceL;
+	u8 bcdDeviceH;
+	u8 iManufacturer;
+	u8 iProduct;
+	u8 iSerialNumber;
+	u8 bNumConfigurations;
+} USB_DEVICE_DESCRIPTOR;
+
+typedef struct {
+	u8 bLength;
+	u8 bDescriptorType;
+	u8 wTotalLengthL;
+	u8 wTotalLengthH;
+	u8 bNumInterfaces;
+	u8 bConfigurationValue;
+	u8 iConfiguration;
+	u8 bmAttributes;
+	u8 maxPower;
+} USB_CONFIGURATION_DESCRIPTOR;
+
+typedef struct {
+	u8 bLength;
+	u8 bDescriptorType;
+	u8 bInterfaceNumber;
+	u8 bAlternateSetting;
+	u8 bNumEndpoints;
+	u8 bInterfaceClass;
+	u8 bInterfaceSubClass;
+	u8 bInterfaceProtocol;
+	u8 iInterface;
+} USB_INTERFACE_DESCRIPTOR;
+
+typedef struct {
+	u8 bLength;
+	u8 bDescriptorType;
+	u8 bEndpointAddress;
+	u8 bmAttributes;
+	u8 wMaxPacketSizeL;
+	u8 wMaxPacketSizeH;
+	u8 bInterval;
+} USB_ENDPOINT_DESCRIPTOR;
+
+typedef struct {
+	u8  bLength;
+	u8  bDescriptorType;
+	u8  bMaxBurst;
+	u8  bmAttributes;
+	u16 wBytesPerInterval;
+} __attribute__ ((packed)) USB_SS_EP_COMP_DESCRIPTOR;
+
+typedef struct {
+	u8 bLength;
+	u8 bDescriptorType;
+	u8 *pString;
+} USB_STRING_DESCRIPTOR;
+
+typedef struct {
+	__u8 bLength;
+	__u8 bDescriptorType;
+	__le16 wTotalLength;
+	__u8 bNumDeviceCaps;
+} __attribute__ ((packed)) USB_BOS_DESCRIPTOR;
+
+typedef struct {
+	__u8 bLength;
+	__u8 bDescriptorType;
+	__u8 bDevCapabilityType;
+	__le32 bmAttributes;
+} __attribute__ ((packed)) USB20_EXT_CAP_DESCRIPTOR;
+
+typedef struct {
+	__u8 bLength;
+	__u8 bDescriptorType;
+	__u8 bDevCapabilityType;
+	__u8 bmAttributes;
+	__le16 wSpeedsSupported;
+	__u8 bFunctionalitySupport;
+	__u8 bU1DevExitLat;
+	__le16 wU2DevExitLat;
+} __attribute__ ((packed)) USB_SUPERSPEED_CAP_DESCRIPTOR;
+
+typedef struct {
+	__u8 bLength;
+	__u8 bDescriptorType;
+	__u8 bDevCapabilityType;
+	__u8 bReserved;
+	__u8 containerID[16];
+} __attribute__ ((packed)) USB_CONTAINER_ID_CAP_DESCRIPTOR;
+
+typedef struct {
+	USB_DEVICE_DESCRIPTOR oDescDevice;
+	USB_CONFIGURATION_DESCRIPTOR oDescConfig;
+	USB_INTERFACE_DESCRIPTOR oDescInterface;
+	USB_ENDPOINT_DESCRIPTOR oDescEp0;
+	USB_ENDPOINT_DESCRIPTOR oDescEp1;
+	USB_ENDPOINT_DESCRIPTOR oDescEp2;
+	USB_ENDPOINT_DESCRIPTOR oDescEp3;
+} __attribute__ ((packed)) USB_DESCRIPTORS;
+
+typedef struct {
+	USB_DEVICE_DESCRIPTOR oDescDevice;
+	USB_CONFIGURATION_DESCRIPTOR oDescConfig;
+	USB_INTERFACE_DESCRIPTOR oDescInterface;
+	USB_ENDPOINT_DESCRIPTOR oDescEp0;
+	USB_SS_EP_COMP_DESCRIPTOR oDescEp0Comp;
+	USB_ENDPOINT_DESCRIPTOR oDescEp1;
+	USB_SS_EP_COMP_DESCRIPTOR oDescEp1Comp;
+	USB_ENDPOINT_DESCRIPTOR oDescEp2;
+	USB_SS_EP_COMP_DESCRIPTOR oDescEp2Comp;
+	USB_ENDPOINT_DESCRIPTOR oDescEp3;
+	USB_SS_EP_COMP_DESCRIPTOR oDescEp3Comp;
+	USB_BOS_DESCRIPTOR oDescBos;
+	USB20_EXT_CAP_DESCRIPTOR oDescUsb20Ext;
+	USB_SUPERSPEED_CAP_DESCRIPTOR oDescSuperCap;
+	USB_CONTAINER_ID_CAP_DESCRIPTOR oDescContainCap;
+} __attribute__ ((packed)) USB_SS_DESCRIPTORS;
+
+typedef struct {
+	u8 bmRequestType;
+	u8 bRequest;
+	u8 wValue_L;
+	u8 wValue_H;
+	u8 wIndex_L;
+	u8 wIndex_H;
+	u8 wLength_L;
+	u8 wLength_H;
+} DEVICE_REQUEST, *DEVICE_REQUEST_PTR;
+
+//=====================================================================
+// definitions related to Standard Device Requests
+#define SETUP_DATA_SIZE	8
+
+// Standard bmRequestType (direction)
+// #define DEVICE_bmREQUEST_TYPE(oDeviceRequest)  ((m_poDeviceRequest->bmRequestType) & 0x80)
+enum DEV_REQUEST_DIRECTION
+{
+	HOST_TO_DEVICE	= 0x00,
+	DEVICE_TO_HOST	= 0x80
+};
+
+// Standard bmRequestType (Type)
+// #define DEVICE_bmREQUEST_TYPE(oDeviceRequest)  ((m_poDeviceRequest->bmRequestType) & 0x60)
+enum DEV_REQUEST_TYPE
+{
+	STANDARD_TYPE	= 0x00,
+	CLASS_TYPE	= 0x20,
+	VENDOR_TYPE	= 0x40,
+	RESERVED_TYPE	= 0x60
+};
+
+// Standard bmRequestType (Recipient)
+// #define DEVICE_bmREQUEST_RECIPIENT(oDeviceRequest)  ((m_poDeviceRequest->bmRequestType) & 0x07)
+enum DEV_REQUEST_RECIPIENT
+{
+	DEVICE_RECIPIENT	= 0,
+	INTERFACE_RECIPIENT	= 1,
+	ENDPOINT_RECIPIENT	= 2,
+	OTHER_RECIPIENT		= 3
+};
+
+// Standard bRequest codes
+enum STANDARD_REQUEST_CODE
+{
+	STANDARD_GET_STATUS		= 0,
+	STANDARD_CLEAR_FEATURE		= 1,
+	STANDARD_RESERVED_1		= 2,
+	STANDARD_SET_FEATURE		= 3,
+	STANDARD_RESERVED_2		= 4,
+	STANDARD_SET_ADDRESS		= 5,
+	STANDARD_GET_DESCRIPTOR		= 6,
+	STANDARD_SET_DESCRIPTOR		= 7,
+	STANDARD_GET_CONFIGURATION	= 8,
+	STANDARD_SET_CONFIGURATION	= 9,
+	STANDARD_GET_INTERFACE		= 10,
+	STANDARD_SET_INTERFACE		= 11,
+	STANDARD_SYNCH_FRAME		= 12,
+	STANDARD_SET_SEL		= 48,
+	STANDARD_ISOCH_DELY		= 49,
+};
+
+// Descriptor types
+enum DESCRIPTOR_TYPE
+{
+	DEVICE_DESCRIPTOR		= 1,
+	CONFIGURATION_DESCRIPTOR	= 2,
+	STRING_DESCRIPTOR		= 3,
+	INTERFACE_DESCRIPTOR		= 4,
+	ENDPOINT_DESCRIPTOR		= 5,
+	DEVICE_QUALIFIER		= 6,
+	OTHER_SPEED_CONFIGURATION	= 7,
+	INTERFACE_POWER			= 8,
+	BOS				= 15,
+};
+
+// configuration descriptor: bmAttributes
+enum CONFIG_ATTRIBUTES
+{
+	CONF_ATTR_DEFAULT		= 0x80, // in Spec 1.0, it was BUSPOWERED bit.
+	CONF_ATTR_REMOTE_WAKEUP		= 0x20,
+	CONF_ATTR_SELFPOWERED		= 0x40
+};
+
+// endpoint descriptor
+enum ENDPOINT_ATTRIBUTES
+{
+	EP_ADDR_IN		= 0x80,
+	EP_ADDR_OUT		= 0x00,
+
+	EP_ATTR_CONTROL		= 0x0,
+	EP_ATTR_ISOCHRONOUS	= 0x1,
+	EP_ATTR_BULK		= 0x2,
+	EP_ATTR_INTERRUPT	= 0x3
+};
+
+// Descriptor size
+enum DESCRIPTOR_SIZE
+{
+	DEVICE_DESC_SIZE	= 18,
+	STRING_DESC0_SIZE	= 4,
+	STRING_DESC1_SIZE	= 22,
+	STRING_DESC2_SIZE	= 42,
+	CONFIG_DESC_SIZE	= 9,
+	INTERFACE_DESC_SIZE	= 9,
+	ENDPOINT_DESC_SIZE	= 7,
+	ENDPOINT_COMP_DESC_SIZE	= 6,
+	DEVICE_QUALIFIER_SIZE	= 10,
+	OTHER_SPEED_CFG_SIZE 	= 9,
+	BOS_DESC_SIZE		= 5,
+	USB20_EXT_CAP_DESC_SIZE	= 7,
+	SUPER_CAP_DESC_SIZE	= 10,
+	CONTAIN_CAP_DESC_SIZE	= 5,
+};
+
+typedef enum
+{
+	USB_HIGH, USB_FULL, USB_LOW
+} USB_SPEED;
+
+typedef enum
+{
+	USBPHY0,
+	USBPHY1,
+} USB_PHY;
+
+typedef enum {
+	DIFF_100MHz,
+	DIFF_24MHz,
+	DIFF_20MHz,
+	DIFF_19_2MHz,
+
+	EXTREF_50MHz,
+	EXTREF_24MHz,
+	EXTREF_20MHz,
+	EXTREF_19_2MHz,
+	EXTREF_12MHz,
+	EXTREF_10MHz,
+	EXTREF_9_6MHz,
+} USB3_PHY_CLKFREQ;
+
+typedef enum
+{
+	UNCHECKED, DISCONNECTED, CONNECTED
+} CABLE_STATUS;
+
+typedef struct {
+	u8 ConfigurationValue;
+} __attribute__ ((packed)) USB_CONFIGURATION_SET;
+
+typedef struct {
+	u8 Device;
+	u8 Interface;
+	u8 EndpointCtrl;
+	u8 EndpointIn;
+	u8 EndpointOut;
+} __attribute__ ((packed)) USB_GET_STATUS;
+
+typedef struct {
+	u8 AlternateSetting;
+} __attribute__ ((packed)) USB_INTERFACE_GET;
+
+typedef struct Usb_st_REG {
+	u8 name[64];
+	u32 uAddr;
+	u8 uBitLen;
+	u8 uRWType;
+	u8 uFlag;						//Option Flag(DPDB, DPPB, PPDB PPPB)
+	u32 uPrivateBitMask;
+	u32 rValue;
+} USBDEV3_REGINFO;
+
+//==================================================================
+// CSR STRUCTURE
+//
+// PHYUTMI
+typedef union
+{
+	u32 data;	// reset value : 0x00000630
+	struct {
+		// bit[0] : force sleep
+		unsigned force_sleep:1;
+		// bit[1] : force suspend
+		unsigned force_suspend:1;
+		// bit[2] : dmpulldown
+		unsigned dm_pulldown:1;
+		// bit[3] : dppulldown
+		unsigned dp_pulldown:1;
+		// bit[4] : drvvbus
+		unsigned drvvbus:1;
+		// bit[5] : idpullup
+		unsigned id_pullup:1;
+		// bit[6] : otg disable
+		unsigned otg_disable:1;
+		// bit[8:7] : reserved
+		unsigned rsvd8_7:2;
+		// bit[9] : external vbus valid indicator (to phy)
+		unsigned vbusvld_ext:1;
+		// bit[10] : external vbus valid select
+		unsigned vbusvld_extsel:1;
+		// bit[31:11] : reserved
+		unsigned rsvd31_11:21;
+	}b;
+} usb3_phy_utmi_t;
+
+// PHYCLKPWR
+typedef union
+{
+	u32 data;	// reset value : 0x801bee3b@c520, 0x441b4558@c510
+	struct {
+			// bit[0] : common block power-down control
+			//            (0->in suspend or sleep mode, the HS bias and pll blocks remain powered and continue to draw current,
+			//             1->in suspend or sleep mode, the HS bias and pll blocks are powered down)
+			unsigned commononn:1;
+			// bit[1] : per-port reset (reest the port's USB2.0 transmit and receive logic without disableing the clocks)
+			unsigned portreset:1;
+			// bit[3:2] : reference clock select for pll block
+			//               (2'b11:HS pll uses EXTREFCLK as reference, 2'b10:HS pll uses ref_pad_clk{p,m}
+			unsigned refclksel:2;
+			// bit[4] : lowered digital suplly indicator (0->normal operating mode, 1->analog blocks are powered-down
+			unsigned retenablen:1;
+			// bit[10:5] : frequency select
+			unsigned fsel:6;
+			// bit[17:11] : mpll frequency multiplier control
+			unsigned mpll_multiplier:7;
+			// bit[18] : input reference clock divider control
+			unsigned ref_clkdiv2:1;
+			// bit[19] : reference clock enable for SS function
+			// enables the reference clock to the prescaler
+			// this must remain deasserted until the ref. clock is running at the appropriate fre., 
+			// at which point ref_ssp_en can be asserted.
+			// for lower power states, ref_ssp_en can be deasserted.
+			unsigned ref_ssp_en:1;
+			// bit[20] : spread spectrum enable
+			unsigned ssc_en:1;
+			// bit[22:21] : spread spectrum clock range
+			unsigned ssc_range:2;
+			// bit[30:23] : spread spectrum reference clock shifting
+			unsigned ssc_ref_clk_sel:8;
+			// bit[31] : reserved
+			unsigned rsvd31:1;
+	}b;
+} usbdev3_phy_clkpwr_t;
+
+// PHYREG0
+typedef union
+{
+	u32 data;
+	struct {
+		// bit[0] : CR_CMD_ADDR
+		unsigned cr_cap_addr:1;
+		// bit[1] : CR_CMD_DATA
+		unsigned cr_cap_data:1;
+		// bit[17:2] : send data to crport
+		unsigned cr_data_in:16;
+		// bit[18] : CR_CMD_READ
+		unsigned cr_read:1;
+		// bit[19] : CR_CMD_WRITE
+		unsigned cr_write:1;
+		// bit[31:20] : reserved
+		unsigned rsvd31_11:12;
+	}b;
+} usb3_phy_reg0_t;
+// PHYREG1
+typedef union
+{
+	u32 data;
+	struct {
+		// bit[0] : receive ack from crport
+		unsigned cr_ack:1;
+		// bit[16:1] : receive data from crport
+		unsigned cr_data_out:16;
+		// bit[31:17] : reserved
+		unsigned rsvd31_11:15;
+	}b;
+} usb3_phy_reg1_t;
+//-----------------------
+// Global Registers (Gxxxx)
+//-----------------------
+// rGSBUSCFG0
+typedef union
+{
+	u32 data;	// reset value : 0x00000001
+	struct {
+		// bit[0] : undefined length INCR burst type enable
+		unsigned incr_xbrst_ena:1;
+		// bit[1] : INCR4 burst type enable
+		unsigned incr_4brst_ena:1;
+		// bit[2] : INCR8 burst type enable
+		unsigned incr_8brst_ena:1;
+		// bit[3] : INCR16 burst type enable
+		unsigned incr_16brst_ena:1;
+		// bit[10:4] :
+		unsigned rsvd10_4:7;
+		// bit[11] : data access is big endian
+		unsigned dat_big_end:1;
+		// bit[12] : bus store-and-forward mode?
+		unsigned sbus_store_and_forward:1;
+		// bit[31:13]
+		unsigned rsvd31_13:19;
+	}b;
+} usbdev3_gsbuscfg0_t;
+
+// rGSBUSCFG1
+typedef union
+{
+	u32 data;	// reset value : 0x00000300
+	struct {
+		// bit[7:0] :
+		unsigned rsvd7_0:8;
+		// bit[11:8] : axi burst request limit
+		unsigned breq_limit:4;
+		// bit[12] : 1k page boundary enable
+		unsigned en_1kpage:1;
+		// bit[31:13]
+		unsigned rsvd31_13:19;
+	}b;
+} usbdev3_gsbuscfg1_t;
+
+// rGSCTL
+typedef union
+{
+	u32 data;	// reset value : 0x30c02000
+	struct {
+		// bit[0] : Disable Clock Gating in LP Mode ( 0:Enable, 1:disable )
+		unsigned dis_clk_gating:1;
+		// bit[1] : HS/FS/LS Module Power Clamp
+		unsigned HsFsLsPwrClmp:1;
+		// bit[2] : SS Module Power Clamp
+		unsigned SsPwrClmp:1;
+		// bit[3] : Disable Data Scrambling in SS ( 0:enable, 1:disable )
+		unsigned DisScramble:1;
+		// bit[5:4] : Scale Down : for simulation
+		unsigned ScaleDown:2;
+		// bit[7:6] : ram clock select (0:bus, 1:pipe, 2:pipe/2, 3:rsvd)
+		unsigned  ram_clk_sel:2;
+		// bit[8] : debug attach
+		unsigned debug_attach:1;
+		// bit[9] : loopback enable
+		unsigned phy_loopback_en:1;
+		// bit[10] : local loopback enable
+		unsigned local_loopback_en:1;
+		// bit[11] : core soft reset
+		unsigned core_soft_reset:1;
+		// bit[13:12] : port cabpbility direction (1:host, 2:device, 3:otg configuration)
+		unsigned port_capdir:2;
+		// bit[15:14] :
+		unsigned frm_scale_down:2;
+		// bit[16] :
+		unsigned u2rst_ecn:1;
+		// bit[18:17] :
+		unsigned rsvd18_17:2;
+		// bit[31:19] : power down scale
+		unsigned pwr_down_scale:13;
+	}b;
+} usbdev3_gctl_t;
+
+// GSTS
+typedef enum
+{
+	GSTS_CUR_OP_MODE_DEVICE, GSTS_CUR_OP_MODE_HOST, GSTS_CUR_OP_MODE_DRD
+} USBDEV3_GSTS_CUR_OP_MODE;
+typedef union
+{
+	u32 data;	// reset value : 0x
+	struct {
+		// bit[1:0] : current mode of operation
+		unsigned cur_mod:2;
+		// bit[31:2] :
+		unsigned rsvd31_2:30;
+	}b;
+} usbdev3_gsts_t;
+
+// GUSB2PHYCFG
+typedef union
+{
+	u32 data;	// reset value : 0x
+	struct {
+		// bit[2:0] :
+		unsigned timeout_cal:3;
+		// bit[3] : 0-> 8bit, 1-> 16bit
+		unsigned phy_if:1;
+		// bit[5:4] :
+		unsigned rsvd5_4:2;
+		// bit[6] :
+		unsigned suspend_usb2_phy:1;
+		// bit[7] :
+		unsigned rsvd7:1;
+		// bit[8] :
+		unsigned enable_sleep_n:1;
+		// bit[9] :
+		unsigned rsvd9:1;
+		// bit[13:10] :
+		unsigned turnaround_time:4;
+		// bit[30:14] :
+		unsigned rsvd30_14:17;
+		// bit[31] :
+		unsigned phy_soft_reset:1;
+	}b;
+} usbdev3_gusb2phycfg_t;
+
+// GUSB3PIPECTL
+typedef union
+{
+	u32 data;	// reset value : 0x00260002
+	struct {
+		// bit[16:0] :
+		unsigned rsvd16_0:17;
+		// bit[17] : suspend USB3.0 SS PHY
+		unsigned suspend_usb3_ss_phy:1;
+		// bit[30:18] :
+		unsigned rsvd31_18:13;
+		// bit[31] : usb3 phy soft reset
+		unsigned phy_soft_reset:1;
+	}b;
+} usbdev3_gusb3pipectl_t;
+
+// GEVNTSIZ
+typedef union
+{
+	u32 data;	// reset value : 0x00000000
+	struct {
+		// bit[15:0] : event buffer size in bytes (must be a multiple of 4)
+		unsigned event_siz:16;
+		// bit[30:16] :
+		unsigned rsvd30_16:15;
+		// bit[31] : event interrupt mask (1 : prevent the interrupt from being generated)
+		unsigned event_int_mask:1;
+	}b;
+} usbdev3_gevntsiz_t;
+
+//-----------------------
+// Device Registers (Dxxxx)
+//-----------------------
+// DCFG
+typedef enum
+{
+	USBDEV3_SPEED_SUPER	= 4,
+	USBDEV3_SPEED_HIGH	= 0,
+	USBDEV3_SPEED_FULL	= 1
+}USBDEV3_SPEED_e;
+typedef union
+{
+	u32 data;	// reset value : 0x00080804
+	struct {
+		// bit[2:0] : device speed
+		unsigned dev_speed:3;
+		// bit[9:3] : device address
+		unsigned dev_addr:7;
+		// bit[11:10] : periodic frame interval
+		unsigned per_fr_int:2;
+		// bit [16:12] : interrupt number
+		unsigned intr_num:5;
+		// bit[21:17] : # of rx buffers
+		unsigned num_rx_buf:5;
+		// bit[22] : lpm capable
+		unsigned lpm_cap:1;
+		// bit[23] : ignore stream pp ???
+		unsigned ignore_stream_pp:1;
+		// bit[31:24] :
+		unsigned rsvd31_24:8;
+	}b;
+} usbdev3_dcfg_t;
+
+typedef enum
+{
+	DCTL_TEST_MODE_DISABLED = 0,
+	DCTL_TEST_J_MODE = 1,
+	DCTL_TEST_K_MODE = 2,
+	DCTL_TEST_SE0_NAK_MODE = 3,
+	DCTL_TEST_PACKET_MODE = 4,
+	DCTL_TEST_FORCE_ENABLE = 5,
+	DCTL_TEST_CTRL_FIELD = 7
+} USBDEV3_DCTL_TEST_CTRL_e;
+
+// DCTL
+typedef union
+{
+	u32 data;	// reset value : 0x0
+	struct {
+		// bit[0] :
+		unsigned rsvd0:1;
+		// bit[4:1] : Test Control
+		unsigned test_ctrl:4;
+		// bit[29:5] :
+		unsigned rsvd29_5:25;
+		// bit[30] : core soft reset
+		unsigned core_soft_reset:1;
+		// bit[31] : run/stop
+		unsigned run_stop:1;
+	}b;
+} usbdev3_dctl_t;
+
+// DEVTEN
+typedef union
+{
+	u32 data;	// reset value : 0x0
+	struct {
+		// bit[0] : disconnect detected event enable
+		unsigned disconn_evt_en:1;
+		// bit[1] : usb reset  enable
+		unsigned usb_reset_en:1;
+		// bit[2] : connection done enable
+		unsigned conn_done_en:1;
+		// bit[3] : usb/link state change event enable
+		unsigned usb_lnk_sts_chng_en:1;
+		// bit[4] : resume/remote wakeup detected event enable
+		unsigned wake_up_en:1;
+		// bit[5] :
+		unsigned rsvd5:1;
+		// bit[6] : end of periodic frame event enable
+		unsigned eopf_en:1;
+		// bit[7] : start of (micro)frame enable
+		unsigned sof_en:1;
+		// bit[8] :
+		unsigned rsvd8:1;
+		// bit[9] : erratic error event enable
+		unsigned errtic_err_en:1;
+		// bit[10] : generic command compete event enable
+		unsigned cmd_cmplt_en:1;
+		// bit[11] : event buffer overflow event enable
+		unsigned evnt_overflow_en:1;
+		// bit[12] : vendor device test LMP received event enable ???
+		unsigned vndr_dev_tst_rcved_en:1;
+		// bit[31:13] :
+		unsigned rsvd31_13:19;
+	}b;
+} usbdev3_devten_t;
+
+// DSTS
+typedef union
+{
+	u32 data;	// reset value : 0x00020004
+	struct {
+		// bit[2:0] : connected speed(0:hs, 1:fs, 4:ss)
+		unsigned connect_speed:3;
+		// bit[16:3] : (u)frame # of the received SOF
+		unsigned soffn:14;
+		// bit[17] : RxFIFO Empty
+		unsigned rx_fifo_empty:1;
+		// bit[21:18] : USB/Link State
+		unsigned usb_link_sts:4;
+		// bit[22] : device controller halted
+		unsigned dev_ctrl_halted:1;
+		// bit[23] : core idle
+		unsigned core_idle:1;
+		// bit[24] : power up request
+		unsigned pwr_up_req:1;
+		// bit[31:25]
+		unsigned rsvd31_25:7;
+	}b;
+} usbdev3_dsts_t;
+
+// DGCMD
+typedef enum
+{
+	DGCMD_CMD_XMIT_SET_LINK_FUNC_LMP	= 0x1,
+	DGCMD_CMD_SET_PERIODIC_PARAMS		= 0x2,
+	DGCMD_CMD_XMIT_FUNC_WAKE_DEV_NOTIF	= 0x3,
+	DGCMD_CMD_SELECTED_FIFO_FLUSH		= 0x9,
+	DGCMD_CMD_ALL_FIFO_FLUSH		= 0xa,
+	DGCMD_CMD_SET_EP_NRDY			= 0xc,
+	DGCMD_CMD_RUN_SOC_BUS_LOOPBACK_TEST	= 0x10
+} USBDEV3_DGCMD_CMD_e;
+
+typedef union
+{
+	u32 data;	// reset value : 0x0
+	struct {
+		// bit[7:0] : command type
+		unsigned cmd_type:8;
+		// bit[8] : command interrupt on complete
+		unsigned ioc:1;
+		// bit[9]
+		unsigned rsvd9:1;
+		// bit[10] : command active
+		unsigned cmd_active:1;
+		// bit[14:11]
+		unsigned rsvd14_11:4;
+		// bit[15] : command completion status (0:error, 1:success)
+		unsigned cmd_sts:1;
+		// bit[31:16] :
+		unsigned rsvd31_16:16;
+	}b;
+} usbdev3_dgcmd_t;
+
+// DEPCMDPAR1
+	// This structure represents the bit fields in the Device Endpoint Command
+	// Parameter 1 Register (DEPCMDPAR1n) for the Set Endpoint Configuration
+	// (DEPCMD_SET_EP_CFG) command.
+typedef enum
+{
+	USBDEV3_EP_DIR_OUT = 0,
+	USBDEV3_EP_DIR_IN = 1
+} USBDEV3_EP_DIR_e;
+
+typedef union
+{
+	u32 data;	// reset value : 0x0
+	struct {
+		// bit[4:0] : interrupt number
+		unsigned intr_num:5;
+		// bit[7:5]
+		unsigned rsvd7_5:3;
+		// bit[8] : transfer complete enable
+		unsigned xfer_cmpl_en:1;
+		// bit[9] : xfer in progress enable
+		unsigned xfer_in_prog_en:1;
+		// bit[10] : xfer not ready enable
+		unsigned xfer_nrdy_en:1;
+		// bit[11] : fifo under/over-run enable
+		unsigned fifo_xrun_en:1;
+		// bit[12]
+		unsigned rsvd12:1;
+		// bit[13] : stream event enable
+		unsigned str_evnt_en:1;
+		// bit[15:14]
+		unsigned rsvd15_14:2;
+		// bit[23:16] : b interval -1
+		unsigned binterval_m1:8;
+		// bit[24] : stream capable
+		unsigned strm_cap:1;
+		// bit[25] : ep direction(0:out, 1:in)
+		unsigned ep_dir:1;
+		// bit[29:26] : ep number
+		unsigned ep_num:4;
+		// bit[30] : bulk-base
+		unsigned bulk_based:1;
+		// bit[31] : fifo-based
+		unsigned fifo_based:1;
+	}b;
+} usbdev3_depcmdpar1_set_ep_cfg_t;
+
+// DEPCMDPAR0
+	// This structure represents the bit fields in the Device Endpoint Command
+	// Parameter 0 Register (DEPCMDPAR0n) for the Set Endpoint Configuration
+	// (DEPCMD_SET_EP_CFG) command.
+typedef enum
+{
+	USBDEV3_EP_CTRL = 0,
+	USBDEV3_EP_ISOC = 1,
+	USBDEV3_EP_BULK = 2,
+	USBDEV3_EP_INTR = 3
+}USBDEV3_EP_TYPE_e;
+
+typedef union
+{
+	u32 data;	// reset value : 0x0
+	struct {
+		// bit[0]
+		unsigned rsvd0:1;
+		// bit[2:1] : ep type
+		unsigned ep_type:2;
+		// bit[13:3] : maximum packet size
+		unsigned mps:11;
+		// bit[16:14]
+		unsigned rsvd16_14:3;
+		// bit[21:17] : fifo number
+		unsigned fifo_num:5;
+		// bit[25:22] : burst size
+		unsigned brst_siz:4;
+		// bit[30:26] : data sequence number
+		unsigned ds_num:5;
+		// bit[31] : ignor sequence number
+		unsigned ign_dsnum:1;
+	}b;
+} usbdev3_depcmdpar0_set_ep_cfg_t;
+
+// DEPCMD
+typedef enum
+{
+	DEPCMD_CMD_RSVD = 0x0,
+	DEPCMD_CMD_SET_EP_CFG = 0x1,
+	DEPCMD_CMD_SET_EP_XFER_RSRC_CFG = 0x2,
+	DEPCMD_CMD_GET_DATA_SEQ_NUM = 0x3,
+	DEPCMD_CMD_SET_STALL = 0x4,
+	DEPCMD_CMD_CLR_STALL = 0x5,
+	DEPCMD_CMD_START_XFER = 0x6,
+	DEPCMD_CMD_UPDATE_XFER = 0x7,
+	DEPCMD_CMD_END_XFER = 0x8,
+	DEPCMD_CMD_START_NEW_CFG = 0x9
+} USBDEV3_DEPCMD_CMD_TYPE_e;
+typedef union
+{
+	u32 data;	// reset value : 0x0
+	struct {
+		// bit[3:0] : Command Type
+		unsigned cmd_type:4;
+		// bit[7:4]
+		unsigned rsvd7_4:4;
+		// bit[8] : command interrupt on complete
+		unsigned ioc:1;
+		// bit9]
+		unsigned rsvd9:1;
+		// bit[10] : command active
+		unsigned cmd_active:1;
+		// bit[11] : high priority(only valid for start transfer command), forceRM(only valid for end transfer command)
+		unsigned hipri_forcerm:1;
+		// bit[15:12] : command completion status
+		unsigned cmd_sts:4;
+		// bit[31:16] : command parameters(written case), event parameters(read case)
+		unsigned param:16;
+	}b;
+} usbdev3_depcmd_t;
+
+/////////////////////////////////////////////////
+// Event Buffer Structures
+//
+
+#define USBDEV3_EVENT_BUFFER_COUNT	128	//256
+
+// Event Buffer for Device Endpoint-Specific Events
+typedef enum
+{
+	DEPEVT_EVT_XFER_CMPL	= 1,
+	DEPEVT_EVT_XFER_IN_PROG	= 2,
+	DEPEVT_EVT_XFER_NRDY	= 3,
+	DEPEVT_EVT_FIFOXRUN	= 4,
+	DEPEVT_EVT_STRM_EVT	= 6,
+	DEPEVT_EVT_EPCMD_CMPL	= 7,
+}USBDEV3_DEPEVT_EVT_e;
+
+typedef union
+{
+	u32 data;
+	struct {
+		// bit[0] : 0-> ep-specific event
+		unsigned non_ep_evnt:1;
+		// bit[5:1] : ep number
+		unsigned ep_num:5;
+		// bit[9:6] : event type
+		unsigned evt_type:4;
+		// bit[11:10]
+		unsigned rsvd11_10:2;
+		// bit[15:12] : event status
+		unsigned evnt_sts:4;
+		// bit[31:16] : event parameters
+		unsigned evnt_param:16;
+	}b;
+}usbdev3_depevt_t;
+
+// Event Buffer for Device-Specific Events
+typedef enum
+{
+	DEVT_DISCONN		= 0,
+	DEVT_USBRESET		= 1,
+	DEVT_CONNDONE		= 2,
+	DEVT_ULST_CHNG		= 3,
+	DEVT_WKUP		= 4,
+	DEVT_EOPF		= 6,
+	DEVT_SOF		= 7,
+	DEVT_ERRATICERR		= 9,
+	DEVT_CMD_CMPL		= 10,
+	DEVT_OVERFLOW		= 11,
+	DEVT_VNDR_DEV_TST_RCVD	= 12,
+	DEVT_INACT_TIMEOUT_RCVD	= 13,
+}USBDEV3_DEVT_e;
+
+typedef union
+{
+	u32 data;
+	struct {
+		// bit[0] : 1-> device-specific event
+		unsigned non_ep_evnt:1;
+		// bit[7:1] : 0-> device specific, 1-> OTG, 3-> ULPI Carkit, 4-> I2C
+		unsigned dev_specific:7;
+		// bit[11:8] : event type
+		unsigned evt_type:4;
+		// bit[15:12]
+		unsigned rsvd15_12:4;
+		// bit[23:16] : event information bits
+		unsigned evt_info:8;
+		// bit[31:24]
+		unsigned rsvd31_24:8;
+	}b;
+}usbdev3_devt_t;
+//
+
+/////////////////////////////////////////////////
+// DMA Descriptor Specific Structures
+//
+
+// Limit of bytes in one TRB
+#define TRB_BUF_SIZ_LIMIT	16777215	//2^24 - 1 (16MB -1byte)
+
+// status field of TRB
+typedef union
+{
+	u32 data;
+	struct
+	{
+		// bit[23:0] : buffer size
+		unsigned buf_siz:24;
+		// bit[25:24] : packet count minus 1
+		unsigned pkt_cnt_m1:2;
+		// bit[27:26]
+		unsigned rsvd27_26:2;
+		// bit[31:28] : TRB status
+		unsigned trb_sts:4;
+	}b;
+}usbdev3_trb_sts_t;
+
+typedef enum
+{
+	TRB_CTRL_NORMAL		= 1,		// Control-Data-2+ / bulk / Interrupt
+	TRB_CTRL_SETUP		= 2,
+	TRB_CTRL_STATUS_2	= 3,
+	TRB_CTRL_STATUS_3	= 4,
+	TRB_CTRL_CTLDATA_1ST	= 5,		// 1st TRB of Data stage
+	TRB_CTRL_ISOC_1ST	= 6,		// 1st TRB of Service Interval
+	TRB_CTRL_ISOC		= 7,
+	TRB_CTRL_LINK		= 8,		// Link TRB
+} USBDEV3_TRB_TYPE_e;
+
+// control field of TRB
+typedef union
+{
+	u32 data;
+	struct
+	{
+		// bit[0] : h/w owner of descriptor
+		unsigned hwo:1;
+		// bit[1] : last TRB
+		unsigned lst:1;
+		// bit[2] : chain buffers
+		unsigned chn:1;
+		// bit[3] : continue on short packet
+		unsigned csp:1;
+		// bit[9:4] : TRB control
+		unsigned trb_ctrl:6;
+		// bit[10] : interrupt on short packet/ interrupt on missed ISOC
+		unsigned isp_imi:1;
+		// bit[11] : interrupt on complete
+		unsigned ioc:1;
+		// bit[13:12]
+		unsigned rsvd13_12:2;
+		// bit[29:14] : stream ID/ SOF #
+		unsigned strmid_sofn:16;
+		// bit[31:30]
+		unsigned rsvd31_30:2;
+	}b;
+} usbdev3_trb_ctrl_t;
+
+// TRB structure
+typedef struct
+{
+	u32 buf_ptr_l;	// buffer pointer low
+	u32 buf_ptr_h;	// buffer pointer high
+	usbdev3_trb_sts_t status;
+	usbdev3_trb_ctrl_t control;
+} usbdev3_trb_t, *usbdev3_trb_ptr_t;
+
+
+//------------------------------------------------
+// USBDEV state
+typedef enum
+{
+	USBDEV3_STATE_DEFAULT,
+	USBDEV3_STATE_ADDRESSED,
+	USBDEV3_STATE_CONFIGURED,
+} USBDEV3_STATE;
+
+typedef struct
+{
+	union {
+		USB_DESCRIPTORS m_oDesc;
+		USB_SS_DESCRIPTORS m_oSSDesc;
+	};
+
+	DEVICE_REQUEST m_oDeviceRequest;
+
+	u32  m_uEp0State;
+	u32  m_uEp0SubState;
+	USBDEV3_SPEED_e m_eSpeed;
+	u32  m_uControlEPMaxPktSize;
+	u32  m_uBulkEPMaxPktSize;
+	u32  m_uDownloadAddress;
+	u32  m_uDownloadFileSize;
+	u32  m_uUploadAddr;
+	u32  m_uUploadSize;
+	u8*  m_pDownPt;
+	u8*  m_pUpPt;
+	USBDEV3_STATE  m_eUsbDev3State;
+	u32  m_uDeviceRequestLength;
+	u8 m_bEp0ThreeStage;
+
+	u8 m_bEPs_Enabled;
+
+	u32 m_uLinkBaseRegs;
+	u32 m_uPhyBaseRegs;
+	u32 *m_pEventBuffer;
+	u16 m_CurrentEventPosition;
+
+	// Buffer for GET_STATUS & GET_DESCRIPTOR up to 512 bytes in length
+	u32 m_uStatusBufAddr;
+
+	// SET_SEL request pending info
+	u8 m_bReq_Set_sel;
+
+	// TRB for Setup Packet
+	volatile usbdev3_trb_ptr_t m_oSetupTrbPtr;
+
+	// TRB for Data-Out or Status-Out phase
+	volatile usbdev3_trb_ptr_t m_oOutTrbPtr;
+
+	// TRB for Data-In or Status-In phase
+	volatile usbdev3_trb_ptr_t m_oInTrbPtr;
+
+	// Transfer Resource Index for Each EP
+	u32 m_uTriOut[TOTL_EP_COUNT];
+	u32 m_uTriIn[TOTL_EP_COUNT];
+
+	// Stall Status for Each EP
+	u8 m_bEpOutStalled[TOTL_EP_COUNT];
+	u8 m_bEpInStalled[TOTL_EP_COUNT];
+
+	CABLE_STATUS m_cable;
+} USBDEV3;
+
+// EP0 state
+enum EP0_STATE
+{
+	EP0_STATE_UNCONNECTED		= 0xffff,
+	EP0_STATE_INIT			= 0,
+	EP0_STATE_IN_DATA_PHASE		= 1,
+	EP0_STATE_OUT_DATA_PHASE	= 2,
+	EP0_STATE_IN_WAIT_NRDY		= 3,
+	EP0_STATE_OUT_WAIT_NRDY		= 4,
+	EP0_STATE_IN_STATUS_PHASE	= 5,
+	EP0_STATE_OUT_STATUS_PHASE	= 6,
+	EP0_STATE_STALL			= 7
+};
+
+//=====================================================================================
+// prototypes of API functions
+void Isr_UsbDev3(void);
+u8 USBDEV3_Init(USBDEV3_SPEED_e eSpeed);
+void USBDEV3_DeInit(void);
+
+u8 USBDEV3_IsUsbDevSetConfiguration(void);
+
+void USBDEV3_Prepare1stBulkOutTrb(void);
+
+void USBDEV3_ClearDownFileInfo(void);
+void USBDEV3_GetDownFileInfo(u32* uDownAddr, u32* uDownFileSize, u8* bIsFinished);
+void USBDEV3_ClearUpFileInfo(void);
+void USBDEV3_GetUpFileInfo(u32* uUpAddr, u32* uUpFileSize, u8* bIsFinished);
+u8 USBDEV3_VerifyChecksum(void);
+void USBDEV3_OpenUsingUsbDownAddr(u32 Addr);
+void USBDEV3_CloseUsingUsbDownAddr(void);
+u32 USBDEV3_AllocateDataStructure(u32 uSize, u32 uAlign);
+void USBDEV3_FreeDataStructure(u32 uAddr);
+
+int exynos_usbctl_init(void);
+int exynos_usbc_activate (void);
+int exynos_usb_stop( void );
+int exynos_udc_int_hndlr(void);
+
+/* in usbd3-ss.c */
+extern unsigned int exynos_usbd_dn_addr;
+extern unsigned int exynos_usbd_dn_cnt;
+extern int DNW;
+extern int exynos_got_header;
+extern int exynos_receive_done;
+
+#endif
diff --git a/fs/fat/fat.c b/fs/fat/fat.c
old mode 100644
new mode 100755
index 465a6875ed..72ac36b0e0
--- a/fs/fat/fat.c
+++ b/fs/fat/fat.c
@@ -1356,3 +1356,311 @@ int fat_read_file(const char *filename, void *buf, loff_t offset, loff_t len,
 void fat_close(void)
 {
 }
+
+/*
+ * Copy string, padding with spaces.
+ */
+static void setstr(u_int8_t *dest, const char *src, size_t len)
+{
+	while (len--)
+		*dest++ = *src ? *src++ : ' ';
+}
+
+static int write_pbr(struct blk_desc *dev_desc, disk_partition_t *info)
+{
+	struct bs *bs;
+	struct bsbpb *bsbpb;
+	struct bsxbpb *bsxbpb;
+	struct bsx *bsx;
+	__u8 *img;
+	int img_offset = 0;
+	int i;
+	int fat_size = 0;
+
+	img = malloc(sizeof(__u8)*512);
+	if(img == NULL) {
+		printf("Can't make img buffer~~!!\n");
+		return -1;
+	}
+	memset(img, 0x0, sizeof(__u8)*512);
+
+	/* Erase Reserved Sector(PBR) */
+	for (i = 0;i < RESERVED_CNT; i++) {
+		if (dev_desc->block_write(dev_desc, info->start + i,
+					1, (ulong *)img) != 1) {
+			printf ("Can't erase reserved sector~~~!!!\n");
+			return -1;
+		}
+	}
+
+	/* Set bs */
+	bs = (struct bs *)img;
+	img_offset += sizeof(struct bs) - 1;
+
+	mk1(bs->jmp[0], 0xeb);
+	mk1(bs->jmp[1], 0x58);
+	mk1(bs->jmp[2], 0x90); /* Jump Boot Code */
+	setstr(bs->oem, "SAMSUNG", sizeof(bs->oem)); /* OEM Name */
+
+	uint spc;
+	/* Set bsbpb */
+	bsbpb = (struct bsbpb *)(img + img_offset);
+	img_offset += sizeof(struct bsbpb) - 2;
+
+	mk2(bsbpb->bps, 512); /* Byte Per Sector */
+
+	printf("size checking ...\n");
+	/* Sector Per Cluster */
+	if (info->size < 0x10000) { /* partition size >= 32Mb */
+		printf("Can't format less than 32Mb partition!!\n");
+		return -1;
+	}
+	if (info->size <= 0x20000) { /* under 64M -> 512 bytes */
+		printf("Under 64M\n");
+		mk1(bsbpb->spc, 1);
+		spc = 1;
+	}
+	else if (info->size <= 0x40000) { /* under 128M -> 1K */
+		printf("Under 128M\n");
+		mk1(bsbpb->spc, 2);
+		spc = 2;
+	}
+	else if (info->size <= 0x80000) { /* under 256M -> 2K */
+		printf("Under 256M\n");
+		mk1(bsbpb->spc, 4);
+		spc = 4;
+	}
+	else if (info->size <= 0xFA0000) { /* under 8G -> 4K */
+		printf("Under 8G\n");
+		mk1(bsbpb->spc, 8);
+		spc = 8;
+	}
+	else if (info->size <= 0x1F40000) { /* under 16G -> 8K */
+		printf("Under 16G\n");
+		mk1(bsbpb->spc, 16);
+		spc = 16;
+	}
+	else {
+		printf("16G~\n");
+		mk1(bsbpb->spc, 32);
+		spc = 32;
+	}
+
+	printf("write FAT info: %d\n",RESERVED_CNT);
+	mk2(bsbpb->res, RESERVED_CNT); /* Reserved Sector Count */
+	mk1(bsbpb->nft, 2); /* Number of FATs */
+	mk2(bsbpb->rde, 0); /* Root Directory Entry Count : It's no use in FAT32 */
+	mk2(bsbpb->sec, 0); /* Total Sector : It's no use in FAT32 */
+	mk1(bsbpb->mid, 0xF8); /* Media */
+	mk2(bsbpb->spf, 0); /* FAT Size 16 : It's no use in FAT32 */
+	mk2(bsbpb->spt, 0); /* Sector Per Track */
+	mk2(bsbpb->hds, 0); /* Number Of Heads */
+	mk4(bsbpb->hid, 0); /* Hidden Sector */
+	mk4(bsbpb->bsec, info->size); /* Total Sector For FAT32 */
+
+	/* Set bsxbpb */
+	bsxbpb = (struct bsxbpb *)(img + img_offset);
+	img_offset += sizeof(struct bsxbpb);
+
+	mk4(bsxbpb->bspf, (info->size / (spc * 128))); /* FAT Size 32 */
+	fat_size = info->size / (spc * 128);
+	printf("Fat size : 0x%x\n", info->size / (spc * 128));
+	mk2(bsxbpb->xflg, 0); /* Ext Flags */
+	mk2(bsxbpb->vers, 0); /* File System Version */
+	mk4(bsxbpb->rdcl, 2); /* Root Directory Cluster */
+	mk2(bsxbpb->infs, 1); /* File System Information */
+	mk2(bsxbpb->bkbs, 0); /* Boot Record Backup Sector */
+
+	/* Set bsx */
+	bsx = (struct bsx *)(img + img_offset);
+	mk1(bsx->drv, 0); /* Drive Number */
+	mk1(bsx->sig, 0x29); /* Boot Signature */
+	mk4(bsx->volid, 0x3333); /* Volume ID : 0x3333 means nothing */
+	setstr(bsx->label, "NO NAME ", sizeof(bsx->label)); /* Volume Label */
+	setstr(bsx->type, "FAT32", sizeof(bsx->type)); /* File System Type */
+
+	/* Set Magic Number */
+	mk2(img + BYTE_PER_SEC - 2, 0xaa55); /* Signature */
+
+/*
+	printf("Print Boot Recode\n");
+	for(i = 0;i<512;i++) {
+		if(img[i] == 0)
+			printf("00 ");
+		else
+			printf("%2x ", img[i]);
+		if (!((i+1) % 16))
+			printf("\n");
+	}
+*/
+
+	if (dev_desc->block_write(dev_desc, info->start,
+				1, (ulong *)img) != 1) {
+		printf ("Can't write PBR~~~!!!\n");
+		return -1;
+	}
+
+	return fat_size;
+}
+static int write_reserved(struct blk_desc *dev_desc, disk_partition_t *info)
+{
+	/* Set Reserved Region */
+	__u8 *img;
+
+	img = malloc(sizeof(__u8)*512);
+	if(img == NULL) {
+		printf("Can't make img buffer~~(reserved)!!\n");
+		return -1;
+	}
+
+	memset(img, 0x0, sizeof(__u8)*512);
+
+	mk4(img, 0x41615252); /* Lead Signature */
+	mk4(img + BYTE_PER_SEC - 28, 0x61417272); /* Struct Signature */
+	mk4(img + BYTE_PER_SEC - 24, 0xffffffff); /* Free Cluster Count */
+	mk4(img + BYTE_PER_SEC - 20, 0x3); /* Next Free Cluster */
+	mk2(img + BYTE_PER_SEC - 2, 0xaa55); /* Trail Signature */
+
+	/*
+	printf("Print Reserved Region\n");
+	for(i = 0;i<512;i++) {
+		if(img[i] == 0)
+			printf("00 ");
+		else
+			printf("%2x ", img[i]);
+		if (!((i+1) % 16))
+			printf("\n");
+	}
+	*/
+
+	/* Write Reserved region */
+	if (dev_desc->block_write(dev_desc, info->start+1,
+				1, (ulong *)img) != 1) {
+		printf ("Can't write reserved region~~~!!!\n");
+		return -1;
+	}
+	return 1;
+}
+
+static int
+write_fat(struct blk_desc *dev_desc, disk_partition_t *info, int fat_size)
+{
+	__u8 *dummy;
+	__u8 *img;
+	int i;
+
+	/* Create buffer for FAT */
+	img = malloc(sizeof(__u8)*512);
+	if(img == NULL) {
+		printf("Can't make img buffer~~!!\n");
+		return -1;
+	}
+	memset(img, 0x0, sizeof(__u8) * 512);
+
+	/* Create buffer for erase */
+	dummy = malloc(sizeof(__u8) * 8192);
+	if(dummy == NULL) {
+		printf("Can't make dummy buffer~~!!\n");
+		return -1;
+	}
+	memset(dummy, 0x0, sizeof(__u8) * 8192);
+
+	/* Erase FAT Region */
+	int erase_block_cnt = (fat_size * 2);
+	printf("Erase FAT region");
+	for (i = 0;i < erase_block_cnt + 10; i+=16) {
+		if (dev_desc->block_write(dev_desc, info->start +
+			RESERVED_CNT + i, 16, (ulong *)dummy) != 16) {
+			printf ("Can't erase FAT region~~!!!\n");
+		}
+		if((i % 160) == 0) {
+			if ((i % 12800) == 0)
+				printf("\n");
+			printf(".");
+		}
+	}
+	printf("\n");
+
+	mk4(img, 0x0ffffff8);
+	mk4(img+4, 0x0fffffff);
+	mk4(img+8, 0x0fffffff); /* Root Directory */
+
+	/*
+	printf("Print FAT Region\n");
+	for(i = 0;i<512;i++) {
+		if(img[i] == 0)
+			printf("00 ");
+		else
+			printf("%2x ", img[i]);
+		if (!((i+1) % 16))
+			printf("\n");
+	}
+	*/
+	/* Write FAT Region */
+	if (dev_desc->block_write(dev_desc, info->start + RESERVED_CNT,
+				1, (ulong *)img) != 1) {
+		printf ("Can't write FAT~~~!!!\n");
+		return -1;
+	}
+
+	return 1;
+}
+
+/*
+ * Format device (FAT)
+ */
+int do_format(struct blk_desc *dev_desc, int part_no)
+{
+	unsigned char buffer[SECTOR_SIZE];
+	unsigned long part_offset = 0;
+	int cur_part = 0;
+	disk_partition_t info;
+
+	cur_dev = dev_desc;
+	/* check if we have a MBR (on floppies we have only a PBR) */
+	if (dev_desc->block_read(dev_desc, 0, 1, (ulong *)buffer) != 1) {
+		printf ("** Can't read from device %d **\n", dev_desc->devnum);
+		return -1;
+	}
+	if (buffer[DOS_PART_MAGIC_OFFSET] != 0x55 ||
+		buffer[DOS_PART_MAGIC_OFFSET + 1] != 0xaa) {
+		printf("** MBR is broken **\n");
+		/* no signature found */
+		return -1;
+	}
+
+#if defined(CONFIG_CMD_IDE) || \
+    defined(CONFIG_CMD_SATA) || \
+    defined(CONFIG_SCSI) || \
+    defined(CONFIG_CMD_USB) || \
+    defined(CONFIG_MMC)
+	/* First we assume, there is a MBR */
+	if (!part_get_info(dev_desc, part_no, &info)) {
+		part_offset = info.start;
+		cur_part = part_no;
+	} else if (!strncmp((char *)&buffer[DOS_FS_TYPE_OFFSET], "FAT", 3)) {
+		/* ok, we assume we are on a PBR only */
+		cur_part = 1;
+		part_offset = 0;
+	} else {
+		printf ("** Partition %d not valid on device %d **\n",
+				part_no, dev_desc->devnum);
+		return -1;
+	}
+#endif
+	printf("Partition %d: Start Address(0x%x), Size(0x%x)\n",
+			part_no, info.start, info.size);
+
+	int fat_size;
+	fat_size = write_pbr(dev_desc, &info);
+	if(fat_size < 0)
+		return -1;
+	if(write_reserved(dev_desc, &info) < 0)
+		return -1;
+	if(write_fat(dev_desc, &info, fat_size) < 0)
+		return -1;
+	printf("Partition%d format complete.\n", part_no);
+
+	return 0;
+}
+
diff --git a/include/configs/exynos5-common.h b/include/configs/exynos5-common.h
index 2860d6bb9b..b863c6fd15 100644
--- a/include/configs/exynos5-common.h
+++ b/include/configs/exynos5-common.h
@@ -142,6 +142,7 @@
 #define BOOT_TARGET_DEVICES(func) \
 	func(MMC, mmc, 1) \
 	func(MMC, mmc, 0) \
+	func(USB, usb, 0) \
 	func(PXE, pxe, na) \
 	func(DHCP, dhcp, na)
 
diff --git a/include/configs/odroid_xu4.h b/include/configs/odroid_xu4.h
new file mode 100755
index 0000000000..d89da74137
--- /dev/null
+++ b/include/configs/odroid_xu4.h
@@ -0,0 +1,254 @@
+/*
+ * Copyright (C) 2013 Samsung Electronics
+ * Hyungwon Hwang <human.hwang@samsung.com>
+ * Dongjin Kim <tobetter@gmail.com>
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#ifndef __CONFIG_ODROID_XU4_H
+#define __CONFIG_ODROID_XU4_H
+
+#include "exynos5420-common.h"
+#include <configs/exynos5-common.h>
+
+#undef CONFIG_ENV_IS_IN_SPI_FLASH
+
+#define CONFIG_BOARD_COMMON
+#define CONFIG_BOARD_LATE_INIT
+
+#define CONFIG_SYS_SDRAM_BASE		0x40000000
+#define CONFIG_SYS_TEXT_BASE		0x43E00000
+
+/* select serial console configuration */
+#define CONFIG_SERIAL2			/* use SERIAL 2 */
+
+#define TZPC_BASE_OFFSET		0x10000
+
+#define CONFIG_NR_DRAM_BANKS		8
+#define SDRAM_BANK_SIZE			(256UL << 20UL)	/* 256 MB */
+/* Reserve the last 22 MiB for the secure firmware */
+#define CONFIG_SYS_MEM_TOP_HIDE		(22UL << 20UL)
+#define CONFIG_TZSW_RESERVED_DRAM_SIZE	CONFIG_SYS_MEM_TOP_HIDE
+
+#define CONFIG_SYS_MMC_MAX_DEVICE	2
+
+#if defined(CONFIG_FASTBOOT)
+/* Fastboot SDMMC Partition Table for ODROID(Exynos5422) */
+
+/* BL1		BLK#: 1    (0x0001) ~    30 (0x001E) */
+/* BL2		BLK#: 31   (0x001F) ~    62 (0x003E) */
+/* UBOOT	BLK#: 63   (0x003F) ~  1502 (0x05DE) */
+/* TZSW		BLK#: 1503 (0x05DF) ~  2014 (0x07DE) */
+/* UBOOT ENV	BLK#: 2015 (0x07DF) ~  2046 (0x07FE) */
+
+/* Attention! : eMMC BLK MAP is BLK#-1 in SDMMC Partition Table */
+
+#define	MOVI_BLK_SIZE			(512)
+#define	MOVI_BLK_END			(-1)
+
+#define	PART_SIZE_BL1			(SZ_1K * 15)
+#define	PART_SIZE_BL2			(SZ_1K * 16)
+#define	PART_SIZE_UBOOT			(SZ_1K * 720)
+#define	PART_SIZE_TZSW			(SZ_1K * 256)
+#define	PART_SIZE_ENV			(SZ_1K * 16)
+#define	PART_SIZE_KERNEL		(SZ_1M * 8)
+
+#define	PART_BL1_ST_BLK			(1)	/* Skip for MBR */
+#define	PART_BL2_ST_BLK			(PART_BL1_ST_BLK + \
+					(PART_SIZE_BL1 / MOVI_BLK_SIZE))
+#define	PART_UBOOT_ST_BLK		(PART_BL2_ST_BLK + \
+					(PART_SIZE_BL2 / MOVI_BLK_SIZE))
+#define	PART_TZSW_ST_BLK		(PART_UBOOT_ST_BLK + \
+					(PART_SIZE_UBOOT / MOVI_BLK_SIZE))
+#define	PART_ENV_ST_BLK			(PART_TZSW_ST_BLK + \
+					(PART_SIZE_TZSW / MOVI_BLK_SIZE))
+#define	PART_KERNEL_ST_BLK		(PART_ENV_ST_BLK + \
+					(PART_SIZE_ENV / MOVI_BLK_SIZE))
+
+/* Android Partition size for ODROID */
+#define	PART_SIZE_SYSTEM		SZ_1G
+#define	PART_SIZE_USERDATA		SZ_2G
+#define	PART_SIZE_CACHE			SZ_256M
+#define	ANDROID_PART_START		SZ_64M
+
+#endif	/* #if defined(CONFIG_FASTBOOT) */
+
+#define CONFIG_ENV_IS_IN_MMC
+
+#undef CONFIG_ENV_SIZE
+#undef CONFIG_ENV_OFFSET
+
+#if defined(CONFIG_FASTBOOT)
+	#define	CONFIG_ENV_SIZE		(PART_SIZE_ENV)
+	#define	CONFIG_ENV_OFFSET	(PART_ENV_ST_BLK * MOVI_BLK_SIZE)
+#else
+	#define CONFIG_ENV_SIZE		(SZ_1K * 16)
+	#define CONFIG_ENV_OFFSET	(SZ_1K * 3136) /* ~3 MiB offset */
+#endif
+
+/* Fastboot SDMMC Partition Table for ODROID(Exynos5422) */
+
+/* BL1		BLK#: 1    (0x0001)  ~    30 (0x001E) */
+/* BL2		BLK#: 31   (0x001F)  ~    62 (0x003E) */
+/* UBOOT	BLK#: 63   (0x003F)  ~  1502 (0x05DE) */
+/* TZSW		BLK#: 1503 (0x05DF)  ~  2014 (0x07DE) */
+/* UBOOT ENV	BLK#: 2015 (0x07DF)  ~  2046 (0x07FE) */
+/* KERNEL	BLK#: 2047 (0x07DF)  ~ 18430 (0x47FE) */
+#define	UBOOT_ENV_ERASE	\
+	"mw.l ${loadaddr} 0 4000;"	\
+	"mmc dev 0;  mmc write ${loadaddr} 0x07df 0x0020;mmc dev 0\0"
+
+#define	UBOOT_COPY_SD2EMMC	\
+	"mmc dev 0;"		\
+	"mmc read  ${loadaddr} 0x0001 0x07de;mmc dev 1;emmc open  1;"	\
+	"mmc write ${loadaddr} 0x0000 0x07de;emmc close 1;mmc dev 0;"	\
+	"mmc dev 1;  mmc write ${loadaddr} 0x07df 0x0020;mmc dev 0\0"	
+
+#define	UBOOT_COPY_EMMC2SD	\
+	"mmc dev 0;"		\
+	"emmc open 0;mmc read  ${loadaddr} 0x0000 0x07de;emmc close 0;"	\
+	"mmc dev 1;  mmc write ${loadaddr} 0x0001 0x07de;mmc dev 0;"	\
+	"mmc dev 1;  mmc write ${loadaddr} 0x07df 0x0020;mmc dev 0\0"	
+
+#define CONFIG_SYS_INIT_SP_ADDR		(CONFIG_SYS_LOAD_ADDR - 0x1000000)
+
+#define CONFIG_DEFAULT_CONSOLE		"console=ttySAC2,115200n8\0"
+
+/* USB */
+#define CONFIG_USB_EHCI_HCD
+#define CONFIG_USB_EHCI_EXYNOS
+
+/* DFU : need enable */
+#define CONFIG_SYS_DFU_DATA_BUF_SIZE	SZ_32M
+#define DFU_DEFAULT_POLL_TIMEOUT	300
+#define DFU_MANIFEST_POLL_TIMEOUT	25000
+
+/* THOR */
+#define CONFIG_G_DNL_THOR_VENDOR_NUM	CONFIG_G_DNL_VENDOR_NUM
+#define CONFIG_G_DNL_THOR_PRODUCT_NUM	0x685D
+#define CONFIG_USB_FUNCTION_THOR
+#define CONFIG_CMD_THOR_DOWNLOAD
+
+/* UMS */
+#define CONFIG_G_DNL_UMS_VENDOR_NUM	0x0525
+#define CONFIG_G_DNL_UMS_PRODUCT_NUM	0xA4A5
+#define CONFIG_USB_FUNCTION_MASS_STORAGE
+
+/* #if defined(CONFIG_USB_DEVICE) */
+/*
+#define CONFIG_USB_DEVICE
+- need function : void udc_disconnect(void), void udc_connedt(void)
+*/
+#if !defined(CONFIG_USB_DEVICE)
+	/*
+	#define CONFIG_EXYNOS_USBD3
+	*/
+	#define EXYNOS_SYSREG_BASE		EXYNOS5_SYSREG_BASE
+	#define EXYNOS_POWER_BASE		EXYNOS5_POWER_BASE
+	/*
+	 * USBD 3.0 SFR
+	 */
+	#define USBDEVICE3_LINK_CH0_BASE	0x12000000
+	#define USBDEVICE3_PHYCTRL_CH0_BASE	0x12100000
+	#define USBDEVICE3_LINK_CH1_BASE	0x12400000
+	#define USBDEVICE3_PHYCTRL_CH1_BASE	0x12500000
+
+	#define EXYNOS_USB_PHY_BASE		EXYNOS5_USBPHY_BASE
+	#define EXYNOS_USB_LINK_BASE		EXYNOS5_USBOTG_BASE
+
+	#if defined(CONFIG_FASTBOOT)
+		#define CFG_FASTBOOT_TRANSFER_BUFFER		(0x50000000)
+
+		/* Download maximum size 1024MB */
+		#define CFG_FASTBOOT_TRANSFER_BUFFER_SIZE	(0x40000000)
+		/* Page size of booting device */
+		#define CFG_FASTBOOT_PAGESIZE			(2048)
+		/* Block size of sdmmc */
+		#define CFG_FASTBOOT_SDMMC_BLOCKSIZE		(512)
+	#endif
+
+	/* cmd from kernel reboot */
+	#define FASTBOOT_MAGIC_REBOOT_CMD		0xFAB0
+	#define FASTBOOT_MAGIC_UPDATE_CMD		0xFADA
+#endif /*#if defined(CONFIG_USB_DEVICE) */
+
+/* FIXME: MUST BE REMOVED AFTER TMU IS TURNED ON */
+#undef CONFIG_EXYNOS_TMU
+#undef CONFIG_TMU_CMD_DTT
+
+#define CONFIG_DFU_ALT_SYSTEM               \
+	"uImage fat 0 1;"                   \
+	"zImage fat 0 1;"                   \
+	"Image.itb fat 0 1;"                \
+	"uInitrd fat 0 1;"                  \
+	"boot.scr fat 0 1;"                 \
+	"boot.cmd fat 0 1;"                 \
+	"exynos5422-odroidxu3.dtb fat 0 1;" \
+	"exynos5422-odroidxu3-lite.dtb fat 0 1;" \
+	"exynos5422-odroidxu4.dtb fat 0 1;" \
+	"boot part 0 1;"                    \
+	"root part 0 2\0"
+
+#define CONFIG_DFU_ALT_BOOT_EMMC           \
+	"u-boot raw 0x3e 0x800 mmcpart 1;" \
+	"bl1 raw 0x0 0x1e mmcpart 1;"      \
+	"bl2 raw 0x1e 0x1d mmcpart 1;"     \
+	"tzsw raw 0x5de 0x200 mmcpart 1;"  \
+	"params.bin raw 0x7df 0x20\0"
+
+#define CONFIG_DFU_ALT_BOOT_SD   \
+	"u-boot raw 0x3f 0x800;" \
+	"bl1 raw 0x1 0x1e;"      \
+	"bl2 raw 0x1f 0x1d;"     \
+	"tzsw raw 0x5df 0x200;"  \
+	"params.bin raw 0x7df 0x20\0"
+
+/* Enable: board/samsung/common/misc.c to use set_dfu_alt_info() */
+#define CONFIG_MISC_COMMON
+#define CONFIG_MISC_INIT_R
+#define CONFIG_SET_DFU_ALT_INFO
+#define CONFIG_SET_DFU_ALT_BUF_LEN	(SZ_1K)
+
+/* Set soc_rev, soc_id, board_rev, boardname, fdtfile */
+#define CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+#define CONFIG_ODROID_REV_AIN			9
+#define CONFIG_REVISION_TAG
+#define CONFIG_BOARD_TYPES
+
+#undef CONFIG_SYS_BOARD
+#define CONFIG_SYS_BOARD	"odroid"
+
+/* Define new extra env settings, including DFU settings */
+#undef CONFIG_EXTRA_ENV_SETTINGS
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	EXYNOS_DEVICE_SETTINGS \
+	EXYNOS_FDTFILE_SETTING \
+	MEM_LAYOUT_ENV_SETTINGS \
+	BOOTENV \
+	"bootdelay=1\0" \
+	"rootfstype=ext4\0" \
+	"console=" CONFIG_DEFAULT_CONSOLE \
+	"fdtfile=exynos5422-odroidxu4.dtb\0" \
+	"board_name=xu4\0" \
+	"mmcbootdev=0\0" \
+	"mmcrootdev=0\0" \
+	"mmcbootpart=1\0" \
+	"mmcrootpart=2\0" \
+	"dfu_alt_system="CONFIG_DFU_ALT_SYSTEM \
+	"dfu_alt_info=Autoset by THOR/DFU command run.\0" \
+	"loadaddr=0x50000000\0" \
+	"env_erase="UBOOT_ENV_ERASE \
+	"copy_uboot_sd2emmc="UBOOT_COPY_SD2EMMC \
+	"copy_uboot_emmc2sd="UBOOT_COPY_EMMC2SD
+
+#undef CONFIG_BOOTCOMMAND
+#define CONFIG_BOOTCOMMAND "cfgload;movi r k 0 40008000;bootz 40008000"
+
+#undef CONFIG_BOOTARGS
+/* Android Default bootargs */
+#define CONFIG_BOOTARGS	"fb_x_res=1280 fb_y_res=720 vout=hdmi led_blink=1 " \
+			"hdmi_phy_res=720p60hz edid=0, hpd=1 disable_vu7=false " \
+			"touch_invert_x=false touch_invert_y=false"
+
+#endif	/* __CONFIG_H */
diff --git a/include/fastboot.h b/include/fastboot.h
old mode 100644
new mode 100755
index 616631e9aa..f70b0403d6
--- a/include/fastboot.h
+++ b/include/fastboot.h
@@ -19,4 +19,203 @@
 void fastboot_fail(const char *reason);
 void fastboot_okay(const char *reason);
 
+#if defined(CONFIG_TARGET_ODROID_XU4) || defined(CONFIG_TARGET_ODROID_XU3)
+
+typedef struct _ext4_file_header {
+	unsigned int magic;
+	unsigned short major;
+	unsigned short minor;
+	unsigned short file_header_size;
+	unsigned short chunk_header_size;
+	unsigned int block_size;
+	unsigned int total_blocks;
+	unsigned int total_chunks;
+	unsigned int crc32;
+}	ext4_file_header;
+
+typedef struct _ext4_chunk_header {
+	unsigned short type;
+	unsigned short reserved;
+	unsigned int chunk_size;
+	unsigned int total_size;
+}	ext4_chunk_header;
+
+#define EXT4_FILE_HEADER_MAGIC	0xED26FF3A
+#define EXT4_FILE_HEADER_MAJOR	0x0001
+#define EXT4_FILE_HEADER_MINOR	0x0000
+#define EXT4_FILE_BLOCK_SIZE	0x1000
+
+#define EXT4_FILE_HEADER_SIZE	(sizeof(ext4_file_header))
+#define EXT4_CHUNK_HEADER_SIZE	(sizeof(ext4_chunk_header))
+
+#define EXT4_CHUNK_TYPE_RAW	0xCAC1
+#define EXT4_CHUNK_TYPE_FILL	0xCAC2
+#define EXT4_CHUNK_TYPE_NONE	0xCAC3
+
+/* This is the interface file between the common cmd_fastboot.c and
+   the board specific support.
+
+   To use this interface, define CONFIG_FASTBOOT in your board config file.
+   An example is include/configs/omap3430labrador.h
+   ...
+   #define CONFIG_FASTBOOT	        1    / * Using fastboot interface * /
+   ...
+
+   An example of the board specific spupport for omap3 is found at
+   cpu/omap3/fastboot.c
+
+*/
+
+/* From fastboot client.. */
+#define FASTBOOT_INTERFACE_CLASS     0xff
+#define FASTBOOT_INTERFACE_SUB_CLASS 0x42
+#define FASTBOOT_INTERFACE_PROTOCOL  0x03
+
+#define FASTBOOT_VERSION "0.4"
+
+/* The fastboot client uses a value of 2048 for the
+   page size of it boot.img file format.
+   Reset this in your board config file as needed. */
+#ifndef CFG_FASTBOOT_MKBOOTIMAGE_PAGE_SIZE
+#define CFG_FASTBOOT_MKBOOTIMAGE_PAGE_SIZE 2048
+#endif
+
+struct cmd_fastboot_interface
+{
+	/* This function is called when a buffer has been
+	   recieved from the client app.
+	   The buffer is a supplied by the board layer and must be unmodified.
+	   The buffer_size is how much data is passed in.
+	   Returns 0 on success
+	   Returns 1 on failure
+
+	   Set by cmd_fastboot	*/
+	int (*rx_handler)(const unsigned char *buffer,
+			  unsigned int buffer_size);
+
+	/* This function is called when an exception has
+	   occurred in the device code and the state
+	   off fastboot needs to be reset
+
+	   Set by cmd_fastboot */
+	void (*reset_handler)(void);
+
+	/* A getvar string for the product name
+	   It can have a maximum of 60 characters
+
+	   Set by board	*/
+	char *product_name;
+
+	/* A getvar string for the serial number
+	   It can have a maximum of 60 characters
+
+	   Set by board */
+	char *serial_no;
+
+	/* Nand block size
+	   Supports the write option WRITE_NEXT_GOOD_BLOCK
+
+	   Set by board */
+	unsigned int nand_block_size;
+
+	/* Transfer buffer, for handling flash updates
+	   Should be multiple of the nand_block_size
+	   Care should be take so it does not overrun bootloader memory
+	   Controlled by the configure variable CFG_FASTBOOT_TRANSFER_BUFFER
+
+	   Set by board */
+	unsigned char *transfer_buffer;
+
+	/* How big is the transfer buffer
+	   Controlled by the configure variable
+	   CFG_FASTBOOT_TRANSFER_BUFFER_SIZE
+
+	   Set by board	*/
+	unsigned int transfer_buffer_size;
+};
+
+/* Status values */
+#define FASTBOOT_OK			0
+#define FASTBOOT_ERROR			-1
+#define FASTBOOT_DISCONNECT		1
+#define FASTBOOT_INACTIVE		2
+
+/* Magic string to enable fastboot during preboot */
+#define FASTBOOT_REBOOT_MAGIC		"REBOOT-FASTBOOT"
+#define FASTBOOT_REBOOT_MAGIC_SIZE	15
+
+/* Android bootimage file format */
+#define FASTBOOT_BOOT_MAGIC "ANDROID!"
+#define FASTBOOT_BOOT_MAGIC_SIZE	8
+#define FASTBOOT_BOOT_NAME_SIZE		16
+#define FASTBOOT_BOOT_ARGS_SIZE		512
+
+/* Input of fastboot_tx_status */
+#define FASTBOOT_TX_ASYNC		0
+#define FASTBOOT_TX_SYNC		1
+
+#if defined(CONFIG_FASTBOOT)
+/* A board specific test if u-boot should go into the fastboot command
+   ahead of the bootcmd
+   Returns 0 to continue with normal u-boot flow
+   Returns 1 to execute fastboot */
+extern int fastboot_preboot(void);
+
+/* Initizes the board specific fastboot
+   Returns 0 on success
+   Returns 1 on failure */
+extern int fastboot_init(struct cmd_fastboot_interface *interface);
+
+/* Cleans up the board specific fastboot */
+extern void fastboot_shutdown(void);
+
+/*
+ * Handles board specific usb protocol exchanges
+ * Returns 0 on success
+ * Returns 1 on disconnects, break out of loop
+ * Returns 2 if no USB activity detected
+ * Returns -1 on failure, unhandled usb requests and other error conditions
+*/
+extern int fastboot_poll(void);
+
+/* Is this high speed (2.0) or full speed (1.1) ?
+   Returns 0 on full speed
+   Returns 1 on high speed */
+extern int fastboot_is_highspeed(void);
+
+/* Return the size of the fifo */
+extern int fastboot_fifo_size(void);
+
+/* Send a status reply to the client app
+   buffer does not have to be null terminated.
+   buffer_size must be not be larger than what is returned by
+   fastboot_fifo_size
+   Returns 0 on success
+   Returns 1 on failure */
+extern int fastboot_tx_status(const char *buffer, unsigned int buffer_size, const u32 need_sync_flag);
+
+/* A board specific variable handler.
+   The size of the buffers is governed by the fastboot spec.
+   rx_buffer is at most 57 bytes
+   tx_buffer is at most 60 bytes
+   Returns 0 on success
+   Returns 1 on failure */
+extern int fastboot_getvar(const char *rx_buffer, char *tx_buffer);
+
+#else
+
+/* Stubs for when CONFIG_FASTBOOT is not defined */
+#define fastboot_preboot() 0
+#define fastboot_init(a) 1
+#define fastboot_shutdown()
+#define fastboot_poll() 1
+#define fastboot_is_highspeed() 0
+#define fastboot_fifo_size() 0
+#define fastboot_tx_status(a, b, c) 1
+#define fastboot_getvar(a,b) 1
+
+#endif /* CONFIG_FASTBOOT */
+
+#endif /* #if defined(CONFIG_TARGET_ODROID_XU4) || defined(CONFIG_TARGET_ODROID_XU3) */
+
 #endif /* _FASTBOOT_H_ */
diff --git a/include/fat.h b/include/fat.h
old mode 100644
new mode 100755
index 71879f01ca..59eec26439
--- a/include/fat.h
+++ b/include/fat.h
@@ -95,6 +95,108 @@
 					((fatsize) != 16 ? 0xff0 : 0xfff0) : \
 					0xffffff0))
 
+#define FATBUFSIZE	(mydata->sect_size * FATBUFBLOCKS)
+#define FAT12BUFSIZE	((FATBUFSIZE*2)/3)
+#define FAT16BUFSIZE	(FATBUFSIZE/2)
+#define FAT32BUFSIZE	(FATBUFSIZE/4)
+#define FATBUFBLOCKS	6
+
+#define mk1(p, x)			\
+	(p) = (__u8)(x)
+
+#define mk2(p, x)			\
+	(p)[0] = (__u8)(x),		\
+	(p)[1] = (__u8)((x) >> 010)
+
+#define mk4(p, x)			\
+	(p)[0] = (__u8)(x),		\
+	(p)[1] = (__u8)((x) >> 010),	\
+	(p)[2] = (__u8)((x) >> 020),	\
+	(p)[3] = (__u8)((x) >> 030)
+
+struct bs {
+	__u8 jmp[3];		/* bootstrap entry point */
+	__u8 oem[9];		/* OEM name and version */
+};
+
+struct bsbpb {
+	__u8 bps[2];		/* bytes per sector */
+	__u8 spc;		/* sectors per cluster */
+	__u8 res[2];		/* reserved sectors */
+	__u8 nft;		/* number of FATs */
+	__u8 rde[2];		/* root directory entries */
+	__u8 sec[2];		/* total sectors */
+	__u8 mid;		/* media descriptor */
+	__u8 spf[2];		/* sectors per FAT */
+	__u8 spt[2];		/* sectors per track */
+	__u8 hds[2];		/* drive heads */
+	__u8 hid[4];		/* hidden sectors */
+	__u8 bsec[6];		/* big total sectors */
+};
+
+/* For FAT32 */
+struct bsxbpb {
+	__u8 bspf[4];		/* big sectors per FAT */
+	__u8 xflg[2];		/* FAT control flags */
+	__u8 vers[2];		/* file system version */
+	__u8 rdcl[4];		/* root directory start cluster */
+	__u8 infs[2];		/* file system info sector */
+	__u8 bkbs[2];		/* backup boot sector */
+	__u8 rsvd[12];		/* reserved */
+};
+
+struct bpb {
+	__u32 bps;		/* bytes per sector */
+	__u32 spc;		/* sectors per cluster */
+	__u32 res;		/* reserved sectors */
+	__u32 nft;		/* number of FATs */
+	__u32 rde;		/* root directory entries */
+	__u32 sec;		/* total sectors */
+	__u32 mid;		/* media descriptor */
+	__u32 spf;		/* sectors per FAT */
+	__u32 spt;		/* sectors per track */
+	__u32 hds;		/* drive heads */
+	__u32 hid;		/* hidden sectors */
+	__u32 bsec;		/* big total sectors */
+	__u32 bspf;		/* big sectors per FAT */
+	__u32 rdcl;		/* root directory start cluster */
+	__u32 infs;		/* file system info sector */
+	__u32 bkbs;		/* backup boot sector */
+};
+
+struct bsx {
+	__u8 drv;		/* drive number */
+	__u8 rsvd;		/* reserved */
+	__u8 sig;		/* extended boot signature */
+	__u8 volid[4];		/* volume ID number */
+	__u8 label[11];		/* volume label */
+	__u8 type[8];		/* file system type */
+};
+
+struct de {
+	__u8 namext[11];	/* name and extension */
+	__u8 attr;		/* attributes */
+	__u8 rsvd[10];		/* reserved */
+	__u8 time[2];		/* creation time */
+	__u8 date[2];		/* creation date */
+	__u8 clus[2];		/* starting cluster */
+	__u8 size[4];		/* size */
+};
+
+#define SECTOR_SIZE	512
+#define BYTE_PER_SEC	512
+#define RESERVED_CNT	32
+#define DOS_PART_TBL_OFFSET	0x1be
+#define DOS_PART_MAGIC_OFFSET	0x1fe
+#define DOS_FS_TYPE_OFFSET	0x36
+#define DOS_FS32_TYPE_OFFSET	0x52
+
+/* Filesystem identifiers */
+#define FAT12_SIGN	"FAT12   "
+#define FAT16_SIGN	"FAT16   "
+#define FAT32_SIGN	"FAT32   "
+#define SIGNLEN		8
+
 typedef struct boot_sector {
 	__u8	ignored[3];	/* Bootstrap code */
 	char	system_id[8];	/* Name of fs */
@@ -211,4 +313,7 @@ int file_fat_write(const char *filename, void *buf, loff_t offset, loff_t len,
 int fat_read_file(const char *filename, void *buf, loff_t offset, loff_t len,
 		  loff_t *actread);
 void fat_close(void);
+
+int do_format(struct blk_desc *dev_desc, int part_no);
+
 #endif /* _FAT_H_ */
diff --git a/include/mmc.h b/include/mmc.h
old mode 100644
new mode 100755
index 010ebe048c..5b85c86caa
--- a/include/mmc.h
+++ b/include/mmc.h
@@ -602,4 +602,9 @@ int mmc_get_env_dev(void);
  */
 struct blk_desc *mmc_get_blk_desc(struct mmc *mmc);
 
+#ifdef CONFIG_SUPPORT_EMMC_BOOT
+int emmc_boot_open(struct mmc *mmc);
+int emmc_boot_close(struct mmc *mmc);
+#endif
+
 #endif /* _MMC_H_ */
diff --git a/include/samsung/odroid_misc.h b/include/samsung/odroid_misc.h
new file mode 100755
index 0000000000..32b5ee58c9
--- /dev/null
+++ b/include/samsung/odroid_misc.h
@@ -0,0 +1,61 @@
+#ifndef __ODROID_MISC_H__
+#define __ODROID_MISC_H__
+
+#include <asm/gpio.h>
+
+#define	GPIO_LED_G	EXYNOS5420_GPIO_B21
+#define	GPIO_LED_B	EXYNOS5420_GPIO_B22
+#define	GPIO_LED_R	EXYNOS5420_GPIO_X23
+
+#define	GPIO_POWER_BT	EXYNOS5420_GPIO_X03
+#define	GPIO_FAN_CTL	EXYNOS5420_GPIO_B20
+#define	GPIO_LCD_PWM	EXYNOS5420_GPIO_B23
+
+#define	BOOT_EMMC	0x6
+#define	BOOT_EMMC_4_4	0x7
+
+/* Self update option */
+#define	OPTION_ERASE_USERDATA	0x01
+#define	OPTION_ERASE_FAT	0x02
+#define	OPTION_ERASE_ENV	0x04
+#define	OPTION_UPDATE_UBOOT	0x08
+#define	OPTION_RESIZE_PART	0x10
+#define	OPTION_FILELOAD_EXT4	0x20
+#define	OPTION_OLDTYPE_PART	0x40
+
+enum	{
+	PART_FWBL1 = 0,
+	PART_BL2,
+	PART_BOOTLOADER,
+	PART_TZSW,
+	PART_ENV,
+	PART_KERNEL,
+	PART_FAT,
+	PART_SYSTEM,
+	PART_USERDATA,
+	PART_CACHE,
+	PART_MAX
+};
+
+struct partition_info {
+	const char	name[16];	/* partition name */
+	u64		blk_start;	/* start blk number */
+	u64		size;		/* size in bytes */
+	unsigned int	raw_en;		/* raw access enable for emmc */
+};
+
+struct upload_info {
+	char	part_name[16];
+	uint	mem_addr;
+	uint	file_size;
+};
+
+extern	int odroid_get_partition_info	(const char *ptn, struct partition_info *pinfo);
+extern	int odroid_partition_setup	(char *dev_no);
+
+extern	void odroid_led_ctrl	(int gpio, int status);
+extern	void odroid_self_update	(uint option);
+extern	void odroid_misc_init	(void);
+extern	void odroid_power_off	(void);
+
+#endif /* __ODROID_MISC_H__ */
